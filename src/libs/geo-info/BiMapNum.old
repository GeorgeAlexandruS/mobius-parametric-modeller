import { BiMapManyToOne } from './BiMap';
/**
 * A bi-directional map that stores many-to-one key value mappings for numbers.
 * Both the keys and values must be unique.
 */
export class BiMapManyToOneNum extends BiMapManyToOne<number> {
    // TODO should avoid over writing existing data
    /**
     * Assumes that the array index is the key, and the array value is the value
     * [3,5,3] means 0->3, 1->5, 2->3
     * @param data
     */
    public addDataArray(data: Array<number>, offset: number = 0): void {
        data.forEach((value, key) => this.set(key + offset, value));
    }
}
/**
 * A bi-directional map that stores one-to-many key value mappings for numbers.
 * Both the keys and values must be unique.
 */
export class BiMapOneToManyNum {
    private readonly kv_map = new Map<number, number[]>();
    private readonly vk_map = new Map<number, number>();
    constructor(data?: Array<[number, number[]]>) {
        if (data) {
            this.setData(data);
        }
    }
    public setData(data: Array<[number, number[]]>): void {
        data.forEach(key_values => {
            this.kv_map.set(key_values[0], key_values[1]);
            key_values[1].forEach(value => this.vk_map.set(value, key_values[0]));
        });
    }
    public set(key: number, values: number[]): void {
        values.forEach(value => this.vk_map.set(value, key));
        this.kv_map.set(key, values);
    }
    public valuesArrays(): Array<number[]> {
        return Array.from(this.kv_map.values());
    }
    public values(): number[] {
        return Array.from(this.vk_map.keys());
    }
    public keys(): number[] {
        return Array.from(this.kv_map.keys());
    }
    public getValues(key: number): number[] {
        return this.kv_map.get(key);
    }
    public getKey(value: number): number {
        return this.vk_map.get(value);
    }
    public hasKey(key: number): boolean {
        return this.kv_map.has(key);
    }
    public hasValue(value: number): boolean {
        return this.vk_map.has(value);
    }
    public numKeys(): number {
        return this.kv_map.size;
    }
    public numValues(): number {
        return this.vk_map.size;
    }
    public getData(): Array<[number, number[]]> {
        return Array.from(this.kv_map);
    }
    // TODO should avoid over writing existing data
    public addData(data: Array<[number, number[]]>): void {
        data.forEach(key_values => {
            this.kv_map.set(key_values[0], key_values[1]);
            key_values[1].forEach(value => this.vk_map.set(value, key_values[0]));
        });
    }
    // TODO should avoid over writing existing data
    /**
     * Assumes that the array index is the key, and the array value is the value
     * [[1,2],[3,4],[5]] means 0->[1,2], 1->[3,4], 2->[5]
     * @param data
     */
    public addDataArray(data: Array<number[]>, offset: number = 0): void {
        data.forEach((value, key) => this.set(key + offset, value));
    }
}
/**
 * A bi-directional map that stores one-to-one key value mappings for numbers.
 * Both the keys and values must be unique.
 */
export class BiMapOneToOneNum {
    private readonly kv_map = new Map<number, number>();
    private readonly vk_map = new Map<number, number>();
    constructor(data?: Array<[number, number]>) {
        if (data) {
            this.setData(data);
        }
    }
    public setData(data: Array<[number, number]>) {
        data.forEach(keys_value => {
            this.vk_map.set(keys_value[1], keys_value[0]);
            this.kv_map.set(keys_value[0], keys_value[1]);
        });
    }
    public set(key: number, value: number): void {
        this.vk_map.set(value, key);
        this.kv_map.set(key, value);
    }
    public values(): Array<V> {
        return Array.from(this.vk_map.keys());
    }
    public keys(): number[] {
        return Array.from(this.kv_map.keys());
    }
    public getValue(key: number): number {
        return this.kv_map.get(key);
    }
    public getKey(value: number): number {
        return this.vk_map.get(value);
    }
    public hasKey(key: number): boolean {
        return this.kv_map.has(key);
    }
    public hasValue(value: number): boolean {
        return this.vk_map.has(value);
    }
    public numKeys(): number {
        return this.kv_map.size;
    }
    public numValues(): number {
        return this.vk_map.size;
    }
    public getData(): Array<[number, number]> {
        return Array.from(this.kv_map);
    }
    public addData(data: Array<[number, number]>): void {
        data.forEach(key_value => this.set(key_value[0], key_value[1]));
    }
    /**
     * Assumes that the array index is the key, and the array value is the value
     * For example, [4,7,8] means 0->4, 1->7, 2->8.
     * If offset is set, array index will be offset by this number.
     * So in the example, if offset=3, then 3->4, 4->7, 5->8.
     * @param data
     */
    public addDataArray(data: number[], offset: number = 0): void {
        data.forEach((value, key) => this.set(key + offset, value));
    }
}