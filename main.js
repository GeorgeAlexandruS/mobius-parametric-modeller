(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["main"],{

/***/ "./src/$$_lazy_route_resource lazy recursive":
/*!**********************************************************!*\
  !*** ./src/$$_lazy_route_resource lazy namespace object ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function webpackEmptyAsyncContext(req) {
	// Here Promise.resolve().then() is used instead of new Promise() to prevent
	// uncaught exception popping up in devtools
	return Promise.resolve().then(function() {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	});
}
webpackEmptyAsyncContext.keys = function() { return []; };
webpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;
module.exports = webpackEmptyAsyncContext;
webpackEmptyAsyncContext.id = "./src/$$_lazy_route_resource lazy recursive";

/***/ }),

/***/ "./src/app/appmodule/app.component.html":
/*!**********************************************!*\
  !*** ./src/app/appmodule/app.component.html ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\r\n<div class='container'>\r\n    <as-split direction=\"horizontal\">\r\n        <as-split-area size=\"50\">\r\n            <div class='container__header'>\r\n\r\n                <!-- top left tab menu  -->\r\n                <div class=\"tab\">\r\n                    <button class='btn-tab' [class.active]='activeView==\"publish\"' (click)='updateView(\"publish\")'>Publish</button>\r\n                    <button class='btn-tab' [class.active]='activeView==\"flowchart\"' (click)='updateView(\"flowchart\")'>Flowchart</button>\r\n                    <!--\r\n                    <button class='btn' [class.active]='false' (click)='updateView(\"editor\")'>Procedures</button>\r\n                    -->\r\n                </div>\r\n\r\n                <!-- hidden components (new file, save file, loaf file) for the dropdown menu-->\r\n                <div style=\"display: none;\">\r\n                    <file-new (create)='updateFile($event)'></file-new>\r\n                    <file-save [file]='file'></file-save>\r\n                    <file-load (loaded)='updateFile($event)'></file-load>        \r\n                </div>\r\n\r\n                <!-- top right dropdown menu -->\r\n                <div class=\"dropmenu\">\r\n                    <!-- execute button -->\r\n                    <div>\r\n                        <execute [flowchart]='flowchart'></execute>\r\n                    </div>\r\n                    <!-- dropdown menu for new file, save file, loaf file-->\r\n                    <div>\r\n                        <button class='btn' mat-icon-button [matMenuTriggerFor]=\"menu\">\r\n                            <mat-icon>more_vert</mat-icon>\r\n                        </button>\r\n                        <mat-menu #menu=\"matMenu\">\r\n                            <button  mat-menu-item onclick=\"document.getElementById('newfile').click();\"\r\n                            title=\"Reset Flowchart to Default\">\r\n                                <mat-icon>rotate_left</mat-icon>\r\n                                <span>Reset</span>\r\n                            </button>\r\n                            <button mat-menu-item onclick=\"document.getElementById('savefile').click();\"\r\n                            title=\"Save Flowchart File to Computer\">\r\n                                <mat-icon>save_alt</mat-icon>\r\n                                <span>Save File</span>\r\n                            </button>\r\n                            <button mat-menu-item onclick=\"document.getElementById('file-input').click();\"\r\n                            title=\"Load Flowchart File from Computer\">\r\n                                <mat-icon>launch</mat-icon>\r\n                                <span>Load File</span>\r\n                            </button>\r\n                        </mat-menu>\r\n                    </div>\r\n                    \r\n                </div>\r\n            </div>\r\n            <!-- viewchild content -->\r\n            <div class='content__panel'>\r\n                <ng-container #vc></ng-container>\r\n            </div>\r\n        </as-split-area>\r\n\r\n        <as-split-area size=\"50\">\r\n            <!-- mViewer panel -->\r\n            <div class='content__panel' >\r\n                <mviewer [node]='flowchart.nodes[flowchart.meta.selected_nodes[0]]'></mviewer>\r\n            </div>\r\n        </as-split-area>\r\n        \r\n\r\n    </as-split>\r\n\r\n</div>\r\n\r\n"

/***/ }),

/***/ "./src/app/appmodule/app.component.scss":
/*!**********************************************!*\
  !*** ./src/app/appmodule/app.component.scss ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ".container {\n  position: relative;\n  overflow: auto;\n  height: 100%;\n  width: 100%;\n  display: flex;\n  flex-direction: column;\n  justify-content: space-around; }\n  .container h1, .container h2, .container h3, .container h4, .container h5, .container h6, .container p {\n    margin: 0px;\n    padding: 0px; }\n  .container .container__header {\n    flex: 0 1 auto;\n    min-height: 35px;\n    display: flex;\n    flex-direction: row;\n    justify-content: space-between;\n    padding: 0px 0px 0px 15px;\n    background-color: #ccc;\n    border-bottom: 3px solid #eeeeee;\n    line-height: 35px;\n    font-size: 18px;\n    font-weight: 600;\n    text-align: center;\n    /* tab styling */\n    /* dropdown menu styling */ }\n  .container .container__header .tab {\n      border: 2px;\n      overflow: hidden;\n      background-color: #ccc; }\n  .container .container__header .tab button {\n      display: inline-block;\n      vertical-align: bottom;\n      background-color: inherit;\n      color: #505050;\n      border: none;\n      outline: none;\n      cursor: pointer;\n      padding: 8px 10px;\n      transition: 0.3s;\n      font-size: 14px; }\n  .container .container__header .tab button:hover {\n      color: blue; }\n  .container .container__header .tab button.active {\n      background-color: #ccc;\n      color: #000096;\n      font-weight: 600;\n      border-color: #222 !important; }\n  .container .container__header .dropmenu {\n      display: inline-flex; }\n  .container .container__content {\n    flex-grow: 1;\n    height: 0px;\n    border: 2px solid #3F4651;\n    overflow: auto; }\n  .container .container__footer {\n    text-align: center;\n    font-size: 12px;\n    line-height: 18px;\n    background-color: #3F4651;\n    color: #E7BF00; }\n  .content__panel {\n  background-color: gainsboro;\n  height: 100%;\n  overflow: auto; }\n  ul.nav {\n  margin: 0px;\n  padding: 0px; }\n  li.link {\n  display: inline;\n  border: 2px solid gray;\n  border-radius: 4px;\n  margin: 5px 5px 0px 0px;\n  padding: 5px;\n  text-transform: uppercase;\n  line-height: 12px;\n  font-weight: 600;\n  cursor: pointer;\n  font-size: 12px; }\n  li.link:hover {\n  background-color: gray;\n  color: white; }\n  button.btn {\n  display: inline-block;\n  vertical-align: middle;\n  margin: 0px 0px 0px 0px;\n  font-size: 12px;\n  line-height: 10px;\n  height: 30px;\n  border: none;\n  border-radius: 4px;\n  background-color: transparent;\n  color: #505050; }\n  button.btn:hover {\n  color: blue; }\n  .active {\n  background-color: #222;\n  color: white;\n  border-color: #222 !important; }\n"

/***/ }),

/***/ "./src/app/appmodule/app.component.ts":
/*!********************************************!*\
  !*** ./src/app/appmodule/app.component.ts ***!
  \********************************************/
/*! exports provided: AppComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AppComponent", function() { return AppComponent; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var _views__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @views */ "./src/app/views/index.ts");
/* harmony import */ var _services__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @services */ "./src/app/core/services/index.ts");
/* harmony import */ var circular_json__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! circular-json */ "./node_modules/circular-json/build/circular-json.node.js");
/* harmony import */ var circular_json__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(circular_json__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _ngFlowchart_svg_flowchart_component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../ngFlowchart-svg/flowchart.component */ "./src/app/ngFlowchart-svg/flowchart.component.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





var AppComponent = /** @class */ (function () {
    function AppComponent(dataService, injector, r) {
        this.dataService = dataService;
        this.injector = injector;
        this.r = r;
        this.views = [];
        this.Viewers = {
            "editor": _views__WEBPACK_IMPORTED_MODULE_1__["ViewEditorComponent"],
            "publish": _views__WEBPACK_IMPORTED_MODULE_1__["ViewPublishComponent"],
            "flowchart": _ngFlowchart_svg_flowchart_component__WEBPACK_IMPORTED_MODULE_4__["FlowchartComponent"] // src/ngFlowchart-svg/
        };
        this.file = dataService.file;
        this.flowchart = dataService.flowchart;
    }
    AppComponent.prototype.ngOnInit = function () {
        this.activeView = "flowchart";
        this.updateView("flowchart");
    };
    AppComponent.prototype.updateFile = function (event) {
        this.dataService.file = circular_json__WEBPACK_IMPORTED_MODULE_3__["parse"](event);
        this.file = this.dataService.file;
        this.flowchart = this.dataService.flowchart;
        this.updateValue();
    };
    AppComponent.prototype.createView = function (view) {
        var _this = this;
        var component = this.Viewers[view];
        var factory = this.r.resolveComponentFactory(component);
        var componentRef = factory.create(this.injector);
        if (view == "flowchart") {
            componentRef.instance["data"] = this.flowchart;
            componentRef.instance["switch"].subscribe(function (data) { return _this.updateView(data); });
        }
        else if (view == "editor") {
            componentRef.instance["flowchart"] = this.flowchart;
            componentRef.instance["node"] = this.flowchart.nodes[this.flowchart.meta.selected_nodes[0]];
        }
        else if (view == "publish") {
            componentRef.instance["flowchart"] = this.flowchart;
        }
        return componentRef;
    };
    AppComponent.prototype.updateView = function (view) {
        this.activeView = view;
        if (this.views[view] == undefined) {
            this.views[view] = this.createView(view);
        }
        else
            this.updateValue();
        this.vc.detach();
        this.vc.insert(this.views[view].hostView);
    };
    AppComponent.prototype.updateValue = function () {
        for (var view in this.Viewers) {
            if (!this.views[view])
                continue;
            var componentRef = this.views[view];
            if (view == "flowchart") {
                componentRef.instance["data"] = this.flowchart;
            }
            else if (view == "editor") {
                componentRef.instance["flowchart"] = this.flowchart;
                componentRef.instance["node"] = this.flowchart.nodes[this.flowchart.meta.selected_nodes[0]];
            }
            else if (view == "publish") {
                componentRef.instance["flowchart"] = this.flowchart;
            }
        }
    };
    __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"])('vc', { read: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewContainerRef"] }),
        __metadata("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewContainerRef"])
    ], AppComponent.prototype, "vc", void 0);
    AppComponent = __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"])({
            selector: 'app-root',
            template: __webpack_require__(/*! ./app.component.html */ "./src/app/appmodule/app.component.html"),
            styles: [__webpack_require__(/*! ./app.component.scss */ "./src/app/appmodule/app.component.scss")]
        }),
        __metadata("design:paramtypes", [_services__WEBPACK_IMPORTED_MODULE_2__["DataService"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["Injector"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["ComponentFactoryResolver"]])
    ], AppComponent);
    return AppComponent;
}());



/***/ }),

/***/ "./src/app/appmodule/app.module.ts":
/*!*****************************************!*\
  !*** ./src/app/appmodule/app.module.ts ***!
  \*****************************************/
/*! exports provided: AppModule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AppModule", function() { return AppModule; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var _angular_platform_browser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/platform-browser */ "./node_modules/@angular/platform-browser/fesm5/platform-browser.js");
/* harmony import */ var _angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/platform-browser/animations */ "./node_modules/@angular/platform-browser/fesm5/animations.js");
/* harmony import */ var _angular_common_http__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/common/http */ "./node_modules/@angular/common/fesm5/http.js");
/* harmony import */ var _app_component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./app.component */ "./src/app/appmodule/app.component.ts");
/* harmony import */ var _views__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @views */ "./src/app/views/index.ts");
/* harmony import */ var _shared_shared_module__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @shared/shared.module */ "./src/app/shared/shared.module.ts");
/* harmony import */ var _services__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @services */ "./src/app/core/services/index.ts");
/* harmony import */ var _ngFlowchart_svg_flowchart_component__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../ngFlowchart-svg/flowchart.component */ "./src/app/ngFlowchart-svg/flowchart.component.ts");
/* harmony import */ var _angular_material__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @angular/material */ "./node_modules/@angular/material/esm5/material.es5.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




//import { AppRoutingModule } from './app-routing.module';









var AppModule = /** @class */ (function () {
    function AppModule() {
    }
    AppModule = __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"])({
            declarations: [
                _app_component__WEBPACK_IMPORTED_MODULE_4__["AppComponent"],
            ],
            imports: [
                _angular_platform_browser__WEBPACK_IMPORTED_MODULE_1__["BrowserModule"],
                _angular_platform_browser_animations__WEBPACK_IMPORTED_MODULE_2__["BrowserAnimationsModule"],
                _angular_common_http__WEBPACK_IMPORTED_MODULE_3__["HttpClientModule"],
                //FormsModule,
                //AppRoutingModule,
                //CoreModule,
                _views__WEBPACK_IMPORTED_MODULE_5__["ViewEditorModule"],
                _views__WEBPACK_IMPORTED_MODULE_5__["ViewPublishModule"],
                _shared_shared_module__WEBPACK_IMPORTED_MODULE_6__["SharedModule"],
                _angular_material__WEBPACK_IMPORTED_MODULE_9__["MatMenuModule"],
                _angular_material__WEBPACK_IMPORTED_MODULE_9__["MatIconModule"],
                _angular_material__WEBPACK_IMPORTED_MODULE_9__["MatButtonModule"],
            ],
            entryComponents: [
                _views__WEBPACK_IMPORTED_MODULE_5__["ViewEditorComponent"],
                _views__WEBPACK_IMPORTED_MODULE_5__["ViewPublishComponent"],
                _ngFlowchart_svg_flowchart_component__WEBPACK_IMPORTED_MODULE_8__["FlowchartComponent"],
            ],
            providers: [_services__WEBPACK_IMPORTED_MODULE_7__["DataService"]],
            bootstrap: [_app_component__WEBPACK_IMPORTED_MODULE_4__["AppComponent"]]
        }),
        __metadata("design:paramtypes", [])
    ], AppModule);
    return AppModule;
}());



/***/ }),

/***/ "./src/app/core/modules/_error_msgs_dev.ts":
/*!*************************************************!*\
  !*** ./src/app/core/modules/_error_msgs_dev.ts ***!
  \*************************************************/
/*! exports provided: checkEnt, checkEntList, notEnt, notEntInList, entNotExist, mustBeEntList, entListTooFew, entInOtherModel, checkObjID, checkObj, checkObjList, checkObjsSameModel, objNotExist, objInOtherModel, objWrongType, pointNotExist, objListTooFew, objListEmpty, mustBeObjList, checkPointID, checkPoint, checkPointList, checkPointNestedList, checkPointsSameModel, pointInOtherModel, pointListEmpty, pointListTooFew, pointNestedListTooFew, pointNestedListJagged, mustBePointList, mustBePointNestedList, invalidID, mustBeIDList, checkGroup, groupNotExist, checkXYZ, xyzWrongLength, xyzInvalidData, xyzNotList, checkNum, checkPosNum, checkPosNums, checkNumListLength, argMustBeNumList, argNumListWrongLength, numMustBePos, argUndefined */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkEnt", function() { return checkEnt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkEntList", function() { return checkEntList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "notEnt", function() { return notEnt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "notEntInList", function() { return notEntInList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "entNotExist", function() { return entNotExist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mustBeEntList", function() { return mustBeEntList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "entListTooFew", function() { return entListTooFew; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "entInOtherModel", function() { return entInOtherModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkObjID", function() { return checkObjID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkObj", function() { return checkObj; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkObjList", function() { return checkObjList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkObjsSameModel", function() { return checkObjsSameModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "objNotExist", function() { return objNotExist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "objInOtherModel", function() { return objInOtherModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "objWrongType", function() { return objWrongType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pointNotExist", function() { return pointNotExist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "objListTooFew", function() { return objListTooFew; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "objListEmpty", function() { return objListEmpty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mustBeObjList", function() { return mustBeObjList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkPointID", function() { return checkPointID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkPoint", function() { return checkPoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkPointList", function() { return checkPointList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkPointNestedList", function() { return checkPointNestedList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkPointsSameModel", function() { return checkPointsSameModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pointInOtherModel", function() { return pointInOtherModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pointListEmpty", function() { return pointListEmpty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pointListTooFew", function() { return pointListTooFew; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pointNestedListTooFew", function() { return pointNestedListTooFew; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pointNestedListJagged", function() { return pointNestedListJagged; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mustBePointList", function() { return mustBePointList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mustBePointNestedList", function() { return mustBePointNestedList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invalidID", function() { return invalidID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mustBeIDList", function() { return mustBeIDList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkGroup", function() { return checkGroup; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "groupNotExist", function() { return groupNotExist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkXYZ", function() { return checkXYZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "xyzWrongLength", function() { return xyzWrongLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "xyzInvalidData", function() { return xyzInvalidData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "xyzNotList", function() { return xyzNotList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkNum", function() { return checkNum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkPosNum", function() { return checkPosNum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkPosNums", function() { return checkPosNums; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkNumListLength", function() { return checkNumListLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "argMustBeNumList", function() { return argMustBeNumList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "argNumListWrongLength", function() { return argNumListWrongLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "numMustBePos", function() { return numMustBePos; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "argUndefined", function() { return argUndefined; });
/* harmony import */ var gs_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gs-json */ "./node_modules/gs-json/dist2015/index.js");
/* harmony import */ var gs_json__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(gs_json__WEBPACK_IMPORTED_MODULE_0__);
/**
 * Objects are a type of entity. They consist of conics, polylines, polymeshes, planes and rays.
 *
 * Objects are formed by a combination of topologies. More information can be found on the page for topo.
 */
var __values = (undefined && undefined.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};

//  ===============================================================================================================
//  Error messages for end users ====================================================================================================
//  ===============================================================================================================
// Entities ====================================================================================================
function checkEnt(ent) {
    if (!(ent instanceof gs_json__WEBPACK_IMPORTED_MODULE_0__["Ent"])) {
        notEnt();
    }
    if (!ent.exists()) {
        entNotExist();
    }
    return ent.getModel();
}
function checkEntList(ents, min_len) {
    var e_1, _a;
    if (!Array.isArray(ents)) {
        mustBeEntList();
    }
    if (ents.length < min_len) {
        objListTooFew();
    }
    if (!(ents[0] instanceof gs_json__WEBPACK_IMPORTED_MODULE_0__["Ent"])) {
        notEntInList();
    }
    var model = ents[0].getModel();
    try {
        for (var ents_1 = __values(ents), ents_1_1 = ents_1.next(); !ents_1_1.done; ents_1_1 = ents_1.next()) {
            var ent = ents_1_1.value;
            if (!(ent instanceof gs_json__WEBPACK_IMPORTED_MODULE_0__["Ent"])) {
                notEntInList();
            }
            if (!ent.exists()) {
                entNotExist();
            }
            if (ent.getModel() !== model) {
                entInOtherModel();
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (ents_1_1 && !ents_1_1.done && (_a = ents_1.return)) _a.call(ents_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return model;
}
function notEnt() {
    throw new Error("The argument must be a point or object.");
}
function notEntInList() {
    throw new Error("One of the items in the list was neither a point nor an object.");
}
function entNotExist() {
    throw new Error("Point or object does not exist. It was probably deleted.");
}
function mustBeEntList() {
    throw new Error("A list of objects and/or points must be given.");
}
function entListTooFew() {
    throw new Error("The list conatins too few objects and/or points.");
}
function entInOtherModel() {
    throw new Error("Entity is in a different model.");
}
// Objects ====================================================================================================
function checkObjID(model, obj_id, obj_tye) {
    var obj = model.getGeom().getObj(obj_id);
    if (!obj.exists()) {
        objNotExist();
    }
    if (obj.getModel() !== model) {
        objInOtherModel();
    }
    if (obj_tye !== undefined) {
        if (obj.getObjType() !== obj_tye) {
            objWrongType();
        }
    }
    return obj;
}
function checkObj(obj, obj_tye) {
    if (!obj.exists()) {
        objNotExist();
    }
    if (obj_tye !== undefined) {
        if (obj.getObjType() !== obj_tye) {
            objWrongType();
        }
    }
    return obj.getModel();
}
function checkObjList(objs, min_len, obj_tye) {
    var e_2, _a;
    if (!Array.isArray(objs)) {
        mustBeObjList();
    }
    if (objs.length < min_len) {
        objListTooFew();
    }
    var model = objs[0].getModel();
    if (model === undefined) {
        mustBeObjList();
    }
    try {
        for (var objs_1 = __values(objs), objs_1_1 = objs_1.next(); !objs_1_1.done; objs_1_1 = objs_1.next()) {
            var obj = objs_1_1.value;
            if (!obj.exists()) {
                objNotExist();
            }
            if (obj.getModel() !== model) {
                objInOtherModel();
            }
            if (obj_tye !== undefined) {
                if (obj.getObjType() !== obj_tye) {
                    objWrongType();
                }
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (objs_1_1 && !objs_1_1.done && (_a = objs_1.return)) _a.call(objs_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return model;
}
function checkObjsSameModel(objs) {
    var e_3, _a;
    if (!Array.isArray(objs)) {
        mustBeObjList();
    }
    var model = objs[0].getModel();
    try {
        for (var objs_2 = __values(objs), objs_2_1 = objs_2.next(); !objs_2_1.done; objs_2_1 = objs_2.next()) {
            var obj = objs_2_1.value;
            if (obj.getModel() !== model) {
                objInOtherModel();
            }
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (objs_2_1 && !objs_2_1.done && (_a = objs_2.return)) _a.call(objs_2);
        }
        finally { if (e_3) throw e_3.error; }
    }
}
function objNotExist() {
    throw new Error("Object does not exist. It was probably deleted.");
}
function objInOtherModel() {
    throw new Error("Object is in a different model.");
}
function objWrongType() {
    throw new Error("Object is of wrong type.");
}
function pointNotExist() {
    throw new Error("Point does not exist. It was probably deleted.");
}
function objListTooFew() {
    throw new Error("The list conatins too few objects.");
}
function objListEmpty() {
    throw new Error("The list of objects was empty.");
}
function mustBeObjList() {
    throw new Error("A list of objects must be given.");
}
// Points ====================================================================================================
function checkPointID(model, point_id) {
    var point = model.getGeom().getPoint(point_id);
    if (!point.exists()) {
        pointNotExist();
    }
    if (point.getModel() !== model) {
        pointInOtherModel();
    }
    return point;
}
function checkPoint(point) {
    if (!point.exists()) {
        objNotExist();
    }
    return point.getModel();
}
function checkPointList(points, min_len) {
    var e_4, _a;
    if (!Array.isArray(points)) {
        mustBePointList();
    }
    if (points.length < min_len) {
        pointListTooFew();
    }
    var model = points[0].getModel();
    try {
        for (var points_1 = __values(points), points_1_1 = points_1.next(); !points_1_1.done; points_1_1 = points_1.next()) {
            var point = points_1_1.value;
            if (!point.exists()) {
                pointNotExist();
            }
            if (point.getModel() !== model) {
                pointInOtherModel();
            }
        }
    }
    catch (e_4_1) { e_4 = { error: e_4_1 }; }
    finally {
        try {
            if (points_1_1 && !points_1_1.done && (_a = points_1.return)) _a.call(points_1);
        }
        finally { if (e_4) throw e_4.error; }
    }
    return model;
}
function checkPointNestedList(points, min_len1, min_len2) {
    var e_5, _a, e_6, _b;
    if (!Array.isArray(points)) {
        mustBePointNestedList();
    }
    var list_len1 = points.length;
    if (list_len1 < min_len1) {
        pointNestedListTooFew();
    }
    var list_len2 = points[0].length;
    if (list_len2 < min_len2) {
        pointListTooFew();
    }
    var model = points[0][0].getModel();
    try {
        for (var points_2 = __values(points), points_2_1 = points_2.next(); !points_2_1.done; points_2_1 = points_2.next()) {
            var point_list = points_2_1.value;
            if (!Array.isArray(point_list)) {
                mustBePointList();
            }
            if (point_list.length < min_len2) {
                pointListTooFew();
            }
            try {
                for (var point_list_1 = __values(point_list), point_list_1_1 = point_list_1.next(); !point_list_1_1.done; point_list_1_1 = point_list_1.next()) {
                    var point = point_list_1_1.value;
                    if (!point.exists()) {
                        pointNotExist();
                    }
                    if (point.getModel() !== model) {
                        pointInOtherModel();
                    }
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (point_list_1_1 && !point_list_1_1.done && (_b = point_list_1.return)) _b.call(point_list_1);
                }
                finally { if (e_6) throw e_6.error; }
            }
        }
    }
    catch (e_5_1) { e_5 = { error: e_5_1 }; }
    finally {
        try {
            if (points_2_1 && !points_2_1.done && (_a = points_2.return)) _a.call(points_2);
        }
        finally { if (e_5) throw e_5.error; }
    }
    return model;
}
function checkPointsSameModel(points) {
    var e_7, _a;
    if (!Array.isArray(points)) {
        mustBePointList();
    }
    var model = points[0].getModel();
    try {
        for (var points_3 = __values(points), points_3_1 = points_3.next(); !points_3_1.done; points_3_1 = points_3.next()) {
            var point = points_3_1.value;
            if (point.getModel() !== model) {
                pointInOtherModel();
            }
        }
    }
    catch (e_7_1) { e_7 = { error: e_7_1 }; }
    finally {
        try {
            if (points_3_1 && !points_3_1.done && (_a = points_3.return)) _a.call(points_3);
        }
        finally { if (e_7) throw e_7.error; }
    }
}
function pointInOtherModel() {
    throw new Error("Point is in a different model.");
}
function pointListEmpty() {
    throw new Error("The list of points was empty.");
}
function pointListTooFew() {
    throw new Error("The list of points did not contain enough points.");
}
function pointNestedListTooFew() {
    throw new Error("The list did not contain enough points lists.");
}
function pointNestedListJagged() {
    throw new Error("The lists of points must all be of equal length.");
}
function mustBePointList() {
    throw new Error("A list of points must be given.");
}
function mustBePointNestedList() {
    throw new Error("A list of lists of points must be given.");
}
// IDs ====================================================================================================
function invalidID() {
    throw new Error("The ID is invalid. It must be an integer number.");
}
function mustBeIDList() {
    throw new Error("A list of IDs must be given.");
}
// GROUPS ====================================================================================================
function checkGroup(model, group_name) {
    var group = model.getGroup(group_name);
    if (group === undefined) {
        groupNotExist();
    }
    return group;
}
function groupNotExist() {
    throw new Error("Group does not exist.");
}
// XYZ ====================================================================================================
function checkXYZ(xyz) {
    if (xyz === undefined) {
        argUndefined();
    }
    if (!Array.isArray(xyz)) {
        xyzNotList();
    }
    if (xyz.length !== 3) {
        xyzWrongLength();
    }
    if (isNaN(xyz[0]) || isNaN(xyz[1]) || isNaN(xyz[2])) {
        xyzInvalidData();
    }
}
function xyzWrongLength() {
    throw new Error("XYZ list is wrong length. It should consist of three numbers.");
}
function xyzInvalidData() {
    throw new Error("XYZ list contains invalid data. It should consist of three numbers.");
}
function xyzNotList() {
    throw new Error("XYZ list must be a list of three numbers.");
}
// Angles ====================================================================================================
// export function checkAngles(angles: [number, number]):void {
//     if (angles === undefined) {argUndefined();}
//     if (angles.length !== 2 ) {anglesWrongLength();}
//     if (isNaN(angles[0]) || isNaN(angles[1])) {anglesInvalidData();}
//     if (angles[0] < 0 || angles[0] > 360) {anglesInvalidData();}
//     if (angles[1] < 0 || angles[1] > 360) {anglesInvalidData();}
// }
// export function anglesWrongLength():void {
//     throw new Error("Angles list is wrong length. It should consist of two numbers between 0 and 360.");
// }
// export function anglesInvalidData():void {
//     throw new Error("Angles list contains invalid data. It should consist of two numbers between 0 and 360.");
// }
// Numbers ====================================================================================================
function checkNum(x) {
    if (x === undefined) {
        argUndefined();
    }
}
function checkPosNum(x) {
    if (x === undefined) {
        argUndefined();
    }
    if (x < 0) {
        numMustBePos();
    }
}
function checkPosNums(nums) {
    var e_8, _a;
    if (nums === undefined) {
        argUndefined();
    }
    try {
        for (var nums_1 = __values(nums), nums_1_1 = nums_1.next(); !nums_1_1.done; nums_1_1 = nums_1.next()) {
            var num = nums_1_1.value;
            if (num < 0) {
                numMustBePos();
            }
        }
    }
    catch (e_8_1) { e_8 = { error: e_8_1 }; }
    finally {
        try {
            if (nums_1_1 && !nums_1_1.done && (_a = nums_1.return)) _a.call(nums_1);
        }
        finally { if (e_8) throw e_8.error; }
    }
}
function checkNumListLength(list, length) {
    if (list === undefined) {
        argUndefined();
    }
    if (!Array.isArray(list)) {
        argMustBeNumList(length);
    }
    if (list.length !== length) {
        argNumListWrongLength(length);
    }
}
function argMustBeNumList(length) {
    throw new Error("Argument must be a list of " + length + "numbers.");
}
function argNumListWrongLength(length) {
    throw new Error("Argument must be a list of " + length + " numbers.");
}
function numMustBePos() {
    throw new Error("Argument must be a positive number.");
}
// GENERAL ====================================================================================================
function argUndefined() {
    throw new Error("Argument is undefined.");
}


/***/ }),

/***/ "./src/app/core/modules/_parameterTypes.ts":
/*!*************************************************!*\
  !*** ./src/app/core/modules/_parameterTypes.ts ***!
  \*************************************************/
/*! exports provided: _parameterTypes */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_parameterTypes", function() { return _parameterTypes; });
var _parameterTypes = {
    constList: "__constList__",
    model: "__model__",
    input: "__input__"
};


/***/ }),

/***/ "./src/app/core/modules/_utils_dev.ts":
/*!********************************************!*\
  !*** ./src/app/core/modules/_utils_dev.ts ***!
  \********************************************/
/*! exports provided: copyObjPoints */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyObjPoints", function() { return copyObjPoints; });
var __values = (undefined && undefined.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
function copyObjPoints(obj, reverse_faces) {
    var e_1, _a, e_2, _b, e_3, _c, e_4, _d;
    var new_points_map = new Map();
    var new_faces_points = [];
    var new_wires_points = [];
    var faces = obj.getFaces();
    try {
        for (var faces_1 = __values(faces), faces_1_1 = faces_1.next(); !faces_1_1.done; faces_1_1 = faces_1.next()) {
            var face = faces_1_1.value;
            var face_points = face.getVertices().map(function (v) { return v.getPoint(); });
            var new_face_points = [];
            try {
                for (var face_points_1 = __values(face_points), face_points_1_1 = face_points_1.next(); !face_points_1_1.done; face_points_1_1 = face_points_1.next()) {
                    var point = face_points_1_1.value;
                    if (new_points_map.has(point.getID())) {
                        new_face_points.push(new_points_map.get(point.getID()));
                    }
                    else {
                        var new_point = point.copy();
                        new_face_points.push(new_point);
                        new_points_map.set(point.getID(), new_point);
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (face_points_1_1 && !face_points_1_1.done && (_b = face_points_1.return)) _b.call(face_points_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
            if (reverse_faces) {
                new_face_points.reverse();
            }
            new_faces_points.push(new_face_points);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (faces_1_1 && !faces_1_1.done && (_a = faces_1.return)) _a.call(faces_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    var wires = obj.getWires();
    try {
        for (var wires_1 = __values(wires), wires_1_1 = wires_1.next(); !wires_1_1.done; wires_1_1 = wires_1.next()) {
            var wire = wires_1_1.value;
            var wire_points = wire.getVertices().map(function (v) { return v.getPoint(); });
            var new_wire_points = [];
            try {
                for (var wire_points_1 = __values(wire_points), wire_points_1_1 = wire_points_1.next(); !wire_points_1_1.done; wire_points_1_1 = wire_points_1.next()) {
                    var point = wire_points_1_1.value;
                    if (new_points_map.has(point.getID())) {
                        new_wire_points.push(new_points_map.get(point.getID()));
                    }
                    else {
                        var new_point = point.copy();
                        new_wire_points.push(new_point);
                        new_points_map.set(point.getID(), new_point);
                    }
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (wire_points_1_1 && !wire_points_1_1.done && (_d = wire_points_1.return)) _d.call(wire_points_1);
                }
                finally { if (e_4) throw e_4.error; }
            }
            new_wires_points.push(new_wire_points); // do not reverse
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (wires_1_1 && !wires_1_1.done && (_c = wires_1.return)) _c.call(wires_1);
        }
        finally { if (e_3) throw e_3.error; }
    }
    return [new_wires_points, new_faces_points];
}


/***/ }),

/***/ "./src/app/core/modules/attrib.ts":
/*!****************************************!*\
  !*** ./src/app/core/modules/attrib.ts ***!
  \****************************************/
/*! exports provided: Get, getAll, getAllEnts, getAllTopos, Create, del, getName, setName, getEntValue, setEntValue, getTopoValue, setTopoValue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Get", function() { return Get; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAll", function() { return getAll; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAllEnts", function() { return getAllEnts; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAllTopos", function() { return getAllTopos; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Create", function() { return Create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "del", function() { return del; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getName", function() { return getName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setName", function() { return setName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getEntValue", function() { return getEntValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setEntValue", function() { return setEntValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTopoValue", function() { return getTopoValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setTopoValue", function() { return setTopoValue; });
/* harmony import */ var gs_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gs-json */ "./node_modules/gs-json/dist2015/index.js");
/* harmony import */ var gs_json__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(gs_json__WEBPACK_IMPORTED_MODULE_0__);
/**
 * Attributes are properties assigned to each object.
 */
var __read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (undefined && undefined.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};

//  ===============================================================================================================
//  Attrib Get ====================================================================================================
//  ===============================================================================================================
/**
 * Gets attribute that apply for a specified geometry type from a model
 * @param model Model to get attribute from
 * @param name The attribute name
 * @param geom_type Type of geometry to get attribute from
 * @returns List of attributes
 */
function Get(model, name, geom_type) {
    switch (geom_type) {
        case gs_json__WEBPACK_IMPORTED_MODULE_0__["EGeomType"].points:
        case gs_json__WEBPACK_IMPORTED_MODULE_0__["EGeomType"].objs:
            return model.getEntAttrib(name, geom_type);
        default:
            return model.getTopoAttrib(name, geom_type);
    }
}
/**
 * Gets all entity attribs
 * @param model Model to get attribute from
 * @returns List of attributes
 */
function getAll(model) {
    return __spread(model.getAllEntAttribs(), model.getAllTopoAttribs());
}
/**
 * Gets all entity attribs
 * @param model Model to get attribute from
 * @returns List of attributes
 */
function getAllEnts(model) {
    return model.getAllEntAttribs();
}
/**
 * Gets all topo attribs
 * @param model Model to get attribute from
 * @returns List of attributes
 */
function getAllTopos(model) {
    return model.getAllTopoAttribs();
}
//  ===============================================================================================================
//  Attrib Constructors ===========================================================================================
//  ===============================================================================================================
/**
 * Adds an attribute to a model
 * @param model Model to add to
 * @param name Name of new attribute
 * @param geom_type Type of geometry to add to
 * @param geom_type Data type for attribute values. (number, string, boolean, number[], string[], boolean[])
 * @returns New attribute
 */
function Create(model, name, geom_type, data_type) {
    switch (geom_type) {
        case gs_json__WEBPACK_IMPORTED_MODULE_0__["EGeomType"].points:
        case gs_json__WEBPACK_IMPORTED_MODULE_0__["EGeomType"].objs:
            return model.addEntAttrib(name, geom_type, data_type);
        default:
            return model.addTopoAttrib(name, geom_type, data_type);
    }
}
//  ===============================================================================================================
//  Attrib Functions ==============================================================================================
//  ===============================================================================================================
/**
 * Deletes an attribute
 * @param attrib Attribute to delete
 * @returns True if successful
 */
function del(attrib) {
    return attrib.getModel().delAttrib(attrib);
}
/**
 * Gets the name of an attribute
 * @param attrib Attribute to get name of
 * @returns Name of specified attribute
 */
function getName(attrib) {
    return attrib.getName();
}
/**
 * Sets the name of an attribute
 * @param attrib Attribute to set name
 * @param name New name of attribute
 * @returns Old name of specified attribute
 */
function setName(attrib, name) {
    return attrib.setName(name);
}
// TODO - see if these set and get methods can be combined
/**
 * Gets the value of a ent attribute for a specified geometry
 * @param attrib Attribute
 * @param ent Geometry
 * @returns Value of attribute
 */
function getEntValue(attrib, ent) {
    return ent.getAttribValue(attrib);
}
/**
 * Sets the value of a ent attribute for a specified geometry
 * @param attrib Attribute
 * @param ent Geometry
 * @param value New value of attribute
 * @returns Old value of specified attribute
 */
function setEntValue(attrib, ent, value) {
    return ent.setAttribValue(attrib, value);
}
/**
 * Gets the value of a topo attribute for a specified geometry
 * @param attrib Attribute
 * @param topo Geometry
 * @returns Value of attribute
 */
function getTopoValue(attrib, topo) {
    return topo.getAttribValue(attrib);
}
/**
 * Sets the value of a topo attribute for a specified geometry
 * @param attrib Attribute
 * @param topo Geometry
 * @param value New value of attribute
 * @returns Old value of specified attribute
 */
function setTopoValue(attrib, topo, value) {
    return topo.setAttribValue(attrib, value);
}


/***/ }),

/***/ "./src/app/core/modules/calc.ts":
/*!**************************************!*\
  !*** ./src/app/core/modules/calc.ts ***!
  \**************************************/
/*! exports provided: distBetweenPoints, vectorBetweenPoints */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distBetweenPoints", function() { return distBetweenPoints; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vectorBetweenPoints", function() { return vectorBetweenPoints; });
/* harmony import */ var _libs_threex_threex__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libs/threex/threex */ "./src/app/core/modules/libs/threex/threex.ts");
/* harmony import */ var _error_msgs_dev__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_error_msgs_dev */ "./src/app/core/modules/_error_msgs_dev.ts");
/**
 * Function for doing various geometric calculations.
 */


//  ===============================================================================================================
//  Pline Get and Copy ============================================================================================
//  ===============================================================================================================
/**
 * Calculate the distance between two points.
 *
 * @param point1 The first point.
 * @param point2 The second point.
 * @returns The distance.
 */
function distBetweenPoints(point1, point2) {
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_1__["checkPoint"](point1);
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_1__["checkPoint"](point2);
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_1__["checkPointsSameModel"]([point1, point2]);
    return _libs_threex_threex__WEBPACK_IMPORTED_MODULE_0__["vectorFromPointsAtoB"](point1, point2).length();
}
/**
 * Creates a vector (a list of 3 numbers) from point 1 to point 2.
 *
 * @param point1 The first point.
 * @param point2 The second point.
 * @returns A list of three numbers.
 */
function vectorBetweenPoints(point1, point2) {
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_1__["checkPoint"](point1);
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_1__["checkPoint"](point2);
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_1__["checkPointsSameModel"]([point1, point2]);
    return _libs_threex_threex__WEBPACK_IMPORTED_MODULE_0__["vectorFromPointsAtoB"](point1, point2).toArray();
}


/***/ }),

/***/ "./src/app/core/modules/circle.ts":
/*!****************************************!*\
  !*** ./src/app/core/modules/circle.ts ***!
  \****************************************/
/*! exports provided: Get, Copy, CopyToModel, FromOrigin2Vectors, FromOrigin2Points, FromOriginXY, FromOriginYZ, FromOriginZX, FromPlane, From3Points, getOrigin, getAxes, getArcAngles, setArcAngles, isClosed, close, calcLength, evalParam, evalParamTangent, evalPoint, tangentPlinesInner2D, tangentPlinesOuter2D */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Get", function() { return Get; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Copy", function() { return Copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CopyToModel", function() { return CopyToModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FromOrigin2Vectors", function() { return FromOrigin2Vectors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FromOrigin2Points", function() { return FromOrigin2Points; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FromOriginXY", function() { return FromOriginXY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FromOriginYZ", function() { return FromOriginYZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FromOriginZX", function() { return FromOriginZX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FromPlane", function() { return FromPlane; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "From3Points", function() { return From3Points; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getOrigin", function() { return getOrigin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAxes", function() { return getAxes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getArcAngles", function() { return getArcAngles; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setArcAngles", function() { return setArcAngles; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isClosed", function() { return isClosed; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "close", function() { return close; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "calcLength", function() { return calcLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "evalParam", function() { return evalParam; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "evalParamTangent", function() { return evalParamTangent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "evalPoint", function() { return evalPoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tangentPlinesInner2D", function() { return tangentPlinesInner2D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tangentPlinesOuter2D", function() { return tangentPlinesOuter2D; });
/* harmony import */ var _circle_dev__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./circle_dev */ "./src/app/core/modules/circle_dev.ts");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _libs_threex_threex__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./libs/threex/threex */ "./src/app/core/modules/libs/threex/threex.ts");
/* harmony import */ var _libs_conics_circles__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./libs/conics/circles */ "./src/app/core/modules/libs/conics/circles.ts");
/* harmony import */ var _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_error_msgs_dev */ "./src/app/core/modules/_error_msgs_dev.ts");
/**
 * Functions for working with circles.
 * Circles are geometric objects definded by a single vertex and a set of parameters.
 * The circle object can be either a closed circle or an open arc.
 */
var __read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (undefined && undefined.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};





//  ===============================================================================================================
//  Circle Get and Copy =====================================================================================================
//  ===============================================================================================================
/**
 * Gets a circle from the model based on an ID number.
 * In the viewer, the object label can display (it starts with 'o'), which contains the ID.
 * For example, if the label is "o123", then the ID is the number 123.
 *
 * @param model Model to get circle object from.
 * @param id ID number of circle object.
 * @returns Circle object.
 */
function Get(model, id) {
    // check args
    var obj = _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkObjID"](model, id, 3 /* circle */);
    // return the circle
    return obj;
}
/**
 * Create a copy of a circle object.
 *
 * @param circle The circle object to copy.
 * @param copy_attribs If true, attributes are copied to the new circle.
 * @returns Circle object.
 */
function Copy(circle, copy_attribs) {
    // check args
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkObj"](circle, 3 /* circle */);
    // copy and return
    return circle.copy(copy_attribs);
}
/**
 * Copies a circle from one model into another model.
 *
 * @param model The model to copy to.
 * @param circle The circle object to copy.
 * @returns The copied circle object in the model.
 */
function CopyToModel(model, circle) {
    // check args
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkObj"](circle, 3 /* circle */);
    // check it is not already in the model
    if (circle.getModel() === model) {
        throw new Error("Error: circle is already in model.");
    }
    // copy circle and return it
    return model.getGeom().copyCircleFromModel(circle);
}
//  ===============================================================================================================
//  Constructors ============================================================================================
//  ===============================================================================================================
/**
 * Creates a circle from an origin point parallel to a plane defined by the two X and Y vectors.
 * The radius will be equal to the length of the X vector.
 * If no angle is defined, a circle is created. Otherwise, an arc is created, with the specified angles
 * starting at the x-axis in an anti-clockwise direction.
 *
 * @param origin Point object, the center of the circle.
 * @param vec_x X-axis of the circle plane. (The length of the vecor described the radius.)
 * @param vec Vector on the circle plane.
 * @param angles Two angles between 0 and 360, or null for a circle.
 * @returns Circle object.
 */
function FromOrigin2Vectors(origin, vec_x, vec, angles) {
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkPoint"](origin);
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkXYZ"](vec_x);
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkXYZ"](vec);
    // make the circle
    return origin.getGeom().addCircle(origin, vec_x, vec, _circle_dev__WEBPACK_IMPORTED_MODULE_0__["_argsCheckAngles"](angles));
}
/**
 * Create a circle at the origin point parallel to a plane that passes through two other points.
 * The radius will be equal to the distance from the origin to point1.
 * If angle is undefined, a circle is created. Otherwise, an arc is created, with the specified angles
 * starting at point1 in an anti-clockwise direction.
 *
 * @param origin Point object, the center of the circle.
 * @param point1 Point object, on the circle perimeter, and defining teh x-axis of the plane.
 * @param point2 Point object, on the plane.
 * @param angles Two angles between 0 and 360, or null for a circle.
 * @returns Circle object.
 */
function FromOrigin2Points(origin, point1, point2, angles) {
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkPoint"](origin);
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkPoint"](point1);
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkPoint"](point2);
    // create the vectors
    var vec_x = _libs_threex_threex__WEBPACK_IMPORTED_MODULE_2__["vectorFromPointsAtoB"](origin, point1).toArray();
    var vec = _libs_threex_threex__WEBPACK_IMPORTED_MODULE_2__["vectorFromPointsAtoB"](origin, point2).toArray();
    // make the circle
    return origin.getGeom().addCircle(origin, vec_x, vec, _circle_dev__WEBPACK_IMPORTED_MODULE_0__["_argsCheckAngles"](angles));
}
/**
 * Create a circle at the origin point parallel to the WCS XY plane, with the specified radius.
 * If angle is undefined, a circle is created. Otherwise, an arc is created, with the specified angles
 * starting at point1 in an anti-clockwise direction.
 *
 * @param origin Point object, the center of the circle.
 * @param radius Radius of circle.
 * @param angles Two angles between 0 and 360, or null for a circle.
 * @returns Circle object.
 */
function FromOriginXY(origin, radius, angles) {
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkPoint"](origin);
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkPosNum"](radius);
    // create the vectors
    var vec_x = [radius, 0, 0];
    var vec = [0, 1, 0];
    // make the circle
    return origin.getGeom().addCircle(origin, vec_x, vec, _circle_dev__WEBPACK_IMPORTED_MODULE_0__["_argsCheckAngles"](angles));
}
/**
 * Create a circle at the origin point parallel to the WCS YZ plane, with the specified radius.
 * If angle is undefined, a circle is created. Otherwise, an arc is created, with the specified angles
 * starting at point1 in an anti-clockwise direction.
 *
 * @param origin Point object, the center of the circle.
 * @param radius Radius of circle.
 * @param angles Two angles between 0 and 360, or null for a circle.
 * @returns Circle object.
 */
function FromOriginYZ(origin, radius, angles) {
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkPoint"](origin);
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkPosNum"](radius);
    // create the vectors
    var vec_x = [0, radius, 0];
    var vec = [0, 0, 1];
    // make the circle
    return origin.getGeom().addCircle(origin, vec_x, vec, _circle_dev__WEBPACK_IMPORTED_MODULE_0__["_argsCheckAngles"](angles));
}
/**
 * Create a circle at the origin point parallel to the WCS ZX plane, with the specified radius.
 * If angle is undefined, a circle is created. Otherwise, an arc is created, with the specified angles
 * starting at point1 in an anti-clockwise direction.
 *
 * @param origin Point object, the center of the circle.
 * @param radius Radius of circle.
 * @param angles Two angles between 0 and 360, or null for a circle.
 * @returns New circle (or arc).
 */
function FromOriginZX(origin, radius, angles) {
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkPoint"](origin);
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkPosNum"](radius);
    // create the vectors
    var vec_x = [0, 0, radius];
    var vec = [1, 0, 0];
    // make the circle
    return origin.getGeom().addCircle(origin, vec_x, vec, _circle_dev__WEBPACK_IMPORTED_MODULE_0__["_argsCheckAngles"](angles));
}
/**
 * Create a circle from a plane, with the specified radius.
 * If angle is undefined, a circle is created. Otherwise, an arc is created, with the specified angles
 * starting at point1 in an anti-clockwise direction.
 *
 * @param plane Plane object to construct circle on.
 * @param radius Radius of circle.
 * @param angles Two angles between 0 and 360, or null for a circle.
 * @returns New circle object.
 */
function FromPlane(plane, radius, angles) {
    var _a;
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkObj"](plane, 2 /* plane */);
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkPosNum"](radius);
    // create the vectors
    var vecs = plane.getAxes();
    var vec_x = new ((_a = three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]).bind.apply(_a, __spread([void 0], vecs[0])))().setLength(radius).toArray();
    var vec = vecs[1];
    // make the circle
    return plane.getGeom().addCircle(plane.getOrigin(), vec_x, vec, _circle_dev__WEBPACK_IMPORTED_MODULE_0__["_argsCheckAngles"](angles));
}
/**
 * Create a circle that passes through three points.
 * If is_closed is false, an arc is created. Otherwise, an arc is created.
 *
 * @param point1 Point object, on the circle.
 * @param point2 Point object, on the circle.
 * @param point3 Point object, on the circle.
 * @param is_closed If false, an arc is generated that starts at point1 and end at point3, passing through point 2.
 * @returns New circle object.
 */
function From3Points(point1, point2, point3, is_closed) {
    var model = _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkPointList"]([point1, point2, point3], 3);
    // do the maths
    var result = _libs_conics_circles__WEBPACK_IMPORTED_MODULE_3__["circleFrom3Points"](point1.getPosition(), point2.getPosition(), point3.getPosition(), is_closed);
    var origin = model.getGeom().addPoint(result.origin);
    // make the circle or arc
    if (is_closed) {
        return origin.getGeom().addCircle(origin, result.vec_x, result.vec_y);
    }
    else {
        return origin.getGeom().addCircle(origin, result.vec_x, result.vec_y, [0, result.angle]);
    }
}
//  ===============================================================================================================
//  Get and Set ===================================================================================================
//  ===============================================================================================================
/**
 * Gets the origin of the circle.
 * @param circle Circle objject to obtain origin from.
 * @returns Point object, the origin of teh circle.
 */
function getOrigin(circle) {
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkObj"](circle, 3 /* circle */);
    return circle.getOrigin();
}
/**
 * Gets the X and Y vectors of the circle plane. The circle radius is equal to the length of the X vector.
 *
 * @param circle Circle object to get vectors from.
 * @returns Two vectors, the X and Y vectors of teh circle plane.
 */
function getAxes(circle) {
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkObj"](circle, 3 /* circle */);
    return circle.getAxes();
}
/**
 * Gets the arc angles of the circle.
 *
 * @param circle Circle object to get angles from.
 * @returns The angles, or null if it is a closed circle.
 */
function getArcAngles(circle) {
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkObj"](circle, 3 /* circle */);
    return circle.getAngles();
}
/**
 * Sets the angles for the arc.
 *
 * @param circle Circle object to set angles for.
 * @param angles The angles to set, two numbers between 0 and 360. If null, then the circle is closed.
 */
function setArcAngles(circle, angles) {
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkObj"](circle, 3 /* circle */);
    var old_angles = circle.getAngles();
    circle.setAngles(_circle_dev__WEBPACK_IMPORTED_MODULE_0__["_argsCheckAngles"](angles));
    return old_angles;
}
/**
 * Checks if a circle object is closed. If it is not closed, then it must be an arc.
 *
 * @param circle Circle object to test.
 * @returns True if the circle is closed.
 */
function isClosed(circle) {
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkObj"](circle, 3 /* circle */);
    return circle.isClosed();
}
/**
 * Closes the arc, so that it becomes a circle.
 *
 * @param circle Circle object to close.
 * @return True if the open circle was closed, false if the circle was already closed.
 */
function close(circle) {
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkObj"](circle, 3 /* circle */);
    if (circle.isClosed()) {
        return false;
    }
    circle.setAngles(undefined);
    return true;
}
//  ===============================================================================================================
//  Functions =====================================================================================================
//  ===============================================================================================================
/**
 * Returns the perimeter length of a circle.
 * If the circle is an open arc, then the length of the arc is returned.
 *
 * @param circle Circle object to calculate length for.
 * @returns Length of circle or arc.
 */
function calcLength(circle) {
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkObj"](circle, 3 /* circle */);
    return circle.length();
}
/**
 * Returns a point by evaluating the position along a circle.
 * The position is specified by a t parameter that starts at 0 and ends at 1.
 * If the circle object is closed, 0 and 1 will have the same position.
 * Values for of t<0 and t>1 are valid, they will loop around.
 * If the circle object is an open arc, the 0 will be the start of the arc, and 1 will be the end of the arc.
 * Values for of t<0 and t>1 are automatically converted to 0 and 1 respectively.
 *
 * @param circle Cricle object to evaluate.
 * @param t Parameter to evaluate (0 is the start of the circular arc, 1 is the end of the circular arc)
 * @returns Point.
 */
function evalParam(circle, t) {
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkObj"](circle, 3 /* circle */);
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkNum"](t);
    if (circle.isClosed()) {
        if (t < 0) {
            t = (t % 1) + 1;
        }
        if (t > 1) {
            t = (t % 1) - 1;
        }
    }
    else {
        if (t < 0) {
            t = 0;
        }
        if (t > 1) {
            t = 1;
        }
    }
    return circle.evalParam(t);
}
/**
 * Returns a tangent unit vector by evaluating the position along a circle.
 * The position is specified by a t parameter that starts at 0 and ends at 1.
 * If the circle object is closed, 0 and 1 will have the same position.
 * Values for of t<0 and t>1 are valid, they will loop around.
 * If the circle object is an open arc, the 0 will be the start of the arc, and 1 will be the end of the arc.
 * Values for of t<0 and t>1 are automatically converted to 0 and 1 respectively.
 *
 * @param circle Cricle object to evaluate.
 * @param t Parameter to evaluate (0 is the start of the circular arc, 1 is the end of the circular arc)
 * @returns Tangent unit vector (a list of three numbers).
 */
function evalParamTangent(circle, t) {
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkObj"](circle, 3 /* circle */);
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkNum"](t);
    if (circle.isClosed()) {
        if (t < 0) {
            t = (t % 1) + 1;
        }
        if (t > 1) {
            t = (t % 1) - 1;
        }
    }
    else {
        if (t < 0) {
            t = 0;
        }
        if (t > 1) {
            t = 1;
        }
    }
    return circle.evalParamTangent(t);
}
/**
 * Returns a t parameter by projecting a point onto a circle.
 * The t parameter represents a position on the circle.
 * The parameter starts at 0 and ends at 1.
 * If the circle object is closed, 0 and 1 will have the same position.
 * If the circle object is an open arc, the 0 will be the start of the arc, and 1 will be the end of the arc.
 * The point is projected onto the closest point on the circle, and t is then caclulated for that point.
 *
 * @param circle Cricle object to evaluate.
 * @param point The point to be projected onto the circle or arc.
 * @returns t parameter.
 */
function evalPoint(circle, point) {
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkObj"](circle, 3 /* circle */);
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkPoint"](point);
    return circle.evalPoint(point);
}
/**
 * Returns two polylines that are tangential (inner tangents) to two coplanar circles.
 *
 * @param circle1 The first circle.
 * @param circle2 The second circle.
 * @returns Two polylines, or null if inner tangents cannot be calculated.
 */
function tangentPlinesInner2D(circle1, circle2) {
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkObj"](circle1, 3 /* circle */);
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkObj"](circle2, 3 /* circle */);
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkObjsSameModel"]([circle1, circle2]);
    return _libs_conics_circles__WEBPACK_IMPORTED_MODULE_3__["innerTangentsCircleCircle2D"](circle1, circle2);
}
/**
 * Returns two polylines that are tangential (outer tangents) to two coplanar circles.
 *
 * @param circle1 The first circle.
 * @param circle2 The second circle.
 * @returns Two polylines, or null if outer tangents cannot be calculated.
 */
function tangentPlinesOuter2D(circle1, circle2) {
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkObj"](circle1, 3 /* circle */);
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkObj"](circle2, 3 /* circle */);
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkObjsSameModel"]([circle1, circle2]);
    return _libs_conics_circles__WEBPACK_IMPORTED_MODULE_3__["outerTangentsCircleCircle2D"](circle1, circle2);
}


/***/ }),

/***/ "./src/app/core/modules/circle_dev.ts":
/*!********************************************!*\
  !*** ./src/app/core/modules/circle_dev.ts ***!
  \********************************************/
/*! exports provided: _argsCheckAngles, From3Points, ArcFrom3Points, CircleFrom3Points, evalParam, evalPoint, extendArc, extendEllArc */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_argsCheckAngles", function() { return _argsCheckAngles; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "From3Points", function() { return From3Points; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArcFrom3Points", function() { return ArcFrom3Points; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CircleFrom3Points", function() { return CircleFrom3Points; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "evalParam", function() { return evalParam; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "evalPoint", function() { return evalPoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extendArc", function() { return extendArc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extendEllArc", function() { return extendEllArc; });
/* harmony import */ var gs_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gs-json */ "./node_modules/gs-json/dist2015/index.js");
/* harmony import */ var gs_json__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(gs_json__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _libs_threex_threex__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./libs/threex/threex */ "./src/app/core/modules/libs/threex/threex.ts");
/* harmony import */ var _libs_conics_circles__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./libs/conics/circles */ "./src/app/core/modules/libs/conics/circles.ts");
/* harmony import */ var _libs_arr_arr__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./libs/arr/arr */ "./src/app/core/modules/libs/arr/arr.ts");




//  ==========================================================================================================
//  Util method
//  ==========================================================================================================
function _argsCheckAngles(angles) {
    //export function checkCircleAngles(angles: [number, number]): [number, number] {
    if (angles === undefined || angles === null) {
        return null;
    }
    // fix angle 0
    if (Math.abs(angles[0]) > 360) {
        angles[0] = angles[0] % 360;
    }
    if (angles[0] < 0) {
        angles[0] = 360 + angles[0];
    }
    // fix angle 1
    if (Math.abs(angles[1]) > 360) {
        angles[1] = angles[1] % 360;
    }
    if (angles[1] < 0) {
        angles[1] = 360 + angles[1];
    }
    // return the fixed angles
    return angles;
}
//  ===============================================================================================================
//  Circle Constructors ============================================================================================
//  ===============================================================================================================
// Still not working
/**
 * Create a circle that passes three points.
 * If is_arc is false, a circle is created.
 * Otherwise, an arc is created.
 *
 * @param point1 Point object, on the circle.
 * @param point2 Point object, on the circle.
 * @param point3 Point object, on the circle.
 * @param is_arc If true, an arc is generated that starts at point1 and end at point3, passing through point 2.
 * @returns New circle object.
 */
function From3Points(point1, point2, point3, is_closed) {
    if (!point1.exists()) {
        throw new Error("Error: point1 has been deleted.");
    }
    if (!point2.exists()) {
        throw new Error("Error: point2 has been deleted.");
    }
    if (!point3.exists()) {
        throw new Error("Error: point3 has been deleted.");
    }
    // check
    var model = point1.getModel();
    if (point2.getModel() !== model) {
        throw new Error("Error: Points must all be in same model.");
    }
    if (point3.getModel() !== model) {
        throw new Error("Error: Points must all be in same model.");
    }
    // do the maths
    var result = _libs_conics_circles__WEBPACK_IMPORTED_MODULE_2__["circleFrom3Points"](point1.getPosition(), point2.getPosition(), point3.getPosition(), is_closed);
    var origin = model.getGeom().addPoint(result.origin);
    var vec_x = result.vec_x;
    var vec = result.vec_y;
    // make the circle or arc
    if (is_closed) {
        return origin.getGeom().addCircle(origin, vec_x, vec);
    }
    else {
        return origin.getGeom().addCircle(origin, vec_x, vec, [0, result.angle]);
    }
}
/**
 * Adds an arc to the model based on three points
 *
 * All points are taken to be points along the arc
 * @param pt1 Start point of arc
 * @param pt2 Second point on arc
 * @param pt3 End point of arc
 * @returns New arc if successful
 */
function ArcFrom3Points(pt1, pt2, pt3) {
    var m1 = pt1.getModel();
    var m2 = pt2.getModel();
    var m3 = pt3.getModel();
    if (m1 !== m2) {
        throw new Error("Points must be in the same model.");
    }
    if (m1 !== m3) {
        throw new Error("Points must be in the same model.");
    }
    var g1 = m1.getGeom();
    if (_libs_threex_threex__WEBPACK_IMPORTED_MODULE_1__["vectorsAreCodir"](_libs_threex_threex__WEBPACK_IMPORTED_MODULE_1__["subPoints"](pt1, pt2), _libs_threex_threex__WEBPACK_IMPORTED_MODULE_1__["subPoints"](pt1, pt3))) {
        throw new Error("Points must be not aligned");
    }
    var AB = _libs_threex_threex__WEBPACK_IMPORTED_MODULE_1__["vectorFromPointsAtoB"](pt1, pt2);
    var AC = _libs_threex_threex__WEBPACK_IMPORTED_MODULE_1__["vectorFromPointsAtoB"](pt1, pt3);
    var BC = _libs_threex_threex__WEBPACK_IMPORTED_MODULE_1__["vectorFromPointsAtoB"](pt2, pt3);
    var radius = BC.length() / (2 * _libs_threex_threex__WEBPACK_IMPORTED_MODULE_1__["crossVectors"](AB.normalize(), AC.normalize(), false).length());
    var m = new gs_json__WEBPACK_IMPORTED_MODULE_0__["Model"]();
    var g = m.getGeom();
    var circle_1 = g.addCircle(pt1, [radius, 0, 0], [0, radius, 0]);
    var circle_2 = g.addCircle(pt2, [radius, 0, 0], [0, radius, 0]);
    var circle_3 = g.addCircle(pt3, [radius, 0, 0], [0, radius, 0]);
    var c1 = _libs_conics_circles__WEBPACK_IMPORTED_MODULE_2__["isectCircleCircle2D"](circle_1, circle_2);
    var c2 = _libs_conics_circles__WEBPACK_IMPORTED_MODULE_2__["isectCircleCircle2D"](circle_1, circle_3);
    var center = null;
    if (_libs_arr_arr__WEBPACK_IMPORTED_MODULE_3__["Arr"].equal(c1[0].getPosition(), c2[0].getPosition())) {
        center = g.addPoint(c1[0].getPosition());
        // center = g1.addPoint(c1[0].getPosition());
    }
    if (_libs_arr_arr__WEBPACK_IMPORTED_MODULE_3__["Arr"].equal(c1[0].getPosition(), c2[1].getPosition())) {
        center = g.addPoint(c1[0].getPosition());
        // center = g1.addPoint(c1[0].getPosition());
    }
    if (_libs_arr_arr__WEBPACK_IMPORTED_MODULE_3__["Arr"].equal(c1[1].getPosition(), c2[0].getPosition())) {
        center = g.addPoint(c1[1].getPosition());
        // center = g1.addPoint(c1[1].getPosition());
    }
    if (_libs_arr_arr__WEBPACK_IMPORTED_MODULE_3__["Arr"].equal(c1[1].getPosition(), c2[1].getPosition())) {
        center = g.addPoint(c1[1].getPosition());
        // center = g1.addPoint(c1[1].getPosition());
    }
    if (center === null) {
        throw new Error("Review thresholds");
    }
    var center_pt1 = _libs_threex_threex__WEBPACK_IMPORTED_MODULE_1__["vectorFromPointsAtoB"](center, pt1);
    var center_pt2 = _libs_threex_threex__WEBPACK_IMPORTED_MODULE_1__["vectorFromPointsAtoB"](center, pt2);
    var center_pt3 = _libs_threex_threex__WEBPACK_IMPORTED_MODULE_1__["vectorFromPointsAtoB"](center, pt3);
    var angle = Math.max(Math.min(center_pt1.angleTo(center_pt2), center_pt2.angleTo(center_pt1)), Math.min(center_pt1.angleTo(center_pt3), center_pt3.angleTo(center_pt1)), Math.min(center_pt2.angleTo(center_pt3), center_pt3.angleTo(center_pt2)));
    var start_point = null;
    if (angle === center_pt1.angleTo(center_pt2)) {
        start_point = g.addPoint(pt1.getPosition());
    }
    if (angle === center_pt2.angleTo(center_pt1)) {
        start_point = g.addPoint(pt2.getPosition());
    }
    if (angle === center_pt1.angleTo(center_pt3)) {
        start_point = g.addPoint(pt1.getPosition());
    }
    if (angle === center_pt3.angleTo(center_pt1)) {
        start_point = g.addPoint(pt3.getPosition());
    }
    if (angle === center_pt2.angleTo(center_pt3)) {
        start_point = g.addPoint(pt2.getPosition());
    }
    if (angle === center_pt3.angleTo(center_pt2)) {
        start_point = g.addPoint(pt3.getPosition());
    }
    var u = _libs_threex_threex__WEBPACK_IMPORTED_MODULE_1__["vectorFromPointsAtoB"](center, start_point);
    var normal = null;
    normal = _libs_threex_threex__WEBPACK_IMPORTED_MODULE_1__["crossVectors"](u, center_pt1);
    if (normal.length() === 0) {
        normal = _libs_threex_threex__WEBPACK_IMPORTED_MODULE_1__["crossVectors"](u, center_pt2);
    }
    if (normal.length() === 0) {
        normal = _libs_threex_threex__WEBPACK_IMPORTED_MODULE_1__["crossVectors"](u, center_pt3);
    }
    var v = _libs_threex_threex__WEBPACK_IMPORTED_MODULE_1__["crossVectors"](normal.normalize(), u);
    return g1.addCircle(g1.addPoint(center.getPosition()), [u[0], u[1], u[2]], [v[0], v[1], v[2]], [0, angle]);
}
/**
 * Adds a closed circle to the model based on three points
 *
 * All points are taken to be points along the circumference of the circle
 * @param pt1 First point on circle
 * @param pt2 Second point on circle
 * @param pt3 Third point on circle
 * @returns New circle if successful
 */
function CircleFrom3Points(pt1, pt2, pt3) {
    var m1 = pt1.getModel();
    var m2 = pt2.getModel();
    var m3 = pt3.getModel();
    if (m1 !== m2) {
        throw new Error("Points must be in the same model.");
    }
    if (m1 !== m3) {
        throw new Error("Points must be in the same model.");
    }
    if (_libs_threex_threex__WEBPACK_IMPORTED_MODULE_1__["vectorsAreCodir"](_libs_threex_threex__WEBPACK_IMPORTED_MODULE_1__["subPoints"](pt1, pt2), _libs_threex_threex__WEBPACK_IMPORTED_MODULE_1__["subPoints"](pt1, pt3))) {
        throw new Error("Points must be not aligned");
    }
    var AB = _libs_threex_threex__WEBPACK_IMPORTED_MODULE_1__["vectorFromPointsAtoB"](pt1, pt2);
    var AC = _libs_threex_threex__WEBPACK_IMPORTED_MODULE_1__["vectorFromPointsAtoB"](pt1, pt3);
    var BC = _libs_threex_threex__WEBPACK_IMPORTED_MODULE_1__["vectorFromPointsAtoB"](pt2, pt3);
    var radius = BC.length() / (2 * _libs_threex_threex__WEBPACK_IMPORTED_MODULE_1__["crossVectors"](AB.normalize(), AC.normalize(), false).length());
    var m = new gs_json__WEBPACK_IMPORTED_MODULE_0__["Model"]();
    var g = m.getGeom();
    var circle_1 = g.addCircle(pt1, [radius, 0, 0], [0, radius, 0], [0, 360]);
    var circle_2 = g.addCircle(pt2, [radius, 0, 0], [0, radius, 0], [0, 360]);
    var circle_3 = g.addCircle(pt3, [radius, 0, 0], [0, radius, 0], [0, 360]);
    var c1 = _libs_conics_circles__WEBPACK_IMPORTED_MODULE_2__["isectCircleCircle2D"](circle_1, circle_2);
    var c2 = _libs_conics_circles__WEBPACK_IMPORTED_MODULE_2__["isectCircleCircle2D"](circle_1, circle_3);
    var g1 = m1.getGeom();
    if (_libs_arr_arr__WEBPACK_IMPORTED_MODULE_3__["Arr"].equal(c1[0].getPosition(), c2[0].getPosition())) {
        return g1.addCircle(g1.addPoint(c1[0].getPosition()), [radius, 0, 0], [0, radius, 0], [0, 360]);
    }
    if (_libs_arr_arr__WEBPACK_IMPORTED_MODULE_3__["Arr"].equal(c1[0].getPosition(), c2[1].getPosition())) {
        return g1.addCircle(g1.addPoint(c1[0].getPosition()), [radius, 0, 0], [0, radius, 0], [0, 360]);
    }
    if (_libs_arr_arr__WEBPACK_IMPORTED_MODULE_3__["Arr"].equal(c1[1].getPosition(), c2[0].getPosition())) {
        return g1.addCircle(g1.addPoint(c1[1].getPosition()), [radius, 0, 0], [0, radius, 0], [0, 360]);
    }
    if (_libs_arr_arr__WEBPACK_IMPORTED_MODULE_3__["Arr"].equal(c1[1].getPosition(), c2[1].getPosition())) {
        return g1.addCircle(g1.addPoint(c1[1].getPosition()), [radius, 0, 0], [0, radius, 0], [0, 360]);
    }
    throw new Error("Review thresholds");
}
//  ===============================================================================================================
//  Conic Functions ===============================================================================================
//  ===============================================================================================================
// - WEEK 6 -
/**
 * Returns a point on a conic curve based on a parameter between 0 and 1
 *
 * @param curve Conic curve to evaluate
 * @param t Parameter along curve to evaluate (0 is the start of the curve and 1 is the end)
 * @returns Point on curve
 */
function evalParam(curve, t) {
    throw new Error("Method not implemented");
}
// - WEEK 6 -
/**
 * Returns a parameter along a conic curve based on a point on the curve
 *
 * Returns null if point specified does not lie on the curve (within a tolerance of 0.1)
 * @param curve Conic curve to evaluate
 * @param point Point to evaluate
 * @returns Parameter on curve if successful, null if unsuccessful or on error
 */
function evalPoint(curve, point) {
    throw new Error("Method not implemented");
}
/**
 * Extends an arc
 *
 * Changes the starting and ending angles for a conic curve such that the curve is lengthened<br/>
 * Conic curve should be either a circular arc or an elliptical arc<br/>
 * Extension will follow the original curvature of the circle or ellipse the arc was constructed from<br>
 * If extension causes length of curve to exceed the circumference of the underlying circle or ellipse,
 * returns a closed circle or ellipse.<br/>
 * Returns null if distance is negative
 * @param curve Conic curve to extend
 * @param direction Direction to extend curve in (0-Start, 1-End, 2-Both)
 * @param distance Distance to extend curve
 * @param copy Performs transformation on a duplicate copy of the input curve if true
 * @returns Extended conic curve, null if unsuccessful or on error
 */
function extendArc(curve, direction, distance, copy) {
    throw new Error("Method not implemented");
}
/**
 * Extends an elliptical arc
 *
 * Changes the starting and ending angles for a conic curve such that the curve is lengthened<br/>
 * Conic curve should be either a circular arc or an elliptical arc<br/>
 * Extension will follow the original curvature of the circle or ellipse the arc was constructed from<br>
 * If extension causes length of curve to exceed the circumference of the underlying circle or ellipse,
 * returns a closed circle or ellipse.<br/>
 * Returns null if distance is negative
 * @param curve Conic curve to extend
 * @param direction Direction to extend curve in (0-Start, 1-End, 2-Both)
 * @param distance Distance to extend curve
 * @param copy Performs transformation on a duplicate copy of the input curve if true
 * @returns Extended conic curve, null if unsuccessful or on error
 */
function extendEllArc(curve, direction, distance, copy) {
    throw new Error("Method not implemented");
}


/***/ }),

/***/ "./src/app/core/modules/console.ts":
/*!*****************************************!*\
  !*** ./src/app/core/modules/console.ts ***!
  \*****************************************/
/*! exports provided: Console */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Console", function() { return Console; });
var Console;
(function (Console) {
    function log(val) {
        console.log('============================\nConsole Log:\n', val);
    }
    Console.log = log;
})(Console || (Console = {}));


/***/ }),

/***/ "./src/app/core/modules/group.ts":
/*!***************************************!*\
  !*** ./src/app/core/modules/group.ts ***!
  \***************************************/
/*! exports provided: GetNames, Create, Creates, del, getParent, setParent, getChildren */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GetNames", function() { return GetNames; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Create", function() { return Create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Creates", function() { return Creates; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "del", function() { return del; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getParent", function() { return getParent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setParent", function() { return setParent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getChildren", function() { return getChildren; });
/**
 * Functions for working with groups.
 */
var __values = (undefined && undefined.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
//  ===============================================================================================================
//  Group Get =====================================================================================================
//  ===============================================================================================================
/**
 * Gets the names of all the groups in the model.
 *
 * @param model Model to get group names from.
 * @returns List of group names
 */
function GetNames(model) {
    return model.getAllGroups().map(function (group) { return group.getName(); });
}
//  ===============================================================================================================
//  Group Constructors ============================================================================================
//  ===============================================================================================================
/**
 * Creates a new group.
 *
 * @param model Model to create group in.
 * @param name Group name.
 * @returns Ture if the group was successfully created.
 */
function Create(model, name) {
    if (model.getGroup(name) !== null) {
        throw new Error("Group already exists.");
    }
    var group = model.addGroup(name);
    if (group === undefined) {
        return false;
    }
    return true;
}
/**
 * Creates a set of new groups.
 *
 * @param model Model to create groups in.
 * @param name List of group names.
 * @returns Ture if all groups were successfully created.
 */
function Creates(model, names) {
    var e_1, _a;
    var ok = true;
    try {
        for (var names_1 = __values(names), names_1_1 = names_1.next(); !names_1_1.done; names_1_1 = names_1.next()) {
            var name_1 = names_1_1.value;
            if (model.getGroup(name_1) !== null) {
                throw new Error("Group already exists.");
            }
            var group = model.addGroup(name_1);
            if (group === undefined) {
                ok = false;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (names_1_1 && !names_1_1.done && (_a = names_1.return)) _a.call(names_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return ok;
}
//  ===============================================================================================================
//  Group Functions ===============================================================================================
//  ===============================================================================================================
/**
 * Deletes a group from the model.
 *
 * @param model Model containing the groups.
 * @param group_name Group name to delete.
 * @param delete_geom If true, the objects and points in the group will be deleted.
 * @returns True if the group was successfully deleted.
 */
function del(model, group_name, delete_geom) {
    var group = model.getGroup(group_name);
    if (group === null) {
        throw new Error("Group does not exist.");
    }
    if (delete_geom) {
        model.getGeom().delObjs(group.getObjs(), false);
        model.getGeom().delPoints(group.getPoints());
    }
    return group.getModel().delGroup(group);
}
/**
 * Gets the parent of a group.
 * Returns null if specified group does not have a parent group.
 *
 * @param model Model containing the groups.
 * @param group_name Group name to get parent from.
 * @returns Parent group of specified group if successful, null if unsuccessful or on error
 */
function getParent(model, group_name) {
    var group = model.getGroup(group_name);
    if (group === null) {
        throw new Error("Group does not exist.");
    }
    return group.getParentGroup().getName();
}
/**
 * Sets the parent of a group.
 *
 * @param model Model containing the groups.
 * @param group_name Group name to set parent for.
 * @param parent_name Group name of parent.
 * @returns The old parent.
 */
function setParent(model, group_name, parent_name) {
    var group = model.getGroup(group_name);
    var parent = model.getGroup(parent_name);
    if (group === null) {
        throw new Error("Group does not exist.");
    }
    if (parent === null) {
        throw new Error("Group does not exist.");
    }
    return group.setParentGroup(parent).getName();
}
/**
 * Gets the list of names of groups that are children of this group.
 * Returns empty list if specified group does not have any children.
 *
 * @param model Model containing the groups.
 * @param group_name Group name to get children from.
 * @returns A list of group names.
 */
function getChildren(model, group_name) {
    var group = model.getGroup(group_name);
    if (group === null) {
        throw new Error("Group does not exist.");
    }
    return group.getChildGroups().map(function (group) { return group.getName(); });
}


/***/ }),

/***/ "./src/app/core/modules/index.ts":
/*!***************************************!*\
  !*** ./src/app/core/modules/index.ts ***!
  \***************************************/
/*! exports provided: model, point, pline, plane, pmesh, circle, intersect, object, calc, attrib, group, query, ray, split, topo, list, math, string, gs, gsConstructor, Input, Output, Console, _parameterTypes */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gsConstructor", function() { return gsConstructor; });
/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./model */ "./src/app/core/modules/model.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "model", function() { return _model__WEBPACK_IMPORTED_MODULE_0__; });
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./point */ "./src/app/core/modules/point.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "point", function() { return _point__WEBPACK_IMPORTED_MODULE_1__; });
/* harmony import */ var _pline__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pline */ "./src/app/core/modules/pline.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "pline", function() { return _pline__WEBPACK_IMPORTED_MODULE_2__; });
/* harmony import */ var _plane__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./plane */ "./src/app/core/modules/plane.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "plane", function() { return _plane__WEBPACK_IMPORTED_MODULE_3__; });
/* harmony import */ var _pmesh__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./pmesh */ "./src/app/core/modules/pmesh.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "pmesh", function() { return _pmesh__WEBPACK_IMPORTED_MODULE_4__; });
/* harmony import */ var _circle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./circle */ "./src/app/core/modules/circle.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "circle", function() { return _circle__WEBPACK_IMPORTED_MODULE_5__; });
/* harmony import */ var _intersect__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./intersect */ "./src/app/core/modules/intersect.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "intersect", function() { return _intersect__WEBPACK_IMPORTED_MODULE_6__; });
/* harmony import */ var _object__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./object */ "./src/app/core/modules/object.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "object", function() { return _object__WEBPACK_IMPORTED_MODULE_7__; });
/* harmony import */ var _calc__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./calc */ "./src/app/core/modules/calc.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "calc", function() { return _calc__WEBPACK_IMPORTED_MODULE_8__; });
/* harmony import */ var _attrib__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./attrib */ "./src/app/core/modules/attrib.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "attrib", function() { return _attrib__WEBPACK_IMPORTED_MODULE_9__; });
/* harmony import */ var _group__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./group */ "./src/app/core/modules/group.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "group", function() { return _group__WEBPACK_IMPORTED_MODULE_10__; });
/* harmony import */ var _query__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./query */ "./src/app/core/modules/query.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "query", function() { return _query__WEBPACK_IMPORTED_MODULE_11__; });
/* harmony import */ var _ray__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./ray */ "./src/app/core/modules/ray.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "ray", function() { return _ray__WEBPACK_IMPORTED_MODULE_12__; });
/* harmony import */ var _split__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./split */ "./src/app/core/modules/split.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "split", function() { return _split__WEBPACK_IMPORTED_MODULE_13__; });
/* harmony import */ var _topo__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./topo */ "./src/app/core/modules/topo.ts");
/* harmony import */ var _topo__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(_topo__WEBPACK_IMPORTED_MODULE_14__);
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "topo", function() { return _topo__WEBPACK_IMPORTED_MODULE_14__; });
/* harmony import */ var _list__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./list */ "./src/app/core/modules/list.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "list", function() { return _list__WEBPACK_IMPORTED_MODULE_15__; });
/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./math */ "./src/app/core/modules/math.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "math", function() { return _math__WEBPACK_IMPORTED_MODULE_16__; });
/* harmony import */ var _string__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./string */ "./src/app/core/modules/string.ts");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "string", function() { return _string__WEBPACK_IMPORTED_MODULE_17__; });
/* harmony import */ var gs_json__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! gs-json */ "./node_modules/gs-json/dist2015/index.js");
/* harmony import */ var gs_json__WEBPACK_IMPORTED_MODULE_18___default = /*#__PURE__*/__webpack_require__.n(gs_json__WEBPACK_IMPORTED_MODULE_18__);
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "gs", function() { return gs_json__WEBPACK_IMPORTED_MODULE_18__; });
/* harmony import */ var _input__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./input */ "./src/app/core/modules/input.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Input", function() { return _input__WEBPACK_IMPORTED_MODULE_19__["Input"]; });

/* harmony import */ var _output__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./output */ "./src/app/core/modules/output.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Output", function() { return _output__WEBPACK_IMPORTED_MODULE_20__["Output"]; });

/* harmony import */ var _console__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./console */ "./src/app/core/modules/console.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Console", function() { return _console__WEBPACK_IMPORTED_MODULE_21__["Console"]; });

/* harmony import */ var _parameterTypes__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./_parameterTypes */ "./src/app/core/modules/_parameterTypes.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_parameterTypes", function() { return _parameterTypes__WEBPACK_IMPORTED_MODULE_22__["_parameterTypes"]; });











































var gsConstructor = new gs_json__WEBPACK_IMPORTED_MODULE_18__["Model"]().constructor;



/***/ }),

/***/ "./src/app/core/modules/input.ts":
/*!***************************************!*\
  !*** ./src/app/core/modules/input.ts ***!
  \***************************************/
/*! exports provided: Input */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Input", function() { return Input; });
var Input;
(function (Input) {
    function declare_constant(__constList__, const_name, __input__) {
        __constList__[const_name] = __input__;
    }
    Input.declare_constant = declare_constant;
})(Input || (Input = {}));


/***/ }),

/***/ "./src/app/core/modules/intersect.ts":
/*!*******************************************!*\
  !*** ./src/app/core/modules/intersect.ts ***!
  \*******************************************/
/*! exports provided: circleCircle2D, polylinePolyline2D, circlePlane3D, polylinePlane3D */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "circleCircle2D", function() { return circleCircle2D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "polylinePolyline2D", function() { return polylinePolyline2D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "circlePlane3D", function() { return circlePlane3D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "polylinePlane3D", function() { return polylinePlane3D; });
/* harmony import */ var _libs_conics_circles__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libs/conics/circles */ "./src/app/core/modules/libs/conics/circles.ts");
/* harmony import */ var _libs_poly_poly__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./libs/poly/poly */ "./src/app/core/modules/libs/poly/poly.ts");
/* harmony import */ var _libs_poly_polylinePlane__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./libs/poly/polylinePlane */ "./src/app/core/modules/libs/poly/polylinePlane.ts");
/* harmony import */ var _error_msgs_dev__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_error_msgs_dev */ "./src/app/core/modules/_error_msgs_dev.ts");
/**
 * Function for intersecting geometric objects.
 */




//  ===============================================================================================================
//  Intersect Functions ===========================================================================================
//  ===============================================================================================================
/**
 * Finds the intersection points between two intersecting co-planar circles.
 *
 * @param circle1 Circle 1
 * @param circle2 Circle 2
 * @returns List of intersection points.
 */
function circleCircle2D(circle1, circle2) {
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_3__["checkObjList"]([circle1, circle2], 2, 3 /* circle */);
    return _libs_conics_circles__WEBPACK_IMPORTED_MODULE_0__["isectCircleCircle2D"](circle1, circle2);
}
/**
 * Finds the intersection points between two coplanar polylines.
 *
 * @param pline1 Polyline 1
 * @param pline2 Polyline 2
 * @returns List of intersection points.
 */
function polylinePolyline2D(pline1, pline2) {
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_3__["checkObjList"]([pline1, pline2], 2, 100 /* polyline */);
    return _libs_poly_poly__WEBPACK_IMPORTED_MODULE_1__["_isectPolylinePolyline2D"](pline1, pline2);
}
/**
 * Finds the intersection points between a circle and a plane.
 * If no intersection points are found, or if the circle and plane are co-planar,
 * an empty list is returned.
 *
 * @param circle Circle
 * @param plane Plane
 * @returns List of intersection points (0, 1 or 2).
 */
function circlePlane3D(circle, plane) {
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_3__["checkObj"](circle, 3 /* circle */);
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_3__["checkObj"](plane, 2 /* plane */);
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_3__["checkObjsSameModel"]([circle, plane]);
    return _libs_conics_circles__WEBPACK_IMPORTED_MODULE_0__["isectCirclePlane3D"](circle, plane);
}
/**
 * Finds the intersection points between a polyine and a plane.
 * If no intersection points are found, an empty list is returned.
 *
 * @param pline Polyline
 * @param plane Plane
 * @returns List of intersection points.
 */
function polylinePlane3D(pline, plane) {
    var model = _error_msgs_dev__WEBPACK_IMPORTED_MODULE_3__["checkObj"](pline, 100 /* polyline */);
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_3__["checkObj"](plane, 2 /* plane */);
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_3__["checkObjsSameModel"]([pline, plane]);
    return _libs_poly_polylinePlane__WEBPACK_IMPORTED_MODULE_2__["isectPolylinePlane3D"](pline, plane);
}


/***/ }),

/***/ "./src/app/core/modules/libs/arr/arr.ts":
/*!**********************************************!*\
  !*** ./src/app/core/modules/libs/arr/arr.ts ***!
  \**********************************************/
/*! exports provided: Arr */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Arr", function() { return Arr; });
/**
 * A set of static methods for working with arrays of simple types.
 * The arrays can be nested, but they do not contain any objects.
 */
var Arr = /** @class */ (function () {
    function Arr() {
    }
    /**
     * Make an array of numbers. All elements in the array will have the same value.
     * @param length The length of the new array. If length is 0, then an empty array is returned.
     * @param value The values in the array.
     * @returns The resulting array.
     */
    Arr.make = function (length, value) {
        if (length === 0) {
            return [];
        }
        return Array.apply(0, new Array(length)).map(function (v, i) { return value; });
    };
    /**
     * Make an array of numbers. All elements in the array will be a numerical sequence, 0, 1, 2, 3....
     * @param length  The length of the new array. If length is 0, then an empty array is returned.
     * @returns The resulting array.
     */
    Arr.makeSeq = function (length) {
        if (length === 0) {
            return [];
        }
        return Array.apply(0, new Array(length)).map(function (v, i) { return i; });
    };
    /**
     * Check if two nD arrays are equal (i.e. that all elements in the array are equal, ===.).
     * If the arrays are unequal in length, false is returned.
     * Elements in the array can have any value.
     * @param arr1 The first value.
     * @param arr2 The second values.
     * @returns True or false.
     */
    Arr.equal = function (arr1, arr2) {
        if (!Array.isArray(arr1) || !Array.isArray(arr2)) {
            return arr1 === arr2;
        }
        if (arr1.length !== arr2.length) {
            return false;
        }
        for (var i = 0; i < arr1.length; i++) {
            if (!this.equal(arr1[i], arr2[i])) {
                return false;
            }
        }
        return true;
    };
    /**
     * Find the position of the first occurrence of a specified value in an array.
     * The value can be an array (which is not the case for Array.indexOf()).
     * If the value is not found or is undefined, return -1.
     * If the array is null or undefined, return -1.
     * @param value The value, can be a value or a 1D array of values.
     * @returns The index in the array of the first occurance of the value.
     */
    Arr.indexOf = function (arr, value) {
        if (!Array.isArray(arr)) {
            throw new Error("First argument must be a array.");
        }
        if (!Array.isArray(value)) {
            return arr.indexOf(value);
        }
        for (var i = 0; i < arr.length; i++) {
            if (Array.isArray(arr[i]) && this.equal(value, arr[i])) {
                return i;
            }
        }
        return -1;
    };
    /**
     * Replace all occurrences of a specified value in an array.
     * The input array is changed.
     * The value can be an array.
     * If the value is not found or is undefined, return -1.
     * @param old_value The old value to replace.
     * @param new_value The new value.
     * @param arr The array.
     */
    Arr.replace = function (arr, old_value, new_value) {
        if (!Array.isArray(arr)) {
            throw new Error("First argument must be a array.");
        }
        for (var i = 0; i < arr.length; i++) {
            if (this.equal(arr[i], old_value)) {
                arr[i] = new_value;
            }
        }
    };
    /**
     * Take an nD array and flattens it.
     * A new array is returned. The input array remains unchanged.
     * For example, [1, 2, [3, 4], [5, 6]] will become [1, 2, 3, 4, 5, 6].
     * If the input array is undefined, an empty array is returned.
     * @param arr The multidimensional array to flatten.
     * @returns A new 1D array.
     */
    Arr.flatten = function (arr, depth) {
        if (arr === undefined) {
            return [];
        }
        return arr.reduce(function (flat, toFlatten) {
            if (depth === undefined) {
                return flat.concat(Array.isArray(toFlatten) ? Arr.flatten(toFlatten) : toFlatten);
            }
            else {
                return flat.concat((Array.isArray(toFlatten) && (depth !== 0)) ?
                    Arr.flatten(toFlatten, depth - 1) : toFlatten);
            }
        }, []);
    };
    /**
     * Make a copy of an nD array.
     * If the input is not an array, then just return the same thing.
     * A new array is returned. The input array remains unchanged.
     * If the input array is undefined, an empty array is returned.
     * If the input is s sparse array, then the output will alos be a sparse array.
     * @param arr The nD array to copy.
     * @returns The new nD array.
     */
    Arr.deepCopy = function (arr) {
        if (arr === undefined) {
            return [];
        }
        if (!Array.isArray(arr)) {
            return arr;
        }
        var arr2 = [];
        for (var i = 0; i < arr.length; i++) {
            if (Array.isArray(arr[i])) {
                arr2[i] = (Arr.deepCopy(arr[i]));
            }
            else {
                if (arr[i] !== undefined) {
                    arr2[i] = (arr[i]);
                }
            }
        }
        return arr2;
    };
    /**
     * Fills an nD array with new values (all the same value).
     * The input array is changed.
     * If the input array is undefined, an empty array is returned.
     * The input can be a sparse array.
     * @param arr The nD array to fill.
     * @param value The value to insert into the array.
     */
    Arr.deepFill = function (arr, value) {
        if (arr === undefined) {
            return;
        }
        for (var i = 0; i < arr.length; i++) {
            if (Array.isArray(arr[i])) {
                Arr.deepFill(arr[i], value);
            }
            else {
                if (arr[i] !== undefined) {
                    arr[i] = value;
                }
            }
        }
    };
    /**
     * Counts the number of values in an nD array .
     * The input array remains unchanged.
     * If the input array is undefined, 0 is returned.
     * The input can be a sparse array. Undefined values are ignored.
     * For example, for [1, 2, , , 3], the count will be 3.
     * @param arr The nD array to count.
     * @return The number of elements in the nD array.
     */
    Arr.deepCount = function (arr) {
        if (arr === undefined) {
            return 0;
        }
        var a = 0;
        for (var i in arr) {
            if (Array.isArray(arr[i])) {
                a = a + Arr.deepCount(arr[i]);
            }
            else {
                if (arr[i] !== undefined) {
                    a = a + 1;
                }
            }
        }
        return a;
    };
    return Arr;
}());



/***/ }),

/***/ "./src/app/core/modules/libs/conics/circle3Points.ts":
/*!***********************************************************!*\
  !*** ./src/app/core/modules/libs/conics/circle3Points.ts ***!
  \***********************************************************/
/*! exports provided: circleFrom3Points */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "circleFrom3Points", function() { return circleFrom3Points; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _threex_threex__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../threex/threex */ "./src/app/core/modules/libs/threex/threex.ts");
var __read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (undefined && undefined.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};


var EPS = 1e-6;
// import * as roots from "poly-roots";
// import * as quadratic from "solve-quadratic-equation";
// import * as trigo from "./trigo";
// import * as pl from "../../plane_dev"; // TODO - can be reomved?
/**
 * Find the center of a circle that passes through three XYZ positions in 3D space.
 * @returns An array of intersection points
 */
function _circleCenterFrom3Points(a, b, c) {
    //https://math.stackexchange.com/questions/1076177/3d-coordinates-of-circle-center-given-three-point-on-the-circle
    var ax = a[0];
    var ay = a[1];
    var az = a[2];
    var bx = b[0];
    var by = b[1];
    var bz = b[2];
    var cx = c[0];
    var cy = c[1];
    var cz = c[2];
    var Cx = bx - ax;
    var Cy = by - ay;
    var Cz = bz - az;
    var Bx = cx - ax;
    var By = cy - ay;
    var Bz = cz - az;
    var B2 = Math.pow(ax, 2) - Math.pow(cx, 2) + Math.pow(ay, 2) - Math.pow(cy, 2) + Math.pow(az, 2) - Math.pow(cz, 2);
    var C2 = Math.pow(ax, 2) - Math.pow(bx, 2) + Math.pow(ay, 2) - Math.pow(by, 2) + Math.pow(az, 2) - Math.pow(bz, 2);
    var CByz = Cy * Bz - Cz * By;
    var CBxz = Cx * Bz - Cz * Bx;
    var CBxy = Cx * By - Cy * Bx;
    var ZZ1 = -(Bz - Cz * Bx / Cx) / (By - Cy * Bx / Cx);
    var Z01 = -(B2 - Bx / Cx * C2) / (2 * (By - Cy * Bx / Cx));
    var ZZ2 = -(ZZ1 * Cy + Cz) / Cx;
    var Z02 = -(2 * Z01 * Cy + C2) / (2 * Cx);
    // and finally the coordinates of the center:
    var dz = -((Z02 - ax) * CByz - (Z01 - ay) * CBxz - az * CBxy) / (ZZ2 * CByz - ZZ1 * CBxz + CBxy);
    var dx = ZZ2 * dz + Z02;
    var dy = ZZ1 * dz + Z01;
    return [dx, dy, dz];
}
function circleFrom3Points(xyz1, xyz2, xyz3, is_closed) {
    var _a, _b, _c, _d;
    // create vectors
    var p1 = new ((_a = three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]).bind.apply(_a, __spread([void 0], xyz1)))();
    var p2 = new ((_b = three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]).bind.apply(_b, __spread([void 0], xyz2)))();
    var p3 = new ((_c = three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]).bind.apply(_c, __spread([void 0], xyz3)))();
    var world_x = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](1, 0, 0);
    var world_y = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](0, 1, 0);
    var world_z = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](0, 0, 1);
    // calc vectors for xform matrix
    var x_axis = _threex_threex__WEBPACK_IMPORTED_MODULE_1__["subVectors"](p2, p1); // .normalize();
    var tmp_vec = _threex_threex__WEBPACK_IMPORTED_MODULE_1__["subVectors"](p3, p2);
    var z_axis = _threex_threex__WEBPACK_IMPORTED_MODULE_1__["crossVectors"](x_axis, tmp_vec); // .normalize();
    var y_axis = _threex_threex__WEBPACK_IMPORTED_MODULE_1__["crossVectors"](z_axis, x_axis); // .normalize();
    // create the xform matrices to map 3d -> 2d
    var m = _threex_threex__WEBPACK_IMPORTED_MODULE_1__["xformMatrixNeg"](p1, x_axis, y_axis);
    var m_inv = _threex_threex__WEBPACK_IMPORTED_MODULE_1__["matrixInverse"](m);
    // calc the circle origin
    var p2_2d = _threex_threex__WEBPACK_IMPORTED_MODULE_1__["multVectorMatrix"](p2, m);
    var p3_2d = _threex_threex__WEBPACK_IMPORTED_MODULE_1__["multVectorMatrix"](p3, m);
    var origin_2d_xyz = _circleCenterFrom3Points([0, 0, 0], p2_2d.toArray(), p3_2d.toArray());
    var origin_2d = new ((_d = three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]).bind.apply(_d, __spread([void 0], origin_2d_xyz)))();
    var circle_origin = _threex_threex__WEBPACK_IMPORTED_MODULE_1__["multVectorMatrix"](origin_2d, m_inv);
    // calc the circle radius
    // const radius: number = origin_2d.length();
    // is not arc? then return data for circle
    m_inv.setPosition(new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]());
    if (is_closed) {
        var circle_x_axis_2d_1 = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](origin_2d.length(), 0, 0);
        var circle_x_axis_1 = _threex_threex__WEBPACK_IMPORTED_MODULE_1__["multVectorMatrix"](circle_x_axis_2d_1, m_inv);
        var circle_y_axis_2d_1 = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](0, 1, 0);
        var circle_y_axis_1 = _threex_threex__WEBPACK_IMPORTED_MODULE_1__["multVectorMatrix"](circle_y_axis_2d_1, m_inv);
        return {
            origin: circle_origin.toArray(),
            vec_x: circle_x_axis_1.toArray(),
            vec_y: circle_y_axis_1.toArray(),
            angle: null
        };
    }
    // calc the circle vectors
    var circle_x_axis_2d = _threex_threex__WEBPACK_IMPORTED_MODULE_1__["vectorNegate"](origin_2d);
    var circle_x_axis = _threex_threex__WEBPACK_IMPORTED_MODULE_1__["multVectorMatrix"](circle_x_axis_2d, m_inv);
    var circle_y_axis_2d = _threex_threex__WEBPACK_IMPORTED_MODULE_1__["crossVectors"](world_z, circle_x_axis_2d);
    var circle_y_axis = _threex_threex__WEBPACK_IMPORTED_MODULE_1__["multVectorMatrix"](circle_y_axis_2d, m_inv);
    // calc the circle angles
    var angle_vec_2d = _threex_threex__WEBPACK_IMPORTED_MODULE_1__["subVectors"](p3_2d, origin_2d);
    var angle = circle_x_axis_2d.angleTo(angle_vec_2d);
    angle = angle * 180 / Math.PI;
    var angle_gt_180 = (_threex_threex__WEBPACK_IMPORTED_MODULE_1__["crossVectors"](circle_x_axis_2d, angle_vec_2d).z < 0);
    var y_gt_0 = (circle_origin.y > 0);
    if (angle_gt_180) {
        angle = 360 - angle;
    }
    // return the data for arc
    return {
        origin: circle_origin.toArray(),
        vec_x: circle_x_axis.toArray(),
        vec_y: circle_y_axis.toArray(),
        angle: angle
    };
}


/***/ }),

/***/ "./src/app/core/modules/libs/conics/circleCircle2D.ts":
/*!************************************************************!*\
  !*** ./src/app/core/modules/libs/conics/circleCircle2D.ts ***!
  \************************************************************/
/*! exports provided: isectCircleCircle2D, innerTangentsCircleCircle2D, outerTangentsCircleCircle2D */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isectCircleCircle2D", function() { return isectCircleCircle2D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "innerTangentsCircleCircle2D", function() { return innerTangentsCircleCircle2D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "outerTangentsCircleCircle2D", function() { return outerTangentsCircleCircle2D; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _threex_threex__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../threex/threex */ "./src/app/core/modules/libs/threex/threex.ts");
/* harmony import */ var kld_intersections__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! kld-intersections */ "./node_modules/kld-intersections/index.js");
/* harmony import */ var kld_intersections__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(kld_intersections__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _circleUtil__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./circleUtil */ "./src/app/core/modules/libs/conics/circleUtil.ts");
var __read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (undefined && undefined.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __values = (undefined && undefined.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};




var EPS = 1e-6;
/**
 * Circle-circle intersection
 * @param circle1
 * @param circle2
 * @returns An array of intersection points
 */
function isectCircleCircle2D(circle1, circle2) {
    var _a, _b, _c, _d, _e, _f, e_1, _g, e_2, _h, e_3, _j;
    var m1 = circle1.getModel();
    var m2 = circle2.getModel();
    if (m1 !== m2) {
        throw new Error("Entities must be in the same model.");
    }
    var v1 = circle1.getAxes();
    var v2 = circle2.getAxes();
    if (!_threex_threex__WEBPACK_IMPORTED_MODULE_1__["planesAreCoplanar"](circle1.getOrigin(), v1[2], circle2.getOrigin(), v2[2])) {
        throw new Error("Entities must be coplanar.");
    }
    var g1 = m1.getGeom();
    var r = circle1.getRadius() + circle2.getRadius();
    var O1O2 = _threex_threex__WEBPACK_IMPORTED_MODULE_1__["vectorFromPointsAtoB"](circle1.getOrigin(), circle2.getOrigin(), false);
    if (O1O2.length() > r) {
        return null;
    }
    // Direct Orthonormal Basis of reference
    var O1 = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](0, 0, 0);
    var e1 = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](1, 0, 0);
    var e2 = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](0, 1, 0);
    var e3 = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](0, 0, 1);
    // Circle 1 Direct Orthonormal Basis
    var C1 = new ((_a = three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]).bind.apply(_a, __spread([void 0], circle1.getOrigin().getPosition())))();
    var U1 = new ((_b = three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]).bind.apply(_b, __spread([void 0], v1[0])))().normalize();
    var V1 = new ((_c = three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]).bind.apply(_c, __spread([void 0], v1[1])))().normalize();
    var W1 = _threex_threex__WEBPACK_IMPORTED_MODULE_1__["crossVectors"](U1, V1, true);
    var angles1 = circle1.getAngles();
    if (angles1 === null) {
        angles1 = [0, 360];
    }
    var angles_circle_1 = angles1[1] - angles1[0];
    // Circle 2 Direct Orthonormal Basis
    var C2 = new ((_d = three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]).bind.apply(_d, __spread([void 0], circle2.getOrigin().getPosition())))();
    var U2 = new ((_e = three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]).bind.apply(_e, __spread([void 0], v2[0])))().normalize();
    var V2 = new ((_f = three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]).bind.apply(_f, __spread([void 0], v2[1])))().normalize();
    var W2 = _threex_threex__WEBPACK_IMPORTED_MODULE_1__["crossVectors"](U2, V2, true);
    var angles2 = circle2.getAngles();
    if (angles2 === null) {
        angles2 = [0, 360];
    }
    var angles_circle_2 = angles2[1] - angles2[0];
    // Rotation Matrix expressed in the reference direct orthonormal basis
    // Circle 1
    var C1O1 = _threex_threex__WEBPACK_IMPORTED_MODULE_1__["subVectors"](O1, C1, false);
    var vec_O_1 = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](_threex_threex__WEBPACK_IMPORTED_MODULE_1__["dotVectors"](C1O1, U1), _threex_threex__WEBPACK_IMPORTED_MODULE_1__["dotVectors"](C1O1, V1), _threex_threex__WEBPACK_IMPORTED_MODULE_1__["dotVectors"](C1O1, W1));
    var x1 = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](_threex_threex__WEBPACK_IMPORTED_MODULE_1__["dotVectors"](e1, U1), _threex_threex__WEBPACK_IMPORTED_MODULE_1__["dotVectors"](e1, V1), _threex_threex__WEBPACK_IMPORTED_MODULE_1__["dotVectors"](e1, W1));
    var y1 = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](_threex_threex__WEBPACK_IMPORTED_MODULE_1__["dotVectors"](e2, U1), _threex_threex__WEBPACK_IMPORTED_MODULE_1__["dotVectors"](e2, V1), _threex_threex__WEBPACK_IMPORTED_MODULE_1__["dotVectors"](e2, W1));
    var rotation1 = _threex_threex__WEBPACK_IMPORTED_MODULE_1__["xformMatrixNeg"](vec_O_1, x1, y1);
    // Initial Rotation Matrix expressed in the reference direct orthonormal basis
    // Circle 1
    var O1C1 = _threex_threex__WEBPACK_IMPORTED_MODULE_1__["subVectors"](C1, O1, false);
    var init_vec_O_1 = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](_threex_threex__WEBPACK_IMPORTED_MODULE_1__["dotVectors"](O1C1, e1), _threex_threex__WEBPACK_IMPORTED_MODULE_1__["dotVectors"](O1C1, e2), _threex_threex__WEBPACK_IMPORTED_MODULE_1__["dotVectors"](O1C1, e3));
    var init_x1 = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](_threex_threex__WEBPACK_IMPORTED_MODULE_1__["dotVectors"](U1, e1), _threex_threex__WEBPACK_IMPORTED_MODULE_1__["dotVectors"](U1, e2), _threex_threex__WEBPACK_IMPORTED_MODULE_1__["dotVectors"](U1, e3));
    var init_y1 = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](_threex_threex__WEBPACK_IMPORTED_MODULE_1__["dotVectors"](V1, e1), _threex_threex__WEBPACK_IMPORTED_MODULE_1__["dotVectors"](V1, e2), _threex_threex__WEBPACK_IMPORTED_MODULE_1__["dotVectors"](V1, e3));
    var init_rotation1 = _threex_threex__WEBPACK_IMPORTED_MODULE_1__["xformMatrixNeg"](init_vec_O_1, init_x1, init_y1);
    var a = _threex_threex__WEBPACK_IMPORTED_MODULE_1__["multVectorMatrix"](C1, init_rotation1);
    var b = _threex_threex__WEBPACK_IMPORTED_MODULE_1__["multVectorMatrix"](C2, init_rotation1);
    var circle_1 = {
        center: new kld_intersections__WEBPACK_IMPORTED_MODULE_2__["Point2D"](a.x, a.y),
        radius: circle1.getRadius(),
    };
    var circle_2 = {
        center: new kld_intersections__WEBPACK_IMPORTED_MODULE_2__["Point2D"](b.x, b.y),
        radius: circle2.getRadius(),
    };
    var result = kld_intersections__WEBPACK_IMPORTED_MODULE_2__["Intersection"].intersectCircleCircle(circle_1.center, circle_1.radius, circle_2.center, circle_2.radius);
    // Retransforming into original coordinates system
    var results = [];
    try {
        for (var _k = __values(result.points), _l = _k.next(); !_l.done; _l = _k.next()) {
            var point = _l.value;
            results.push(new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](point.x, point.y, 0));
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_l && !_l.done && (_g = _k.return)) _g.call(_k);
        }
        finally { if (e_1) throw e_1.error; }
    }
    var results_c1 = [];
    try {
        for (var results_1 = __values(results), results_1_1 = results_1.next(); !results_1_1.done; results_1_1 = results_1.next()) {
            var point = results_1_1.value;
            results_c1.push(_threex_threex__WEBPACK_IMPORTED_MODULE_1__["multVectorMatrix"](point, rotation1));
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (results_1_1 && !results_1_1.done && (_h = results_1.return)) _h.call(results_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    var points = [];
    try {
        for (var results_c1_1 = __values(results_c1), results_c1_1_1 = results_c1_1.next(); !results_c1_1_1.done; results_c1_1_1 = results_c1_1.next()) {
            var point = results_c1_1_1.value;
            var c1_to_point = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](point.x - C1.x, point.y - C1.y, point.z - C1.z);
            var c2_to_point = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](point.x - C2.x, point.y - C2.y, point.z - C2.z);
            var angle_1 = U1.angleTo(c1_to_point) * 180 / Math.PI;
            if (_threex_threex__WEBPACK_IMPORTED_MODULE_1__["crossVectors"](U1, c1_to_point).dot(_threex_threex__WEBPACK_IMPORTED_MODULE_1__["crossVectors"](U1, V1)) < 0) {
                angle_1 = 360 - angle_1;
            }
            var angle_2 = U2.angleTo(c2_to_point) * 180 / Math.PI;
            if (_threex_threex__WEBPACK_IMPORTED_MODULE_1__["crossVectors"](U2, c2_to_point).dot(_threex_threex__WEBPACK_IMPORTED_MODULE_1__["crossVectors"](U2, V2)) < 0) {
                angle_2 = 360 - angle_2;
            }
            // if (angles_circle_1 - angle_1 >= 0 && angles_circle_2 - angle_2 >= 0) {
            //     points.push(g1.addPoint([point.x, point.y, point.z]));
            // }
            if (_circleUtil__WEBPACK_IMPORTED_MODULE_3__["angleInCircle"](circle1, angle_1) && _circleUtil__WEBPACK_IMPORTED_MODULE_3__["angleInCircle"](circle2, angle_2)) {
                points.push(g1.addPoint([point.x, point.y, point.z]));
            }
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (results_c1_1_1 && !results_c1_1_1.done && (_j = results_c1_1.return)) _j.call(results_c1_1);
        }
        finally { if (e_3) throw e_3.error; }
    }
    return points;
}
/**
 * Find the inner tangents of two coplanar circles.
 * @param circle1
 * @param circle2
 * @returns An array of start and end points of the two tangent lines
 */
function innerTangentsCircleCircle2D(circle1, circle2) {
    var _a, _b;
    var c1_origin = new ((_a = three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]).bind.apply(_a, __spread([void 0], circle1.getOrigin().getPosition())))();
    var c1_axes = circle1.getAxes().map(function (v) {
        var _a;
        return new ((_a = three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]).bind.apply(_a, __spread([void 0], v)))();
    });
    var c2_origin = new ((_b = three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]).bind.apply(_b, __spread([void 0], circle2.getOrigin().getPosition())))();
    var c2_axes = circle2.getAxes().map(function (v) {
        var _a;
        return new ((_a = three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]).bind.apply(_a, __spread([void 0], v)))();
    });
    if (!_threex_threex__WEBPACK_IMPORTED_MODULE_1__["planesAreCoplanar"](c1_origin, c1_axes[2], c2_origin, c2_axes[2])) {
        throw new Error("Circles must be coplanar.");
    }
    // set the x axis to be from o1 to o2
    var x_vec = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]().subVectors(c2_origin, c1_origin).normalize();
    var y_vec = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]().crossVectors(x_vec, c1_axes[2]);
    // make matrixes
    var matrix_pos = _threex_threex__WEBPACK_IMPORTED_MODULE_1__["xformMatrixPos"](c1_origin, x_vec, y_vec);
    var matrix_neg = _threex_threex__WEBPACK_IMPORTED_MODULE_1__["xformMatrixNeg"](c1_origin, x_vec, y_vec);
    // transform origins from 3d to 2d
    c1_origin.applyMatrix4(matrix_neg);
    c2_origin.applyMatrix4(matrix_neg);
    // get the radii
    var r1 = circle1.getRadius();
    var r2 = circle2.getRadius();
    // check that circles do not overlap
    if ((r1 + r2) >= c2_origin.x) {
        return null;
    }
    // calc mid point
    var dist = c2_origin.x;
    var dist1 = dist * (r1 / (r1 + r2));
    var dist2 = dist - dist1;
    // calc angles, a1 is the angle to the start point
    var a1 = Math.acos(r1 / dist1);
    // calc start and end of each inner tangent line
    var t1_start = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](r1 * Math.cos(a1), r1 * Math.sin(a1), 0);
    var t2_start = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](t1_start.x, -t1_start.y, 0);
    var t1_end = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](dist - (r2 * Math.cos(a1)), -r2 * Math.sin(a1), 0);
    var t2_end = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](t1_end.x, -t1_end.y, 0);
    // tranform points from 2d to 3d
    t1_start.applyMatrix4(matrix_pos);
    t2_start.applyMatrix4(matrix_pos);
    t1_end.applyMatrix4(matrix_pos);
    t2_end.applyMatrix4(matrix_pos);
    // create points in the model
    var g = circle1.getModel().getGeom();
    var t1_start_point = g.addPoint(t1_start.toArray());
    var t2_start_point = g.addPoint(t2_start.toArray());
    var t1_end_point = g.addPoint(t1_end.toArray());
    var t2_end_point = g.addPoint(t2_end.toArray());
    // return the two polylines
    return [
        g.addPolyline([t1_start_point, t1_end_point], false),
        g.addPolyline([t2_start_point, t2_end_point], false)
    ];
}
/**
 * Find the outer tangents of two coplanar circles.
 * @param circle1
 * @param circle2
 * @returns An array of two tangent lines
 */
function outerTangentsCircleCircle2D(circle1, circle2) {
    var _a, _b;
    var c1_origin = new ((_a = three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]).bind.apply(_a, __spread([void 0], circle1.getOrigin().getPosition())))();
    var c1_axes = circle1.getAxes().map(function (v) {
        var _a;
        return new ((_a = three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]).bind.apply(_a, __spread([void 0], v)))();
    });
    var c2_origin = new ((_b = three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]).bind.apply(_b, __spread([void 0], circle2.getOrigin().getPosition())))();
    var c2_axes = circle2.getAxes().map(function (v) {
        var _a;
        return new ((_a = three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]).bind.apply(_a, __spread([void 0], v)))();
    });
    if (!_threex_threex__WEBPACK_IMPORTED_MODULE_1__["planesAreCoplanar"](c1_origin, c1_axes[2], c2_origin, c2_axes[2])) {
        throw new Error("Circles must be coplanar.");
    }
    // set the x axis to be from o1 to o2
    var x_vec = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]().subVectors(c2_origin, c1_origin).normalize();
    var y_vec = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]().crossVectors(x_vec, c1_axes[2]);
    // make matrixes
    var matrix_pos = _threex_threex__WEBPACK_IMPORTED_MODULE_1__["xformMatrixPos"](c1_origin, x_vec, y_vec);
    var matrix_neg = _threex_threex__WEBPACK_IMPORTED_MODULE_1__["xformMatrixNeg"](c1_origin, x_vec, y_vec);
    // transform origins from 3d to 2d
    c1_origin.applyMatrix4(matrix_neg);
    c2_origin.applyMatrix4(matrix_neg);
    // get the radii
    var r1 = circle1.getRadius();
    var r2 = circle2.getRadius();
    // check that circles do not overlap
    if ((r1 + r2) >= c2_origin.x) {
        return null;
    }
    // dist between origins
    var dist = c2_origin.x;
    // calc angles, a1 is the angle to the start point
    var a1;
    if (r1 > r1) {
        a1 = Math.acos((r2 - r1) / dist);
    }
    else {
        a1 = -Math.acos((r1 - r2) / dist);
    }
    // calc start and end of each inner tangent line
    var t1_start = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](r1 * Math.cos(a1), r1 * Math.sin(a1), 0);
    var t1_end = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](dist + (r2 * Math.cos(a1)), r2 * Math.sin(a1), 0);
    var t2_start = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](t1_start.x, -t1_start.y, 0);
    var t2_end = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](t1_end.x, -t1_end.y, 0);
    // tranform points from 2d to 3d
    t1_start.applyMatrix4(matrix_pos);
    t2_start.applyMatrix4(matrix_pos);
    t1_end.applyMatrix4(matrix_pos);
    t2_end.applyMatrix4(matrix_pos);
    // create points in the model
    var g = circle1.getModel().getGeom();
    var t1_start_point = g.addPoint(t1_start.toArray());
    var t2_start_point = g.addPoint(t2_start.toArray());
    var t1_end_point = g.addPoint(t1_end.toArray());
    var t2_end_point = g.addPoint(t2_end.toArray());
    // return the two polylines
    return [
        g.addPolyline([t1_start_point, t1_end_point], false),
        g.addPolyline([t2_start_point, t2_end_point], false)
    ];
}


/***/ }),

/***/ "./src/app/core/modules/libs/conics/circlePlane3D.ts":
/*!***********************************************************!*\
  !*** ./src/app/core/modules/libs/conics/circlePlane3D.ts ***!
  \***********************************************************/
/*! exports provided: isectCirclePlane3D */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isectCirclePlane3D", function() { return isectCirclePlane3D; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _trigo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./trigo */ "./src/app/core/modules/libs/conics/trigo.ts");
/* harmony import */ var _circleUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./circleUtil */ "./src/app/core/modules/libs/conics/circleUtil.ts");
var __read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (undefined && undefined.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __values = (undefined && undefined.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};



var EPS = 1e-6;
/**
 * Circle-Plane intersection
 * @param circle
 * @param plane
 * @returns Adds intersecting points to the geometry if successfull, [] if empty or coplanar
 */
function isectCirclePlane3D(circle, plane) {
    var _a, _b, e_1, _c;
    // http://mathforum.org/library/drmath/view/69136.html
    var m = circle.getModel();
    var eps = 1e-7;
    // get plane
    var PO = plane.getOrigin().getPosition();
    var n1 = [plane.getCartesians()[0], plane.getCartesians()[1], plane.getCartesians()[2]];
    // get circle
    var C0 = circle.getOrigin().getPosition();
    var CA = circle.getAxes();
    var U1 = new ((_a = three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]).bind.apply(_a, __spread([void 0], CA[0])))();
    var V1 = new ((_b = three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]).bind.apply(_b, __spread([void 0], CA[1])))().setLength(U1.length());
    var _n1 = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](n1[0], n1[1], n1[2]);
    // calculate t
    var A = n1[0] * (C0[0] - PO[0]) + n1[1] * (C0[1] - PO[1]) + n1[2] * (C0[2] - PO[2]);
    var B = n1[0] * U1.x + n1[1] * U1.y + n1[2] * U1.z;
    var C = n1[0] * V1.x + n1[1] * V1.y + n1[2] * V1.z;
    var _t = _trigo__WEBPACK_IMPORTED_MODULE_1__["_solve_trigo"](A, B, C);
    if (_t === null) {
        return [];
    }
    var result = [];
    if (Math.abs(Math.abs(_t[0] - _t[1]) - Math.PI) < EPS) {
        delete _t[0];
    }
    try {
        for (var _t_1 = __values(_t), _t_1_1 = _t_1.next(); !_t_1_1.done; _t_1_1 = _t_1.next()) {
            var t = _t_1_1.value;
            if ((t !== null) && (t != undefined)) {
                var ok1 = false;
                var ok2 = false;
                if (circle.isClosed()) {
                    ok1 = true;
                    ok2 = true;
                }
                else {
                    var angle = t * (180 / Math.PI);
                    if (_circleUtil__WEBPACK_IMPORTED_MODULE_2__["angleInCircle"](circle, angle)) {
                        ok1 = true;
                    }
                    if (_circleUtil__WEBPACK_IMPORTED_MODULE_2__["angleInCircle"](circle, angle + 180)) {
                        ok2 = true;
                    }
                    //console.log(circle.getAngles(), angle, ok1, angle + 180, ok2);
                }
                if (ok1) {
                    var point1 = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](C0[0] + Math.cos(t) * U1.x + Math.sin(t) * V1.x - PO[0], C0[1] + Math.cos(t) * U1.y + Math.sin(t) * V1.y - PO[1], C0[2] + Math.cos(t) * U1.z + Math.sin(t) * V1.z - PO[2]);
                    //console.log("point1", t, point1);
                    if (Math.abs(_n1.dot(point1)) < eps) {
                        result.push(m.getGeom().addPoint([
                            C0[0] + Math.cos(t) * U1.x + Math.sin(t) * V1.x,
                            C0[1] + Math.cos(t) * U1.y + Math.sin(t) * V1.y,
                            C0[2] + Math.cos(t) * U1.z + Math.sin(t) * V1.z
                        ]));
                    }
                }
                if (ok2) {
                    var point2 = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](C0[0] + Math.cos(t + Math.PI) * U1.x + Math.sin(t + Math.PI) * V1.x - PO[0], C0[1] + Math.cos(t + Math.PI) * U1.y + Math.sin(t + Math.PI) * V1.y - PO[1], C0[2] + Math.cos(t + Math.PI) * U1.z + Math.sin(t + Math.PI) * V1.z - PO[2]);
                    //console.log("point2", t, point2);
                    if (Math.abs(_n1.dot(point2)) < eps) {
                        result.push(m.getGeom().addPoint([
                            C0[0] + Math.cos(t + Math.PI) * U1.x + Math.sin(t + Math.PI) * V1.x,
                            C0[1] + Math.cos(t + Math.PI) * U1.y + Math.sin(t + Math.PI) * V1.y,
                            C0[2] + Math.cos(t + Math.PI) * U1.z + Math.sin(t + Math.PI) * V1.z
                        ]));
                    }
                }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_t_1_1 && !_t_1_1.done && (_c = _t_1.return)) _c.call(_t_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return result;
}


/***/ }),

/***/ "./src/app/core/modules/libs/conics/circlePolyline2D.ts":
/*!**************************************************************!*\
  !*** ./src/app/core/modules/libs/conics/circlePolyline2D.ts ***!
  \**************************************************************/
/*! exports provided: _isectCircleLine2D */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_isectCircleLine2D", function() { return _isectCircleLine2D; });
var EPS = 1e-6;
/**
 * Circle-Line intersection
 * @param circle
 * @param Line, represented by 2 Points
 * @returns An array of intersection points
 */
function _isectCircleLine2D() {
    throw new Error("Method not implemented.");
}


/***/ }),

/***/ "./src/app/core/modules/libs/conics/circleUtil.ts":
/*!********************************************************!*\
  !*** ./src/app/core/modules/libs/conics/circleUtil.ts ***!
  \********************************************************/
/*! exports provided: pointInCircle, tInCircle, angleInCircle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pointInCircle", function() { return pointInCircle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tInCircle", function() { return tInCircle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "angleInCircle", function() { return angleInCircle; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _threex_threex__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../threex/threex */ "./src/app/core/modules/libs/threex/threex.ts");
var __read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (undefined && undefined.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};


var EPS = 1e-6;
/**
 * Check if a points is within the circle arc
 * @param circle
 * @param point
 * @returns True is it is inside
 */
function pointInCircle(circle, point) {
    var _a;
    if (circle.isClosed()) {
        return true;
    }
    // create matrix to map from the 3D plane for circle into the XY plane
    var origin = circle.getOrigin().getPosition();
    var axes = circle.getAxes();
    var matrix = _threex_threex__WEBPACK_IMPORTED_MODULE_1__["xformMatrixFromXYZAxes"](origin, axes, true);
    // map the point onto the XY plane
    var vpoint = new ((_a = three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]).bind.apply(_a, __spread([void 0], point.getPosition())))();
    vpoint.applyMatrix4(matrix);
    // calculate the angle between the point vector and the x axis, in radians
    var angle_rad = Math.atan2(vpoint.y, vpoint.x);
    if (angle_rad < 0) {
        angle_rad += (2 * Math.PI);
    }
    var angle_deg = angle_rad * (180 / Math.PI);
    // mow check angle
    return angleInCircle(circle, angle_deg);
}
/**
 * Check if a t value (for closed circle) is within the circle arc
 * @param circle
 * @param t
 * @returns True is it is inside
 */
function tInCircle(circle, t) {
    if (circle.isClosed()) {
        return true;
    }
    var angle = t * (180 / Math.PI);
    return angleInCircle(circle, angle);
}
/**
 * Check if an angle (in degrees) isf within the circle arc
 * @param circle
 * @param angle
 * @returns True is it is inside
 */
function angleInCircle(circle, angle) {
    if (circle.isClosed()) {
        return true;
    }
    // convert angle to 0 to 360
    if (angle < 0) {
        angle = 360 + (angle % 360);
    }
    if (angle > 360) {
        angle = angle % 360;
    }
    // get the angles, calc start and end, incl EPS
    var angles = circle.getAngles();
    var start = angles[0] - EPS;
    var end = angles[1] + EPS;
    // return result
    if (angles[0] < angles[1]) {
        if ((angle >= start) && (angle <= end)) {
            return true;
        }
    }
    else {
        if ((angle >= start) || (angle <= end)) {
            return true;
        }
    }
    return false;
}


/***/ }),

/***/ "./src/app/core/modules/libs/conics/circles.ts":
/*!*****************************************************!*\
  !*** ./src/app/core/modules/libs/conics/circles.ts ***!
  \*****************************************************/
/*! exports provided: circleFrom3Points, isectCircleCircle2D, innerTangentsCircleCircle2D, outerTangentsCircleCircle2D, _isectCircleLine2D, isectCirclePlane3D */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _circle3Points__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./circle3Points */ "./src/app/core/modules/libs/conics/circle3Points.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "circleFrom3Points", function() { return _circle3Points__WEBPACK_IMPORTED_MODULE_0__["circleFrom3Points"]; });

/* harmony import */ var _circleCircle2D__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./circleCircle2D */ "./src/app/core/modules/libs/conics/circleCircle2D.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isectCircleCircle2D", function() { return _circleCircle2D__WEBPACK_IMPORTED_MODULE_1__["isectCircleCircle2D"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "innerTangentsCircleCircle2D", function() { return _circleCircle2D__WEBPACK_IMPORTED_MODULE_1__["innerTangentsCircleCircle2D"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "outerTangentsCircleCircle2D", function() { return _circleCircle2D__WEBPACK_IMPORTED_MODULE_1__["outerTangentsCircleCircle2D"]; });

/* harmony import */ var _circlePolyline2D__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./circlePolyline2D */ "./src/app/core/modules/libs/conics/circlePolyline2D.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_isectCircleLine2D", function() { return _circlePolyline2D__WEBPACK_IMPORTED_MODULE_2__["_isectCircleLine2D"]; });

/* harmony import */ var _circlePlane3D__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./circlePlane3D */ "./src/app/core/modules/libs/conics/circlePlane3D.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isectCirclePlane3D", function() { return _circlePlane3D__WEBPACK_IMPORTED_MODULE_3__["isectCirclePlane3D"]; });







/***/ }),

/***/ "./src/app/core/modules/libs/conics/trigo.ts":
/*!***************************************************!*\
  !*** ./src/app/core/modules/libs/conics/trigo.ts ***!
  \***************************************************/
/*! exports provided: _solve_trigo */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_solve_trigo", function() { return _solve_trigo; });
/**
  * Solves exact solutions of the trigonometric equation A + B.cos(t) + C.sin(t) = 0
  * @param A, real number, parameter of the trigonometric equation
  * @param B, real number, parameter of the trigonometric equation
  * @param C, real number, parameter of the trigonometric equation
  * @return a set of 2 real numbers solutions of the equation
  */
function _solve_trigo(A, B, C) {
    var num1 = -A;
    var den1 = Math.sqrt(B * B + C * C);
    var num2 = B;
    var den2 = C;
    if (C === 0) {
        if (B === 0) {
            return null;
        }
        if (Math.abs(A / B) > 1) {
            return null;
        }
        return [(-Math.acos(-A / B)) % (2 * Math.PI), (Math.acos(-A / B)) % (2 * Math.PI)];
    }
    if (Math.abs(num1 / den1) > 1) {
        return null;
    }
    var t1 = Math.asin(num1 / den1) - Math.atan(num2 / den2);
    var t2 = Math.PI - Math.atan(num2 / den2) - Math.asin(num1 / den1);
    return [t1 % (2 * Math.PI), t2 % (2 * Math.PI)];
}


/***/ }),

/***/ "./src/app/core/modules/libs/filesys/download.ts":
/*!*******************************************************!*\
  !*** ./src/app/core/modules/libs/filesys/download.ts ***!
  \*******************************************************/
/*! exports provided: save */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "save", function() { return save; });
function save(data, filename) {
    var data_type = 'text/plain;charset=utf-8';
    var data_bom = decodeURIComponent('%ef%bb%bf');
    if (window.navigator.msSaveBlob) {
        var blob = new Blob([data_bom + data], { type: data_type });
        window.navigator.msSaveBlob(blob, data);
    }
    else {
        var link = document.createElement('a');
        var content = data_bom + data;
        var uriScheme = ['data:', data_type, ','].join('');
        link.href = uriScheme + content;
        link.download = filename;
        //FF requires the link in actual DOM
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }
    return true;
}


/***/ }),

/***/ "./src/app/core/modules/libs/poly/poly.ts":
/*!************************************************!*\
  !*** ./src/app/core/modules/libs/poly/poly.ts ***!
  \************************************************/
/*! exports provided: getVertexNormal, pointsLoftLoop, pointsLoft, pointsExtend, pointsEvaluate, _isectPolylinePolyline2D, _splitPolylinePolyline2D */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getVertexNormal", function() { return getVertexNormal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pointsLoftLoop", function() { return pointsLoftLoop; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pointsLoft", function() { return pointsLoft; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pointsExtend", function() { return pointsExtend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pointsEvaluate", function() { return pointsEvaluate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_isectPolylinePolyline2D", function() { return _isectPolylinePolyline2D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_splitPolylinePolyline2D", function() { return _splitPolylinePolyline2D; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _threex_threex__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../threex/threex */ "./src/app/core/modules/libs/threex/threex.ts");
var __read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (undefined && undefined.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __values = (undefined && undefined.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};


var EPS = 1e-6;
/**
 * Get a normal from a face vertex
 */
function getVertexNormal(vertex) {
    var next = vertex.next();
    var prev = vertex.previous();
    var vector_next = _threex_threex__WEBPACK_IMPORTED_MODULE_1__["vectorFromVerticesAtoB"](vertex, next);
    var vector_prev = _threex_threex__WEBPACK_IMPORTED_MODULE_1__["vectorFromVerticesAtoB"](vertex, prev);
    var normal = _threex_threex__WEBPACK_IMPORTED_MODULE_1__["crossVectors"](vector_next, vector_prev);
    //console.log("normal", normal.lengthSq());
    if (normal.lengthSq() > EPS) {
        return normal;
    } //TODO normal length looks big
    // this will be executed for degenerate cases, e.g. colinear points
    for (var i = 0; i < vertex.getWireOrFace().numVertices() - 2; i++) {
        if (vector_prev.lengthSq() < EPS) {
            prev = prev.previous();
            vector_prev = _threex_threex__WEBPACK_IMPORTED_MODULE_1__["vectorFromVerticesAtoB"](vertex, prev);
        }
        next = next.next();
        vector_next = _threex_threex__WEBPACK_IMPORTED_MODULE_1__["vectorFromVerticesAtoB"](vertex, next);
        normal = _threex_threex__WEBPACK_IMPORTED_MODULE_1__["crossVectors"](vector_next, vector_prev);
        if (normal.lengthSq() > EPS) {
            return normal;
        }
    }
    throw new Error("Failed to get normal from face.");
}
/**
 *  Loop through a list of list of points, and loft.
 *  The lists represent rows, each row has sub lists. The sub lists get lofted.
 */
function pointsLoftLoop(points_lists, is_closed) {
    var mesh_points = [];
    var num_lists = points_lists.length;
    var list_length = points_lists[0].length;
    for (var list_pos = 0; list_pos < list_length; list_pos++) {
        var points_list = [];
        for (var list_num = 0; list_num < num_lists; list_num++) {
            points_list.push(points_lists[list_num][list_pos]);
        }
        mesh_points.push.apply(mesh_points, __spread(pointsLoft(points_list, is_closed)));
    }
    return mesh_points;
}
/**
 *  Generate a nested list of points, ready for creating polymesh faces.
 */
function pointsLoft(points, is_closed) {
    var mesh_points = [];
    for (var i = 0; i < points.length - 1; i++) {
        for (var j = 0; j < points[i].length; j++) {
            if (j < points[i].length - 1) {
                mesh_points.push([points[i][j], points[i][j + 1], points[i + 1][j + 1], points[i + 1][j]]);
            }
            else {
                if (is_closed) {
                    mesh_points.push([points[i][j], points[i][0], points[i + 1][0], points[i + 1][j]]);
                }
            }
        }
    }
    return mesh_points;
}
/**
 * Moves the end point away from the start point by distance.
 * If create_point is true, then a new point get created, otherwise the existing point gets moved.
 */
function pointsExtend(start, end, distance, create) {
    if (create === void 0) { create = true; }
    var _a, _b;
    var start_vec = new ((_a = three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]).bind.apply(_a, __spread([void 0], start.getPosition())))();
    var end_vec = new ((_b = three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]).bind.apply(_b, __spread([void 0], end.getPosition())))();
    var dir_vec = _threex_threex__WEBPACK_IMPORTED_MODULE_1__["subVectors"](end_vec, start_vec);
    dir_vec.setLength(distance);
    var new_xyz = _threex_threex__WEBPACK_IMPORTED_MODULE_1__["addVectors"](end_vec, dir_vec).toArray();
    if (create) {
        var geom = start.getGeom();
        return geom.addPoint(new_xyz);
    }
    else {
        end.setPosition(new_xyz);
        return end;
    }
}
/**
 * Evaluates the position between a sequence of points.
 * A new point is always created.
 */
function pointsEvaluate(points, t_param) {
    var geom = points[0].getGeom();
    if (t_param === 0) {
        return geom.addPoint(points[0].getPosition());
    }
    if (t_param === 1) {
        return geom.addPoint(points[points.length - 1].getPosition());
    }
    if (t_param < 0 || t_param > 1) {
        throw new Error("t parameter is out of range");
    }
    var vec_points = points.map(function (point) {
        var _a;
        return new ((_a = three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]).bind.apply(_a, __spread([void 0], point.getPosition())))();
    });
    var num_segs = points.length - 1;
    var dists_to_segends = [0];
    var total_length = 0;
    for (var i = 0; i < num_segs; i++) {
        var seg_vec = _threex_threex__WEBPACK_IMPORTED_MODULE_1__["subVectors"](vec_points[i + 1], vec_points[i]);
        total_length += seg_vec.length();
        dists_to_segends.push(total_length);
    }
    var t_mapped = t_param * total_length;
    for (var i = 0; i < vec_points.length - 1; i++) {
        if (t_mapped >= dists_to_segends[i] && t_mapped < dists_to_segends[i + 1]) {
            var start_seg = vec_points[i];
            var end_seg = vec_points[i + 1];
            var seg_vec = _threex_threex__WEBPACK_IMPORTED_MODULE_1__["subVectors"](end_seg, start_seg);
            var start_dist = dists_to_segends[i];
            seg_vec.setLength(t_mapped - start_dist);
            var xyz = _threex_threex__WEBPACK_IMPORTED_MODULE_1__["addVectors"](start_seg, seg_vec).toArray();
            return geom.addPoint(xyz);
        }
    }
    throw new Error("Something went wrong evaluating the t parameter.");
}
/**
 * Intersect polylines.
 */
function _isectPolylinePolyline2D(pline1, pline2) {
    var e_1, _a, e_2, _b;
    var model = pline1.getModel();
    var points1 = pline1.getPointsArr();
    var points2 = pline2.getPointsArr();
    // Add points for closed polylines
    if (pline1.isClosed()) {
        points1.push(points1[0]);
    }
    if (pline2.isClosed()) {
        points2.push(points2[0]);
    }
    // Create vpoints
    var points1_vec = points1.map(function (p) {
        var _a;
        return new ((_a = three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]).bind.apply(_a, __spread([void 0], p.getPosition())))();
    });
    var points2_vec = points2.map(function (p) {
        var _a;
        return new ((_a = three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]).bind.apply(_a, __spread([void 0], p.getPosition())))();
    });
    var ortho_vecs = _threex_threex__WEBPACK_IMPORTED_MODULE_1__["orthoVectorsFromPlanarVPoints"](__spread(points1_vec, points2_vec));
    // Create the matrixes to transform between 3d and 2d
    if (ortho_vecs === null) {
        throw new Error("Entities must be coplanar.");
    }
    var matrix_neg = _threex_threex__WEBPACK_IMPORTED_MODULE_1__["xformMatrixNeg"](points1_vec[0], ortho_vecs[0], ortho_vecs[1]);
    var matrix_pos = _threex_threex__WEBPACK_IMPORTED_MODULE_1__["xformMatrixPos"](points1_vec[0], ortho_vecs[0], ortho_vecs[1]);
    try {
        // Make the polyline points 2D, and also check that they really are 2d
        for (var points1_vec_1 = __values(points1_vec), points1_vec_1_1 = points1_vec_1.next(); !points1_vec_1_1.done; points1_vec_1_1 = points1_vec_1.next()) {
            var point = points1_vec_1_1.value;
            point.applyMatrix4(matrix_neg);
            if (Math.abs(point.z) > EPS) {
                return null;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (points1_vec_1_1 && !points1_vec_1_1.done && (_a = points1_vec_1.return)) _a.call(points1_vec_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    try {
        for (var points2_vec_1 = __values(points2_vec), points2_vec_1_1 = points2_vec_1.next(); !points2_vec_1_1.done; points2_vec_1_1 = points2_vec_1.next()) {
            var point = points2_vec_1_1.value;
            point.applyMatrix4(matrix_neg);
            if (Math.abs(point.z) > EPS) {
                return null;
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (points2_vec_1_1 && !points2_vec_1_1.done && (_b = points2_vec_1.return)) _b.call(points2_vec_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    // Loop through each edge and check for intersections
    var isect_points = [];
    for (var i = 0; i < points1_vec.length - 1; i++) {
        var line1_start = points1_vec[i];
        var line1_end = points1_vec[i + 1];
        for (var j = 0; j < points2_vec.length - 1; j++) {
            var line2_start = points2_vec[j];
            var line2_end = points2_vec[j + 1];
            var result = _isectLineLine2D(line1_start, line1_end, line2_start, line2_end);
            if (result !== null) {
                var xyz = result.isect_point.applyMatrix4(matrix_pos).toArray();
                var isect_point = model.getGeom().addPoint(xyz);
                // add the point
                isect_points.push(isect_point);
            }
        }
    }
    return isect_points;
}
/**
 * Split polylines.
 */
function _splitPolylinePolyline2D(pline1, pline2) {
    var e_3, _a, e_4, _b, e_5, _c, e_6, _d;
    var model = pline1.getModel();
    var points1 = pline1.getPointsArr();
    var points2 = pline2.getPointsArr();
    // Add points for closed polylines
    if (pline1.isClosed()) {
        points1.push(points1[0]);
    }
    if (pline2.isClosed()) {
        points2.push(points2[0]);
    }
    // Create vpoints
    var points1_vec = points1.map(function (p) {
        var _a;
        return new ((_a = three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]).bind.apply(_a, __spread([void 0], p.getPosition())))();
    });
    var points2_vec = points2.map(function (p) {
        var _a;
        return new ((_a = three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]).bind.apply(_a, __spread([void 0], p.getPosition())))();
    });
    var ortho_vecs = _threex_threex__WEBPACK_IMPORTED_MODULE_1__["orthoVectorsFromPlanarVPoints"](__spread(points1_vec, points2_vec));
    // Create the matrixes to transform between 3d and 2d
    if (ortho_vecs === null) {
        throw new Error("Entities must be coplanar.");
    }
    var matrix_neg = _threex_threex__WEBPACK_IMPORTED_MODULE_1__["xformMatrixNeg"](points1_vec[0], ortho_vecs[0], ortho_vecs[1]);
    var matrix_pos = _threex_threex__WEBPACK_IMPORTED_MODULE_1__["xformMatrixPos"](points1_vec[0], ortho_vecs[0], ortho_vecs[1]);
    try {
        // Make the polyline points 2D, and also check that they really are 2d
        for (var points1_vec_2 = __values(points1_vec), points1_vec_2_1 = points1_vec_2.next(); !points1_vec_2_1.done; points1_vec_2_1 = points1_vec_2.next()) {
            var point = points1_vec_2_1.value;
            point.applyMatrix4(matrix_neg);
            if (Math.abs(point.z) > EPS) {
                return null;
            }
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (points1_vec_2_1 && !points1_vec_2_1.done && (_a = points1_vec_2.return)) _a.call(points1_vec_2);
        }
        finally { if (e_3) throw e_3.error; }
    }
    try {
        for (var points2_vec_2 = __values(points2_vec), points2_vec_2_1 = points2_vec_2.next(); !points2_vec_2_1.done; points2_vec_2_1 = points2_vec_2.next()) {
            var point = points2_vec_2_1.value;
            point.applyMatrix4(matrix_neg);
            if (Math.abs(point.z) > EPS) {
                return null;
            }
        }
    }
    catch (e_4_1) { e_4 = { error: e_4_1 }; }
    finally {
        try {
            if (points2_vec_2_1 && !points2_vec_2_1.done && (_b = points2_vec_2.return)) _b.call(points2_vec_2);
        }
        finally { if (e_4) throw e_4.error; }
    }
    // Loop through each edge and check for intersections
    var isect1_map = new Map();
    var isect2_map = new Map();
    for (var i = 0; i < points1_vec.length - 1; i++) {
        var line1_start = points1_vec[i];
        var line1_end = points1_vec[i + 1];
        for (var j = 0; j < points2_vec.length - 1; j++) {
            var line2_start = points2_vec[j];
            var line2_end = points2_vec[j + 1];
            var result = _isectLineLine2D(line1_start, line1_end, line2_start, line2_end);
            if (result !== null) {
                var xyz = result.isect_point.applyMatrix4(matrix_pos).toArray();
                var isect_point = model.getGeom().addPoint(xyz);
                // add the point for pline1
                if (!isect1_map.has(i)) {
                    isect1_map.set(i, []);
                }
                isect1_map.get(i).push({ t: result.t1, isect_point: isect_point });
                // add the point for pline2
                if (!isect2_map.has(j)) {
                    isect2_map.set(j, []);
                }
                isect2_map.get(j).push({ t: result.t2, isect_point: isect_point });
            }
        }
    }
    // make the list of points for pline 1
    var new_points1 = [[points1[0]]];
    for (var i = 0; i < points1.length - 1; i++) {
        if (isect1_map.has(i)) {
            // sort the points in the list by t value
            var isects = isect1_map.get(i);
            isects.sort(function (a, b) { return a.t - b.t; });
            try {
                // for each isect, start a new array of points
                for (var isects_1 = __values(isects), isects_1_1 = isects_1.next(); !isects_1_1.done; isects_1_1 = isects_1.next()) {
                    var isect = isects_1_1.value;
                    new_points1[new_points1.length - 1].push(isect.isect_point);
                    new_points1.push([isect.isect_point]);
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (isects_1_1 && !isects_1_1.done && (_c = isects_1.return)) _c.call(isects_1);
                }
                finally { if (e_5) throw e_5.error; }
            }
        }
        // add the next point
        new_points1[new_points1.length - 1].push(points1[i + 1]);
    }
    // if the polyline was closed, then merge first and last lists
    if (pline1.isClosed()) {
        var last = new_points1[new_points1.length - 1];
        last.push.apply(last, __spread(new_points1[0]));
        new_points1[0] = last;
        new_points1.pop();
    }
    // make the list of points for pline 2
    var new_points2 = [[points2[0]]];
    for (var i = 0; i < points2.length - 1; i++) {
        if (isect2_map.has(i)) {
            // sort the points in the list by t value
            var isects = isect2_map.get(i);
            isects.sort(function (a, b) { return a.t - b.t; });
            try {
                // for each isect, start a new array of points
                for (var isects_2 = __values(isects), isects_2_1 = isects_2.next(); !isects_2_1.done; isects_2_1 = isects_2.next()) {
                    var isect = isects_2_1.value;
                    new_points2[new_points2.length - 1].push(isect.isect_point);
                    new_points2.push([isect.isect_point]);
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (isects_2_1 && !isects_2_1.done && (_d = isects_2.return)) _d.call(isects_2);
                }
                finally { if (e_6) throw e_6.error; }
            }
        }
        // add the next point
        new_points2[new_points2.length - 1].push(points2[i + 1]);
    }
    // if the polyline was closed, then merge first and last lists
    if (pline2.isClosed()) {
        var last = new_points2[new_points2.length - 1];
        last.push.apply(last, __spread(new_points2[0]));
        new_points2[0] = last;
        new_points2.pop();
    }
    // delete the old plines
    model.getGeom().delObjs([pline1, pline2], true);
    // return an array of new plines
    var new_plines1 = new_points1.map(function (pts) { return model.getGeom().addPolyline(pts, false); });
    var new_plines2 = new_points2.map(function (pts) { return model.getGeom().addPolyline(pts, false); });
    return [new_plines1, new_plines2];
}
/**
 * Intersect lines.
 * http://jsfiddle.net/justin_c_rounds/Gd2S2/light/
 */
function _isectLineLine2D(line1_start, line1_end, line2_start, line2_end) {
    var denominator = ((line2_end.y - line2_start.y) * (line1_end.x - line1_start.x)) -
        ((line2_end.x - line2_start.x) * (line1_end.y - line1_start.y));
    // lines are parallel
    if (denominator === 0) {
        return null;
    }
    // calc intersection
    var t1 = line1_start.y - line2_start.y;
    var t2 = line1_start.x - line2_start.x;
    var numerator1 = ((line2_end.x - line2_start.x) * t1) - ((line2_end.y - line2_start.y) * t2);
    var numerator2 = ((line1_end.x - line1_start.x) * t1) - ((line1_end.y - line1_start.y) * t2);
    t1 = numerator1 / denominator;
    t2 = numerator2 / denominator;
    // check intersection point is on both line segments
    if ((t1 <= 0) || (t1 > 1)) {
        return null;
    }
    if ((t2 <= 0) || (t2 > 1)) {
        return null;
    }
    // intersection point
    var result_x = line1_start.x + (t1 * (line1_end.x - line1_start.x));
    var result_y = line1_start.y + (t1 * (line1_end.y - line1_start.y));
    // return the result
    return { isect_point: new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](result_x, result_y, 0), t1: t1, t2: t2 };
}


/***/ }),

/***/ "./src/app/core/modules/libs/poly/polylinePipe.ts":
/*!********************************************************!*\
  !*** ./src/app/core/modules/libs/poly/polylinePipe.ts ***!
  \********************************************************/
/*! exports provided: pipe */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pipe", function() { return pipe; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _threex_threex__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../threex/threex */ "./src/app/core/modules/libs/threex/threex.ts");
var __read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (undefined && undefined.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __values = (undefined && undefined.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};


var EPS = 1e-6;
/**
 * Pipes a polylines.
 */
function pipe(pline, radius, segments) {
    var e_1, _a;
    var model = pline.getModel();
    // create the section
    var sec_vpts_xy = [new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](radius, 0, 0)];
    var rot_matrix = new three__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]().makeRotationZ((Math.PI * 2) / segments);
    for (var i = 1; i < segments; i++) {
        sec_vpts_xy.push(sec_vpts_xy[sec_vpts_xy.length - 1].clone().applyMatrix4(rot_matrix));
    }
    // Get the points
    var points_raw = pline.getPointsArr();
    var points = [];
    // check for zero dist points
    for (var i = 0; i < points_raw.length; i++) {
        var p1 = points_raw[i];
        var inext = i + 1;
        if (i === points_raw.length - 1) {
            inext = 0;
        }
        var p2 = points_raw[inext];
        if (_threex_threex__WEBPACK_IMPORTED_MODULE_1__["distManPointToPoint"](p1, p2) > EPS) {
            points.push(p1);
        } // TODO COuld be slow
    }
    // Add points for closed polylines
    if (pline.isClosed() && pline.numVertices() > 3) {
        points.push(points[0]);
        points.push(points[1]);
    }
    // Create vpoints
    var vpoints = points.map(function (p) {
        var _a;
        return new ((_a = three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]).bind.apply(_a, __spread([void 0], p.getPosition())))();
    });
    // Do all the other points first
    var start_x_vec = null;
    var end_x_vec = null;
    var prev_x_vec = null;
    var sec_pts_array = [];
    if (points.length > 2) {
        var _loop_1 = function (i) {
            // Get the points
            var prev = vpoints[i - 1];
            var curr = vpoints[i];
            var next = vpoints[i + 1];
            var vec_c_p = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]().subVectors(prev, curr).normalize();
            var vec_c_n = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]().subVectors(next, curr).normalize();
            var x_vec = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]().crossVectors(vec_c_p, vec_c_n);
            var y_vec = void 0;
            // get a valid x vector
            if (x_vec.length() > EPS) {
                prev_x_vec = x_vec;
                y_vec = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]().addVectors(vec_c_p, vec_c_n).multiplyScalar(0.5);
            }
            else {
                if (prev_x_vec !== null) {
                    x_vec = prev_x_vec;
                }
                else {
                    if (vec_c_n.y > EPS || vec_c_n.z > EPS) {
                        x_vec.crossVectors(vec_c_n, new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](1, 0, 0));
                    }
                    else {
                        x_vec.crossVectors(vec_c_n, new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](0, 1, 0));
                    }
                }
                y_vec = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]().crossVectors(vec_c_n, x_vec).normalize();
            }
            // calc the transform
            var matrix = _threex_threex__WEBPACK_IMPORTED_MODULE_1__["xformMatrixPos"](curr, x_vec, y_vec);
            var angle = vec_c_p.angleTo(vec_c_n);
            var scale = Math.cos(angle / 2);
            var matrix_scale = new three__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]().makeScale(1, 1 + scale, 1);
            matrix.multiply(matrix_scale); // first scale, then transform
            var xformed = sec_vpts_xy.map(function (p) { return p.clone().applyMatrix4(matrix); });
            var new_points = xformed.map(function (v) { return model.getGeom().addPoint([v.x, v.y, v.z]); });
            sec_pts_array.push(new_points);
            if (i === 1) {
                start_x_vec = x_vec;
            }
            if (i === points.length - 2) {
                end_x_vec = x_vec;
            }
        };
        // Loop through pline segments
        for (var i = 1; i < points.length - 1; i++) {
            _loop_1(i);
        }
    }
    // For open plines, calc start and end sections
    if (!pline.isClosed()) {
        // Do the first and last points for open polylines
        var start_end = [];
        var first = [vpoints[0], vpoints[1], start_x_vec];
        var extend = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]().subVectors(vpoints[vpoints.length - 1], vpoints[vpoints.length - 2]).add(vpoints[vpoints.length - 1]);
        var last = [vpoints[vpoints.length - 1], extend, end_x_vec];
        var _loop_2 = function (triple) {
            var z_vec = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]().subVectors(triple[1], triple[0]).normalize();
            var x_vec = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
            if (triple[2] !== null) {
                x_vec = triple[2];
            }
            else if (z_vec.y > EPS || z_vec.z > EPS) {
                x_vec.crossVectors(z_vec, new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](1, 0, 0));
            }
            else {
                x_vec.crossVectors(z_vec, new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](0, 1, 0));
            }
            var y_vec = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]().crossVectors(z_vec, x_vec);
            var matrix = _threex_threex__WEBPACK_IMPORTED_MODULE_1__["xformMatrixPos"](triple[0], x_vec, y_vec);
            var xformed = sec_vpts_xy.map(function (v) { return v.clone().applyMatrix4(matrix); });
            var new_points = xformed.map(function (v) { return model.getGeom().addPoint([v.x, v.y, v.z]); });
            start_end.push(new_points);
        };
        try {
            for (var _b = __values([first, last]), _c = _b.next(); !_c.done; _c = _b.next()) {
                var triple = _c.value;
                _loop_2(triple);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        sec_pts_array.unshift(start_end[0]);
        sec_pts_array.push(start_end[1]);
    }
    // Create the mesh points
    var mesh_points = [];
    for (var i = 0; i < sec_pts_array.length; i++) {
        var inext = i + 1;
        if (pline.isClosed() && inext === sec_pts_array.length) {
            inext = 0;
        }
        if (!pline.isClosed() && inext === sec_pts_array.length) {
            break;
        }
        for (var j = 0; j < segments; j++) {
            var jnext = j + 1;
            if (jnext === segments) {
                jnext = 0;
            }
            var v1 = sec_pts_array[i][j];
            var v2 = sec_pts_array[i][jnext];
            var v3 = sec_pts_array[inext][jnext];
            var v4 = sec_pts_array[inext][j];
            mesh_points.push([v1, v2, v3, v4]);
        }
    }
    // Create the mesh
    //console.log(mesh_points);
    return model.getGeom().addPolymesh(mesh_points);
}


/***/ }),

/***/ "./src/app/core/modules/libs/poly/polylinePlane.ts":
/*!*********************************************************!*\
  !*** ./src/app/core/modules/libs/poly/polylinePlane.ts ***!
  \*********************************************************/
/*! exports provided: splitPolylinePlane3D, isectPolylinePlane3D */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "splitPolylinePlane3D", function() { return splitPolylinePlane3D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isectPolylinePlane3D", function() { return isectPolylinePlane3D; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _threex_threex__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../threex/threex */ "./src/app/core/modules/libs/threex/threex.ts");
var __read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (undefined && undefined.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __values = (undefined && undefined.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};


var EPS = 1e-6;
/**
 * Split polylines with a plane.
 */
function splitPolylinePlane3D(pline, plane) {
    var _a, e_1, _b;
    var model = pline.getModel();
    var points = pline.getPointsArr();
    var origin = plane.getOrigin();
    var axes = plane.getAxes();
    // Add points for closed polylines
    if (pline.isClosed()) {
        points.push(points[0]);
    }
    // Create vpoints
    var vpoints = points.map(function (p) {
        var _a;
        return new ((_a = three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]).bind.apply(_a, __spread([void 0], p.getPosition())))();
    });
    var vaxes = axes.map(function (a) {
        var _a;
        return new ((_a = three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]).bind.apply(_a, __spread([void 0], a)))();
    });
    var vorigin = new ((_a = three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]).bind.apply(_a, __spread([void 0], origin.getPosition())))();
    // Create the matrixes to transform between 3d and 2d
    var matrix_neg = _threex_threex__WEBPACK_IMPORTED_MODULE_1__["xformMatrixNeg"](vorigin, vaxes[0], vaxes[1]);
    var matrix_pos = _threex_threex__WEBPACK_IMPORTED_MODULE_1__["xformMatrixPos"](vorigin, vaxes[0], vaxes[1]);
    try {
        // Project the polyline points
        for (var vpoints_1 = __values(vpoints), vpoints_1_1 = vpoints_1.next(); !vpoints_1_1.done; vpoints_1_1 = vpoints_1.next()) {
            var vpoint = vpoints_1_1.value;
            vpoint.applyMatrix4(matrix_neg);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (vpoints_1_1 && !vpoints_1_1.done && (_b = vpoints_1.return)) _b.call(vpoints_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    // Loop through each edge and check for intersections
    var pline_points_array = [];
    var pline_points = [];
    for (var i = 0; i < vpoints.length - 1; i++) {
        pline_points.push(points[i]);
        var line1_start = vpoints[i];
        var line1_end = vpoints[i + 1];
        var result = _isectLineXYPlane3D(line1_start, line1_end);
        if (result !== null) {
            var xyz = result.applyMatrix4(matrix_pos).toArray();
            var isect_point = model.getGeom().addPoint(xyz);
            pline_points.push(isect_point);
            pline_points_array.push(pline_points);
            pline_points = [isect_point];
        }
        if (i === vpoints.length - 2) {
            pline_points.push(points[i + 1]);
            pline_points_array.push(pline_points);
        }
    }
    if (pline_points_array.length === 1) {
        return null;
    }
    if (pline.isClosed() && pline_points_array.length > 2) {
        var first = pline_points_array[0];
        var last = pline_points_array.pop();
        last.push.apply(last, __spread(first));
        pline_points_array[0] = last;
    }
    return pline_points_array.map(function (pts) { return model.getGeom().addPolyline(pts, false); });
}
/**
 * Isect polylines with a plane.
 */
function isectPolylinePlane3D(pline, plane) {
    var _a, e_2, _b;
    var model = pline.getModel();
    var points = pline.getPointsArr();
    var origin = plane.getOrigin();
    var axes = plane.getAxes();
    // Add points for closed polylines
    if (pline.isClosed()) {
        points.push(points[0]);
    }
    // Create vpoints
    var vpoints = points.map(function (p) {
        var _a;
        return new ((_a = three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]).bind.apply(_a, __spread([void 0], p.getPosition())))();
    });
    var vaxes = axes.map(function (a) {
        var _a;
        return new ((_a = three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]).bind.apply(_a, __spread([void 0], a)))();
    });
    var vorigin = new ((_a = three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]).bind.apply(_a, __spread([void 0], origin.getPosition())))();
    // Create the matrixes to transform between 3d and 2d
    var matrix_neg = _threex_threex__WEBPACK_IMPORTED_MODULE_1__["xformMatrixNeg"](vorigin, vaxes[0], vaxes[1]);
    var matrix_pos = _threex_threex__WEBPACK_IMPORTED_MODULE_1__["xformMatrixPos"](vorigin, vaxes[0], vaxes[1]);
    try {
        // Project the polyline points
        for (var vpoints_2 = __values(vpoints), vpoints_2_1 = vpoints_2.next(); !vpoints_2_1.done; vpoints_2_1 = vpoints_2.next()) {
            var vpoint = vpoints_2_1.value;
            vpoint.applyMatrix4(matrix_neg);
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (vpoints_2_1 && !vpoints_2_1.done && (_b = vpoints_2.return)) _b.call(vpoints_2);
        }
        finally { if (e_2) throw e_2.error; }
    }
    // Loop through each edge and check for intersections
    var isect_points = [];
    for (var i = 0; i < vpoints.length - 1; i++) {
        var line1_start = vpoints[i];
        var line1_end = vpoints[i + 1];
        var result = _isectLineXYPlane3D(line1_start, line1_end);
        if (result !== null) {
            var xyz = result.applyMatrix4(matrix_pos).toArray();
            var isect_point = model.getGeom().addPoint(xyz);
            isect_points.push(isect_point);
        }
    }
    return isect_points;
}
/**
 * Intersect line with XY plane.
 */
function _isectLineXYPlane3D(line_start, line_end) {
    if (line_start.z === 0) {
        return line_start.clone();
    }
    if (line_end.z === 0) {
        return line_end.clone();
    }
    if ((line_start.z * line_end.z) > 0) {
        return null;
    }
    var start_z = Math.abs(line_start.z);
    var end_z = Math.abs(line_end.z);
    var scalar_z = start_z / (start_z + end_z);
    var line_vec = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]()
        .subVectors(line_end, line_start).multiplyScalar(scalar_z);
    return new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]().addVectors(line_start, line_vec);
}


/***/ }),

/***/ "./src/app/core/modules/libs/threex/threex.ts":
/*!****************************************************!*\
  !*** ./src/app/core/modules/libs/threex/threex.ts ***!
  \****************************************************/
/*! exports provided: multVectorMatrix, multXYZMatrix, xformMatrixNeg, xformMatrixPos, matrixInverse, xformMatrixFromXYZAxes, xformMatrixFromXYZVectors, orthoVectors, vectorNegate, vectorFromVertex, vectorFromPoint, vectorsFromVertices, vectorsFromPoints, subVectors, addVectors, crossVectors, dotVectors, vectorFromPointsAtoB, vectorFromVerticesAtoB, normalVectorFromPlanarVPoints, orthoVectorsFromPlanarVPoints, interpVPoints, subXYZs, addXYZs, crossXYZs, dotXYZs, normalizeXYZ, lengthXYZ, subPoints, addPoints, addPointXYZ, subPointXYZ, movePointsAddXYZ, distPointToPoint, distSquPointToPoint, distManPointToPoint, subVertices, addVertices, makeVertices2D, planesAreParallel, planesAreCoplanar, pointIsOnPlane, vectorsAreCodir */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multVectorMatrix", function() { return multVectorMatrix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multXYZMatrix", function() { return multXYZMatrix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "xformMatrixNeg", function() { return xformMatrixNeg; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "xformMatrixPos", function() { return xformMatrixPos; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "matrixInverse", function() { return matrixInverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "xformMatrixFromXYZAxes", function() { return xformMatrixFromXYZAxes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "xformMatrixFromXYZVectors", function() { return xformMatrixFromXYZVectors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "orthoVectors", function() { return orthoVectors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vectorNegate", function() { return vectorNegate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vectorFromVertex", function() { return vectorFromVertex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vectorFromPoint", function() { return vectorFromPoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vectorsFromVertices", function() { return vectorsFromVertices; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vectorsFromPoints", function() { return vectorsFromPoints; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subVectors", function() { return subVectors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addVectors", function() { return addVectors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "crossVectors", function() { return crossVectors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dotVectors", function() { return dotVectors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vectorFromPointsAtoB", function() { return vectorFromPointsAtoB; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vectorFromVerticesAtoB", function() { return vectorFromVerticesAtoB; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalVectorFromPlanarVPoints", function() { return normalVectorFromPlanarVPoints; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "orthoVectorsFromPlanarVPoints", function() { return orthoVectorsFromPlanarVPoints; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "interpVPoints", function() { return interpVPoints; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subXYZs", function() { return subXYZs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addXYZs", function() { return addXYZs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "crossXYZs", function() { return crossXYZs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dotXYZs", function() { return dotXYZs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalizeXYZ", function() { return normalizeXYZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lengthXYZ", function() { return lengthXYZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subPoints", function() { return subPoints; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addPoints", function() { return addPoints; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addPointXYZ", function() { return addPointXYZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subPointXYZ", function() { return subPointXYZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "movePointsAddXYZ", function() { return movePointsAddXYZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distPointToPoint", function() { return distPointToPoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distSquPointToPoint", function() { return distSquPointToPoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distManPointToPoint", function() { return distManPointToPoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subVertices", function() { return subVertices; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addVertices", function() { return addVertices; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeVertices2D", function() { return makeVertices2D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "planesAreParallel", function() { return planesAreParallel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "planesAreCoplanar", function() { return planesAreCoplanar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pointIsOnPlane", function() { return pointIsOnPlane; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vectorsAreCodir", function() { return vectorsAreCodir; });
/* harmony import */ var gs_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gs-json */ "./node_modules/gs-json/dist2015/index.js");
/* harmony import */ var gs_json__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(gs_json__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _arr_arr__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../arr/arr */ "./src/app/core/modules/libs/arr/arr.ts");
var __read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (undefined && undefined.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __values = (undefined && undefined.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};



/**
 * Utility functions for threejs.
 */
var EPS = 1e-6;
// Matrices ======================================================================================================
function multVectorMatrix(v, m) {
    var v2 = v.clone();
    v2.applyMatrix4(m);
    return v2;
}
function multXYZMatrix(xyz, m) {
    var _a;
    var v2 = new ((_a = three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]).bind.apply(_a, __spread([void 0], xyz)))();
    v2.applyMatrix4(m);
    return v2;
}
/*
 * Transforms from LCS to GCS. The LCS is defined by origin, x axis, y axis.
 */
function xformMatrixNeg(o, x, y) {
    var m1 = new three__WEBPACK_IMPORTED_MODULE_1__["Matrix4"]();
    var o_neg = o.clone().negate();
    m1.setPosition(o_neg);
    var m2 = new three__WEBPACK_IMPORTED_MODULE_1__["Matrix4"]();
    m2.makeBasis(x.normalize(), y.normalize(), crossVectors(x, y, true));
    m2.getInverse(m2);
    var m3 = new three__WEBPACK_IMPORTED_MODULE_1__["Matrix4"]();
    // first translate to (0,0,0), then xform, so m1 x m2
    m3.multiplyMatrices(m2, m1);
    return m3;
}
/*
 * Transforms from GCS to LCS.The LCS is defined by origin, x axis, y axis.
 */
function xformMatrixPos(o, x, y) {
    var m1 = new three__WEBPACK_IMPORTED_MODULE_1__["Matrix4"]();
    m1.setPosition(o);
    var m2 = new three__WEBPACK_IMPORTED_MODULE_1__["Matrix4"]();
    m2.makeBasis(x.normalize(), y.normalize(), crossVectors(x, y, true));
    var m3 = new three__WEBPACK_IMPORTED_MODULE_1__["Matrix4"]();
    // first xform, then translate to origin, so m1 x m2
    m3.multiplyMatrices(m1, m2);
    return m3;
}
// get the inverse of a matrix
function matrixInverse(m) {
    var m_inv = new three__WEBPACK_IMPORTED_MODULE_1__["Matrix4"]();
    return m_inv.getInverse(m);
}
function xformMatrixFromXYZAxes(o, axes, neg) {
    var _a, _b, _c, _d;
    var x_vec = new ((_a = three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]).bind.apply(_a, __spread([void 0], axes[0])))().normalize();
    var y_vec = new ((_b = three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]).bind.apply(_b, __spread([void 0], axes[1])))().normalize();
    if (neg) {
        return xformMatrixNeg(new ((_c = three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]).bind.apply(_c, __spread([void 0], o)))(), x_vec, y_vec);
    }
    return xformMatrixPos(new ((_d = three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]).bind.apply(_d, __spread([void 0], o)))(), x_vec, y_vec);
}
function xformMatrixFromXYZVectors(o, xaxis, xyplane, neg) {
    var _a, _b, _c, _d;
    var x_vec = new ((_a = three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]).bind.apply(_a, __spread([void 0], xaxis)))().normalize();
    var xyplane_vec = new ((_b = three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]).bind.apply(_b, __spread([void 0], xyplane)))().normalize();
    var z_vec = crossVectors(x_vec, xyplane_vec);
    var y_vec = crossVectors(z_vec, x_vec);
    if (neg) {
        return xformMatrixNeg(new ((_c = three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]).bind.apply(_c, __spread([void 0], o)))(), x_vec, y_vec);
    }
    return xformMatrixPos(new ((_d = three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]).bind.apply(_d, __spread([void 0], o)))(), x_vec, y_vec);
}
//  Vectors =======================================================================================================
/*
 * returns the y vector
 */
function orthoVectors(vec_x, vec) {
    return crossVectors(vec_x, vec).cross(vec_x);
}
function vectorNegate(vector) {
    return vector.clone().negate();
}
function vectorFromVertex(vertex) {
    var _a;
    return new ((_a = three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]).bind.apply(_a, __spread([void 0], vertex.getPoint().getPosition())))();
}
function vectorFromPoint(point) {
    var _a;
    return new ((_a = three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]).bind.apply(_a, __spread([void 0], point.getPosition())))();
}
function vectorsFromVertices(vertices) {
    return vertices.map(function (v) {
        var _a;
        return new ((_a = three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]).bind.apply(_a, __spread([void 0], v.getPoint().getPosition())))();
    });
}
function vectorsFromPoints(points) {
    return points.map(function (p) {
        var _a;
        return new ((_a = three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]).bind.apply(_a, __spread([void 0], p.getPosition())))();
    });
}
function subVectors(v1, v2, norm) {
    if (norm === void 0) { norm = false; }
    var v3 = new three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();
    v3.subVectors(v1, v2);
    if (norm) {
        v3.normalize();
    }
    return v3;
}
function addVectors(v1, v2, norm) {
    if (norm === void 0) { norm = false; }
    var v3 = new three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();
    v3.addVectors(v1, v2);
    if (norm) {
        v3.normalize();
    }
    return v3;
}
function crossVectors(v1, v2, norm) {
    if (norm === void 0) { norm = false; }
    var v3 = new three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();
    v3.crossVectors(v1, v2);
    if (norm) {
        v3.normalize();
    }
    return v3;
}
function dotVectors(v1, v2) {
    return v1.dot(v2);
}
function vectorFromPointsAtoB(a, b, norm) {
    if (norm === void 0) { norm = false; }
    var _a, _b;
    var v = subVectors(new ((_a = three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]).bind.apply(_a, __spread([void 0], b.getPosition())))(), new ((_b = three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]).bind.apply(_b, __spread([void 0], a.getPosition())))());
    if (norm) {
        v.normalize();
    }
    return v;
}
function vectorFromVerticesAtoB(a, b, norm) {
    if (norm === void 0) { norm = false; }
    var _a, _b;
    var v = subVectors(new ((_a = three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]).bind.apply(_a, __spread([void 0], b.getPoint().getPosition())))(), new ((_b = three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]).bind.apply(_b, __spread([void 0], a.getPoint().getPosition())))());
    if (norm) {
        v.normalize();
    }
    return v;
}
// /*
//  * Finds the two orthogonal vectors in a plane defined by a set of co-planar points.
//  */
// export function orthoVectorsFromXYZs(points: three.Vector3[]): [three.Vector3, three.Vector3] {
//     if (points.length < 3) {return null;}
//     if (points.length == 3) {
//         const vec_x: three.Vector3 = new three.Vector3().subVectors(points[1], points[0]).normalize();
//         const vec: three.Vector3 = new three.Vector3().subVectors(points[2], points[0]).normalize();
//         const vec_y: three.Vector3 = orthoVectors(vec_x, vec);
//         if (vec_y.length() < EPS) {return null;}
//         return [vec_x, vec_y];
//     }
//     const x_bbox: {min:three.Vector3, max:three.Vector3, dim:number} = {min:null, max:null, dim:null};
//     const y_bbox: {min:three.Vector3, max:three.Vector3, dim:number} = {min:null, max:null, dim:null};
//     const z_bbox: {min:three.Vector3, max:three.Vector3, dim:number} = {min:null, max:null, dim:null};
//     for (const point of points) {
//         // find min max of x
//         if ((x_bbox.min === null) || (point.x < x_bbox.min.x)) {
//             x_bbox.min = point;
//         }
//         if ((x_bbox.max === null) || (point.x > x_bbox.max.x)) {
//             x_bbox.max = point;
//         }
//         // find min max of y
//         if ((y_bbox.min === null) || (point.y < y_bbox.min.y)) {
//             y_bbox.min = point;
//         }
//         if ((y_bbox.max === null) || (point.y > y_bbox.max.y)) {
//             y_bbox.max = point;
//         }
//         // find min max of z
//         if ((z_bbox.min === null) || (point.z < z_bbox.min.z)) {
//             z_bbox.min = point;
//         }
//         if ((z_bbox.max === null) || (point.z > z_bbox.max.z)) {
//             z_bbox.max = point;
//         }
//     }
//     x_bbox.dim = Math.abs(x_bbox.max[0] - x_bbox.min[0]);
//     y_bbox.dim = Math.abs(y_bbox.max[1] - y_bbox.min[1]);
//     z_bbox.dim = Math.abs(z_bbox.max[2] - z_bbox.min[2]);
//     const sorted_bbox = [x_bbox, y_bbox, z_bbox].sort((n1,n2) => {
//         if (n1.dim > n2.dim) {return -1;}
//         return 1;
//     });
//     if (sorted_bbox[0].dim < EPS) {return null;}
//     if (sorted_bbox[1].dim < EPS) {return null;}
//     const p1: three.Vector3 = sorted_bbox[0].min;
//     const p2: three.Vector3 = sorted_bbox[0].max;
//     const p3: three.Vector3 = sorted_bbox[1].min;
//     const p4: three.Vector3 = sorted_bbox[1].max;
//     const vec_x: three.Vector3 = p2.sub(p1).normalize();
//     const vec: three.Vector3 = p4.sub(p3).normalize();
//     const vec_y: three.Vector3 = orthoVectors(vec_x, vec);
//     if (vec_y.length() < EPS) {return null;}
//     return [vec_x, vec_y];
// }
/*
 * Finds the normal using Newell's method
 */
function normalVectorFromPlanarVPoints(points) {
    var normal = new three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();
    for (var i = 0; i < points.length - 1; i++) {
        var point0 = points[i];
        var point1 = points[i + 1];
        normal.x += (point0.y - point1.y) * (point0.z + point1.z);
        normal.y += (point0.z - point1.z) * (point0.x + point1.x);
        normal.z += (point0.x - point1.x) * (point0.y + point1.y);
    }
    return normal.normalize();
}
/*
 * Finds the ortho vectors using Newell's method
 */
function orthoVectorsFromPlanarVPoints(points) {
    var normal = new three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();
    var max_vec_len = 0;
    var vec_x = null;
    for (var i = 0; i < points.length - 1; i++) {
        var point0 = points[i];
        var point1 = points[i + 1];
        var test_vec = new three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]().subVectors(point1, point0);
        if (test_vec.lengthSq() > max_vec_len) {
            vec_x = test_vec;
        }
        normal.x += (point0.y - point1.y) * (point0.z + point1.z);
        normal.y += (point0.z - point1.z) * (point0.x + point1.x);
        normal.z += (point0.x - point1.x) * (point0.y + point1.y);
    }
    normal.normalize();
    vec_x.normalize();
    var vec_y = new three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]().crossVectors(vec_x, normal);
    if (vec_y.length() < EPS) {
        return null;
    }
    return [vec_x, vec_y];
}
/**
 * Create new vpoints between two existing vpoints.
 */
function interpVPoints(pt1, pt2, num_points) {
    if (num_points < 1) {
        return [];
    }
    var vec = new three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]().subVectors(pt2, pt1);
    vec.divideScalar(num_points + 1);
    var points = [];
    var next = pt1;
    for (var i = 0; i < num_points; i++) {
        next = new three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]().addVectors(next, vec);
        points.push(next);
    }
    return points;
}
//  XYZ ===========================================================================================================
function subXYZs(xyz1, xyz2, norm) {
    if (norm === void 0) { norm = false; }
    var _a, _b;
    return subVectors(new ((_a = three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]).bind.apply(_a, __spread([void 0], xyz1)))(), new ((_b = three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]).bind.apply(_b, __spread([void 0], xyz2)))(), norm).toArray();
}
function addXYZs(xyz1, xyz2, norm) {
    if (norm === void 0) { norm = false; }
    var _a, _b;
    return addVectors(new ((_a = three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]).bind.apply(_a, __spread([void 0], xyz1)))(), new ((_b = three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]).bind.apply(_b, __spread([void 0], xyz2)))(), norm).toArray();
}
function crossXYZs(xyz1, xyz2, norm) {
    if (norm === void 0) { norm = false; }
    var _a, _b;
    return crossVectors(new ((_a = three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]).bind.apply(_a, __spread([void 0], xyz1)))(), new ((_b = three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]).bind.apply(_b, __spread([void 0], xyz2)))(), norm).toArray();
}
function dotXYZs(xyz1, xyz2) {
    var _a, _b;
    return new ((_a = three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]).bind.apply(_a, __spread([void 0], xyz1)))().dot(new ((_b = three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]).bind.apply(_b, __spread([void 0], xyz2)))());
}
function normalizeXYZ(xyz) {
    var _a;
    return new ((_a = three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]).bind.apply(_a, __spread([void 0], xyz)))().normalize().toArray();
}
function lengthXYZ(xyz) {
    var _a;
    return new ((_a = three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]).bind.apply(_a, __spread([void 0], xyz)))().length();
}
//  Points ========================================================================================================
function subPoints(p1, p2, norm) {
    if (norm === void 0) { norm = false; }
    var _a, _b;
    return subVectors(new ((_a = three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]).bind.apply(_a, __spread([void 0], p1.getPosition())))(), new ((_b = three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]).bind.apply(_b, __spread([void 0], p2.getPosition())))(), norm).toArray();
}
function addPoints(p1, p2, norm) {
    if (norm === void 0) { norm = false; }
    var _a, _b;
    return addVectors(new ((_a = three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]).bind.apply(_a, __spread([void 0], p1.getPosition())))(), new ((_b = three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]).bind.apply(_b, __spread([void 0], p2.getPosition())))(), norm).toArray();
}
function addPointXYZ(p1, xyz_vec) {
    var _a, _b;
    return (new ((_a = three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]).bind.apply(_a, __spread([void 0], p1.getPosition())))().add(new ((_b = three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]).bind.apply(_b, __spread([void 0], xyz_vec)))())).toArray();
}
function subPointXYZ(p1, xyz_vec) {
    var _a, _b;
    return (new ((_a = three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]).bind.apply(_a, __spread([void 0], p1.getPosition())))().sub(new ((_b = three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]).bind.apply(_b, __spread([void 0], xyz_vec)))())).toArray();
}
function movePointsAddXYZ(points, xyz_vec) {
    var _a, e_1, _b, e_2, _c, _d;
    var vec = new ((_a = three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]).bind.apply(_a, __spread([void 0], xyz_vec)))();
    var points_flat = _arr_arr__WEBPACK_IMPORTED_MODULE_2__["Arr"].flatten(points);
    var point_ids = [];
    var points_no_dups = [];
    try {
        for (var points_flat_1 = __values(points_flat), points_flat_1_1 = points_flat_1.next(); !points_flat_1_1.done; points_flat_1_1 = points_flat_1.next()) {
            var point = points_flat_1_1.value;
            if (point_ids.indexOf(point.getID()) === -1) {
                points_no_dups.push(point);
                point_ids.push(point.getID());
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (points_flat_1_1 && !points_flat_1_1.done && (_b = points_flat_1.return)) _b.call(points_flat_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    try {
        for (var points_no_dups_1 = __values(points_no_dups), points_no_dups_1_1 = points_no_dups_1.next(); !points_no_dups_1_1.done; points_no_dups_1_1 = points_no_dups_1.next()) {
            var point = points_no_dups_1_1.value;
            var xyz_point = (new ((_d = three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]).bind.apply(_d, __spread([void 0], point.getPosition())))().add(vec)).toArray();
            point.setPosition(xyz_point);
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (points_no_dups_1_1 && !points_no_dups_1_1.done && (_c = points_no_dups_1.return)) _c.call(points_no_dups_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
}
function distPointToPoint(p1, p2) {
    var _a, _b;
    return (new ((_a = three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]).bind.apply(_a, __spread([void 0], p1.getPosition())))()).distanceTo(new ((_b = three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]).bind.apply(_b, __spread([void 0], p2.getPosition())))());
}
function distSquPointToPoint(p1, p2) {
    var _a, _b;
    return (new ((_a = three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]).bind.apply(_a, __spread([void 0], p1.getPosition())))()).distanceToSquared(new ((_b = three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]).bind.apply(_b, __spread([void 0], p2.getPosition())))());
}
function distManPointToPoint(p1, p2) {
    var _a, _b;
    return (new ((_a = three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]).bind.apply(_a, __spread([void 0], p1.getPosition())))()).manhattanDistanceTo(new ((_b = three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]).bind.apply(_b, __spread([void 0], p2.getPosition())))());
}
//  Vertices ======================================================================================================
function subVertices(v1, v2, norm) {
    if (norm === void 0) { norm = false; }
    var _a, _b;
    return subVectors(new ((_a = three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]).bind.apply(_a, __spread([void 0], v1.getPoint().getPosition())))(), new ((_b = three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]).bind.apply(_b, __spread([void 0], v2.getPoint().getPosition())))(), norm).toArray();
}
function addVertices(v1, v2, norm) {
    if (norm === void 0) { norm = false; }
    var _a, _b;
    return addVectors(new ((_a = three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]).bind.apply(_a, __spread([void 0], v1.getPoint().getPosition())))(), new ((_b = three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]).bind.apply(_b, __spread([void 0], v2.getPoint().getPosition())))(), norm).toArray();
}
//  3D to 2D ======================================================================================================
/**
 * Transform a set of vertices in 3d space onto the xy plane. This function assumes that the vertices
 * are co-planar. Returns a set of three Vectors that represent points on the xy plane.
 */
function makeVertices2D(vertices) {
    var e_3, _a;
    var points = vectorsFromVertices(vertices);
    var o = new three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();
    try {
        for (var points_1 = __values(points), points_1_1 = points_1.next(); !points_1_1.done; points_1_1 = points_1.next()) {
            var v = points_1_1.value;
            o.add(v);
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (points_1_1 && !points_1_1.done && (_a = points_1.return)) _a.call(points_1);
        }
        finally { if (e_3) throw e_3.error; }
    }
    o.divideScalar(points.length);
    var vx;
    var vz;
    var got_vx = false;
    for (var i = 0; i < vertices.length; i++) {
        if (!got_vx) {
            vx = subVectors(points[i], o).normalize();
            if (vx.lengthSq() !== 0) {
                got_vx = true;
            }
        }
        else {
            vz = crossVectors(vx, subVectors(points[i], o).normalize()).normalize();
            if (vz.lengthSq() !== 0) {
                break;
            }
        }
        if (i === vertices.length - 1) {
            throw new Error("Trinagulation found bad face.");
        }
    }
    var vy = crossVectors(vz, vx);
    var m = xformMatrixNeg(o, vx, vy);
    // const m: three.Matrix4 = xformMatrix(o, vx, vy, vz);
    var points_2d = points.map(function (v) { return multVectorMatrix(v, m); });
    // console.log(o, vx, vy, vz);
    // console.log(points_2d);
    return points_2d;
}
//  Query ======================================================================================================
/**
 * Check planes are parallel.
 * The plane is represented by an origin and a normal.
 */
function planesAreParallel(normal1, normal2) {
    var _a, _b;
    // args
    var normal1_v;
    if (Array.isArray(normal1)) {
        normal1_v = new ((_a = three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]).bind.apply(_a, __spread([void 0], normal1)))();
    }
    else {
        normal1_v = normal1;
    }
    normal1_v.normalize();
    var normal2_v;
    if (Array.isArray(normal2)) {
        normal2_v = new ((_b = three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]).bind.apply(_b, __spread([void 0], normal2)))();
    }
    else {
        normal2_v = normal2;
    }
    normal2_v.normalize();
    // check is vectors are same
    if (Math.abs(1 - normal1_v.dot(normal2_v)) > EPS) {
        return false;
    }
    return true;
}
/**
 * Check a point is on a plane.
 * The plane is represented by an origin and a normal.
 */
function planesAreCoplanar(origin1, normal1, origin2, normal2) {
    var _a, _b, _c, _d;
    // args
    var origin1_v;
    if (origin1 instanceof gs_json__WEBPACK_IMPORTED_MODULE_0__["Point"]) {
        origin1_v = new ((_a = three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]).bind.apply(_a, __spread([void 0], origin1.getPosition())))();
    }
    else {
        origin1_v = origin1;
    }
    var normal1_v;
    if (Array.isArray(normal1)) {
        normal1_v = new ((_b = three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]).bind.apply(_b, __spread([void 0], normal1)))();
    }
    else {
        normal1_v = normal1;
    }
    normal1_v.normalize();
    var origin2_v;
    if (origin2 instanceof gs_json__WEBPACK_IMPORTED_MODULE_0__["Point"]) {
        origin2_v = new ((_c = three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]).bind.apply(_c, __spread([void 0], origin2.getPosition())))();
    }
    else {
        origin2_v = origin2;
    }
    var normal2_v;
    if (Array.isArray(normal2)) {
        normal2_v = new ((_d = three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]).bind.apply(_d, __spread([void 0], normal2)))();
    }
    else {
        normal2_v = normal2;
    }
    normal2_v.normalize();
    // Check if point is on plane
    if (Math.abs(dotVectors(subVectors(origin1_v, origin2_v), normal2_v)) > EPS) {
        return false;
    }
    // check is vectors are same
    if (Math.abs(1 - normal1_v.dot(normal2_v)) > EPS) {
        return false;
    }
    return true;
}
/**
 * Check a point is on a plane.
 * The plane is represented by an origin and a normal.
 */
function pointIsOnPlane(origin, normal, point) {
    var _a, _b, _c;
    var origin_v = new ((_a = three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]).bind.apply(_a, __spread([void 0], origin.getPosition())))();
    var normal_v = new ((_b = three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]).bind.apply(_b, __spread([void 0], normal)))().normalize();
    var point_v = new ((_c = three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]).bind.apply(_c, __spread([void 0], point.getPosition())))();
    if (dotVectors(subVectors(point_v, origin_v), normal_v) === 0) {
        return true;
    }
    return false;
}
/**
 * Check if vectors are same dir.
 */
function vectorsAreCodir(xyz1, xyz2) {
    var _a, _b;
    // Check if point is on plane
    var v1 = new ((_a = three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]).bind.apply(_a, __spread([void 0], xyz1)))().normalize();
    var v2 = new ((_b = three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]).bind.apply(_b, __spread([void 0], xyz2)))().normalize();
    if (Math.abs(1 - v1.dot(v2)) > EPS) {
        return false;
    }
    return true;
}


/***/ }),

/***/ "./src/app/core/modules/list.ts":
/*!**************************************!*\
  !*** ./src/app/core/modules/list.ts ***!
  \**************************************/
/*! exports provided: Copy, FromRange, len, append, appendFront, extend, extendFront, flatten, removeIndex, removeValue, reverse, sortAlpha, sortNum, slice, splice */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Copy", function() { return Copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FromRange", function() { return FromRange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "append", function() { return append; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "appendFront", function() { return appendFront; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extendFront", function() { return extendFront; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "flatten", function() { return flatten; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeIndex", function() { return removeIndex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeValue", function() { return removeValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reverse", function() { return reverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sortAlpha", function() { return sortAlpha; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sortNum", function() { return sortNum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slice", function() { return slice; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "splice", function() { return splice; });
/* harmony import */ var _libs_arr_arr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libs/arr/arr */ "./src/app/core/modules/libs/arr/arr.ts");
/**
 * The <i>List</i> module provides a set of functions for working with lists.
 * Lists are containers that can hold other values. The values inside the list are called <i>items</i>.<br/>
 *
 * The items in a list can be of any data type.
 * The items can also be other lists, thereby allowing more complex nested data strictures to be created.
 * Items are ordered and will be returned in the same order or accessed by the same index unless
 * changes are made to alter it.<br/>
 *
 * When instantiating a list, use square brackets as follows: <code>[10,20,30]</code>.<br/>
 *
 * To refer to an item in a list, use index notation as follows: <code>list_name[index_num]</code>.
 */
var __read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (undefined && undefined.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};

//  ===============================================================================================================
//  List Constructors =============================================================================================
//  ===============================================================================================================
/**
 * Creates a new list by making a copy of an existing list.
 *
 * @param list List to copy.
 * @returns New duplicated list.
 *
 * <h3>Example:</h3>
 * <code>
 * list = [1,2,3]<br/>
 * copy = List.Copy(list)</code><br/><br/>
 * Expected value of copy is [1,2,3].
 */
function Copy(list) {
    if (list === undefined) {
        throw new Error("Invalid arg: list must be defined.");
    }
    return list.slice();
}
/**
 * Creates a new list of integer numbers between two bounds.
 * Lower bound is inclusive and upper bound is exclusive.
 *
 * @param min Lower bound integer.
 * @param max Upper bound integer.
 * @returns New list.
 *
 * <h3>Example: </h3>
 * <code>
 * list = List.FromRange(0,5)</code><br/><br/>
 * Expected value of list is [0,1,2,3,4].
 */
function FromRange(min, max) {
    if (min === undefined) {
        throw new Error("Invalid arg: min must be defined.");
    }
    if (max === undefined) {
        throw new Error("Invalid arg: max must be defined.");
    }
    return _libs_arr_arr__WEBPACK_IMPORTED_MODULE_0__["Arr"].makeSeq(max - min).map(function (v) { return v + min; });
}
//  ===============================================================================================================
//  List Functions ================================================================================================
//  ===============================================================================================================
/**
 * Returns the number of items in an list.
 *
 * @param list List.
 * @returns Length of the list.
 *
 * <h3>Example: </h3>
 * <code>
 * list = [1,2,3]<br/>
 * len = List.len(list)</code><br/><br/>
 * Expected value of len is 3.
 */
function len(list) {
    if (list === undefined) {
        throw new Error("Invalid arg: list must be defined.");
    }
    return list.length;
}
/**
 * Adds an item to the end of a list.
 * If item is a list, the entire list will be appended as one item.
 *
 * @param list List to add to.
 * @param item Item to add.
 * @returns New list with added item.
 *
 * <h3>Example: </h3>
 * <code>
 * list = [1,2,3]<br/>
 * append = List.append(list,4)</code><br/><br/>
 * Expected value of list is [1,2,3,4].
 */
function append(list, item) {
    if (list === undefined) {
        throw new Error("Invalid arg: list must be defined.");
    }
    if (item === undefined) {
        throw new Error("Invalid arg: item must be defined.");
    }
    var list2 = list.slice();
    list2.push(item);
    return list2;
}
/**
 * Adds an item to the front of a list.
 * If the item is a list, the entire list will be appended as one item.
 *
 * @param list List to add to.
 * @param item Item to add.
 * @returns New list with added item.
 *
 * <h3>Example: </h3>
 * <code>
 * list = [1,2,3]<br/>
 * append = List.appendFront(list,4)</code><br/><br/>
 * Expected value of list is [4,1,2,3].
 */
function appendFront(list, item) {
    if (list === undefined) {
        throw new Error("Invalid arg: list must be defined.");
    }
    if (item === undefined) {
        throw new Error("Invalid arg: item must be defined.");
    }
    var list2 = list.slice();
    list2.unshift(item);
    return list2;
}
/**
 * Adds items (from a list) to the end of an list.
 * Items are added to list individually as seperate items.
 *
 * @param list List to add to.
 * @param items List of items to add.
 * @returns List with added items.
 *
 * <h3>Example: </h3>
 * <code>
 * list = [1,2,3]<br/>
 * list2 = [9,0]<br/>
 * extend = List.extend(list,list2)</code><br/><br/>
 * Expected value of extend is [1,2,3,9,0].
 */
function extend(list, items) {
    if (list === undefined) {
        throw new Error("Invalid arg: list must be defined.");
    }
    if (items === undefined) {
        throw new Error("Invalid arg: items must be defined.");
    }
    return list.concat(items);
}
/**
 * Adds items (from a list) to the front of an list.
 * Items are added to list individually as seperate items.
 *
 * @param list List to add to.
 * @param items List of items to add.
 * @returns List with added items.
 *
 * <h3>Example: </h3>
 * <code>
 * list = [1,2,3]<br/>
 * list2 = [9,0]<br/>
 * extend = List.extend(list,list2)</code><br/><br/>
 * Expected value of extend is [9,0,1,2,3].
 */
function extendFront(list, items) {
    if (list === undefined) {
        throw new Error("Invalid arg: list must be defined.");
    }
    if (items === undefined) {
        throw new Error("Invalid arg: items must be defined.");
    }
    return items.concat(list);
}
/**
 * Flattens an n-dimensional list into a one-dimensional list.
 *
 * @param list List to flatten.
 * @returns Flattened list.
 *
 * <h3>Example: </h3>
 * <code>
 * list = [1,2,3,[4,5]]<br/>
 * flatten = List.flatten(list)</code><br/><br/>
 * Expected value of list is [1,2,3,4,5].
 */
function flatten(list) {
    if (list === undefined) {
        throw new Error("Invalid arg: list must be defined.");
    }
    return _libs_arr_arr__WEBPACK_IMPORTED_MODULE_0__["Arr"].flatten(list);
}
/**
 * Removes the item at the specified index from a list.
 *
 * @param list List to remove item from.
 * @param index Zero-based index number of item to remove.
 * @returns List with item removed.
 *
 * <h3>Example: </h3>
 * <code>
 * list = [1,2,3]<br/>
 * remove = List.removeIndex(list,1)</code><br/><br/>
 * Expected value of list is [1,3].
 */
function removeIndex(list, index) {
    if (list === undefined) {
        throw new Error("Invalid arg: list must be defined.");
    }
    if (index === undefined) {
        throw new Error("Invalid arg: index must be defined.");
    }
    var list2 = list.slice();
    list2.splice(index, 1);
    return list2;
}
/**
 * Removes items that match specified value from a list.
 * Items must match both the value and type of specified value<br/>
 *
 * Returns original list if no items in list match specified value.
 *
 * @param list List to remove item from.
 * @param value Value to search for.
 * @param remove_all Removes all instances of specified value if true, removes only the first instance if
 *      false.
 * @returns List with item removed
 *
 * <h3>Example: </h3>
 * <code>
 * list = [1,2,2,3]<br/>
 * remove = List.removeValue(list,2,true)</code><br/><br/>
 * Expected value of list is [1,3].
 */
function removeValue(list, value, remove_all) {
    if (remove_all === void 0) { remove_all = true; }
    if (list === undefined) {
        throw new Error("Invalid arg: list must be defined.");
    }
    if (value === undefined) {
        throw new Error("Invalid arg: value must be defined.");
    }
    var list2 = list.slice();
    for (var i = list2.length - 1; i >= 0; i--) {
        if (list2[i] === value) {
            list2.splice(i, 1);
            if (remove_all === false) {
                break;
            }
        }
    }
    return list2;
}
/**
 * Reverses the order of items in an list.
 *
 * @param list List to reverse.
 * @returns New reversed list.
 *
 * <h3>Example: </h3>
 * <code>
 * list = [1,2,3]<br/>
 * result = List.reverse(list)</code><br/><br/>
 * Expected value of result is [3,2,1].
 */
function reverse(list) {
    if (list === undefined) {
        throw new Error("Invalid arg: list must be defined.");
    }
    var list2 = list.slice();
    list2.reverse();
    return list2;
}
/**
 * Sorts a list of strings alphabetically.
 * If items are not strings, they are treated as strings.<br/>
 *
 * Items are sorted according to string Unicode code points (character by character, numbers before upper case
 * alphabets, upper case alphabets before lower case alphabets)
 *
 * @param list List to sort.
 * @returns New sorted list.
 *
 * <h3>Example: </h3>
 * <code>
 * list = ["1","2","10","Orange","apple"]<br/>
 * sort = List.sortAlpha(list)</code><br/><br/>
 * Expected value of list is ["1","10","2","Orange","apple"].
 */
function sortAlpha(list) {
    if (list === undefined) {
        throw new Error("Invalid arg: list must be defined.");
    }
    var list2 = list.slice();
    list2.sort();
    return list2;
}
/**
 * Sorts a list of numbers in ascending order.
 * The list must contain numbers.
 *
 * @param list List to add to.
 * @returns New sorted list.
 *
 * <h3>Example: </h3>
 * <code>
 * list = [56,6,48]<br/>
 * sort = List.sortNum(list)</code><br/><br/>
 * Expected value of list is [6,48,56].
 */
function sortNum(list) {
    if (list === undefined) {
        throw new Error("Invalid arg: list must be defined.");
    }
    var list2 = list.slice();
    list2.sort(function (a, b) { return a - b; });
    return list2;
}
/**
 * Creates a copy of a portion of a list, from start index to end index (end not included).
 *
 * @param list List to slice.
 * @param start Zero-based index at which to begin slicing.
 *      A negative index can be used, indicating an offset from the end of the sequence.
 *      If start is undefined, slice begins from index 0.
 * @param end Zero-based index before which to end slicing. Slice extracts up to but not including end.
 *      A negative index can be used, indicating an offset from the end of the sequence.
 *      If end is undefined, slice extracts through the end of the sequence.
 * @returns A new list.
 *
 * <h3>Example: </h3>
 * <code>
 * list = [1,2,3,4,5]<br/>
 * result = List.slice(list,1,3)</code><br/><br/>
 * Expected value of result is [2,3].
 */
function slice(list, start, end) {
    if (list === undefined) {
        throw new Error("Invalid arg: list must be defined.");
    }
    if (start === undefined) {
        throw new Error("Invalid arg: start must be defined.");
    }
    if (end === undefined) {
        throw new Error("Invalid arg: end must be defined.");
    }
    var list2 = list.slice();
    return list2.slice(start, end);
}
/**
 * Adds and/or removes items to/from a list.
 *
 * If no items_to_add are specified, then items are only removed.
 * If num_to_remove is 0, then items are only added.<br/>
 *
 * @param list List to splice
 * @param index Zero-based index at which to add/remove items. (Items are added/removed after specified index)
 * @param num_to_remove Number of items to remove.
 * @param items_to_add List of items to add.
 * @returns A new list.
 *
 * <h3>Example: </h3>
 * <code>
 * list = [10, 20, 30, 40, 50]<br/>
 * result = List.splice(list, 1, 3, [2.2, 3.3])</code><br/><br/>
 * Expected value of result is [10, 2.2, 3.2, 50].
 */
function splice(list, index, num_to_remove, items_to_add) {
    if (list === undefined) {
        throw new Error("Invalid arg: list must be defined.");
    }
    if (index === undefined) {
        throw new Error("Invalid arg: index must be defined.");
    }
    var list2 = list.slice();
    list2.splice.apply(list2, __spread([index, num_to_remove], items_to_add));
    return list2;
}


/***/ }),

/***/ "./src/app/core/modules/math.ts":
/*!**************************************!*\
  !*** ./src/app/core/modules/math.ts ***!
  \**************************************/
/*! exports provided: PI, POS_INF, NEG_INF, cos, acos, sin, asin, tan, atan, pow, ceiling, floor, abs, max, min, rand, randInt, randFloat */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PI", function() { return PI; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "POS_INF", function() { return POS_INF; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NEG_INF", function() { return NEG_INF; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cos", function() { return cos; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "acos", function() { return acos; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sin", function() { return sin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "asin", function() { return asin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tan", function() { return tan; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "atan", function() { return atan; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pow", function() { return pow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ceiling", function() { return ceiling; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floor", function() { return floor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "abs", function() { return abs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "max", function() { return max; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "min", function() { return min; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rand", function() { return rand; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "randInt", function() { return randInt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "randFloat", function() { return randFloat; });
/**
 * The <i>Math</i> module provides commonly used mathematical functions.
 * It also provides functions that return a number of constants such as PI and positive and negative infinity.
 */
var __values = (undefined && undefined.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/PI
/**
 * Returns the value of PI.
 * @returns Value of pi
 */
function PI() {
    return Math.PI;
}
/**
 * Returns the value of positive infinity
 * @returns Value of positive infinity
 */
function POS_INF() {
    return Number.POSITIVE_INFINITY;
}
/**
 * Returns the value of negative infinity
 * @returns Value of negative infinity
 */
function NEG_INF() {
    return Number.NEGATIVE_INFINITY;
}
//  ===============================================================================================================
//  Math Methods ==================================================================================================
//  ===============================================================================================================
/**
 * Returns the cosine of a specified angle in degrees.
 *
 * @param angle Angle in degrees.
 * @returns Cosine of angle.
 */
function cos(angle) {
    if (angle === undefined) {
        throw new Error("Invalid arg: angle must be defined.");
    }
    return Math.cos(angle * (Math.PI / 180));
}
/**
 * Returns the arc cosine (or inverse cosine) of a specified number, converted to degrees.
 *
 * @param num Number.
 * @returns Angle, the arc cosine of num converted to degrees.
 */
function acos(num) {
    if (num === undefined) {
        throw new Error("Invalid arg: num must be defined.");
    }
    return Math.acos(num) * (180 / Math.PI);
}
/**
 * Returns the sine of a specified angle in degrees.
 *
 * @param angle Angle in degrees.
 * @returns Sine of angle.
 */
function sin(angle) {
    if (angle === undefined) {
        throw new Error("Invalid arg: angle must be defined.");
    }
    return Math.sin(angle * (Math.PI / 180));
}
/**
 * Returns the arc sine (or inverse sine) of a specified number, converted to degrees.
 *
 * @param num Number.
 * @returns Angle, the arc cosine of num converted to degrees.
 */
function asin(num) {
    if (num === undefined) {
        throw new Error("Invalid arg: num must be defined.");
    }
    return Math.asin(num) * (180 / Math.PI);
}
/**
 * Returns the tangent of a specified angle in degrees.
 *
 * @param angle Angle in degrees.
 * @returns Tangent of angle.
 */
function tan(angle) {
    if (angle === undefined) {
        throw new Error("Invalid arg: angle must be defined.");
    }
    return Math.tan(angle * (Math.PI / 180));
}
/**
 * Returns the arc tangent (or inverse tangent) of a specified number, converted to degrees.
 *
 * @param num Number.
 * @returns Angle, the arc tangent of num converted to degrees.
 */
function atan(num) {
    if (num === undefined) {
        throw new Error("Invalid arg: num must be defined.");
    }
    return Math.atan(num) * (180 / Math.PI);
}
/**
 * Returns a number representing the given base taken to the power of the given exponent.
 *
 * @param base Base number.
 * @param exponent Power of exponent.
 * @returns Number representing the given base taken to the power of the given exponent.
 *
 * <h3>Example:</h3>
 * <code>
 * num = Math.pow(2,3)</code><br/><br/>
 * Expected value of num is 8.
 */
function pow(base, exponent) {
    if (base === undefined) {
        throw new Error("Invalid arg: base must be defined.");
    }
    if (exponent === undefined) {
        throw new Error("Invalid arg: exponent must be defined.");
    }
    return Math.pow(base, exponent);
}
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/ceil
/**
 * Rounds a number up to the nearest integer.
 *
 * @param num Number.
 * @returns A number representing the smallest integer more than or equal to the specified number.
 *
 * <h3>Example:</h3>
 * <code>
 * num = Math.ceiling(4.3)</code><br/><br/>
 * Expected value of num is 5.
 */
function ceiling(num) {
    if (num === undefined) {
        throw new Error("Invalid arg: num must be defined.");
    }
    return Math.ceil(num);
}
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/floor
/**
 * Rounds a number down to the nearest integer.
 *
 * @param num Number.
 * @returns A number representing the largest integer less than or equal to the specified number.
 *
 * <h3>Example:</h3>
 * <code>
 * num = Math.floor(4.3)</code><br/><br/>
 * Expected value of num is 4.
 */
function floor(num) {
    if (num === undefined) {
        throw new Error("Invalid arg: num must be defined.");
    }
    return Math.floor(num);
}
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/abs
/**
 * Returns the absolute value of a number.
 *
 * Returns num if num is positive, -num if num is negative and 0 if num=0<br/>
 *
 * @param num Number.
 * @returns A number representing the absolute value of the specified number.
 *
 * <h3>Example:</h3>
 * <code>
 * num1 = Math.abs(-1.234)
 * num2 = Math.abs(2.345)<br/>
 * </code><br/><br/>
 * Expected value of num1 is 1.234, and of num2 is 2.345.
 */
function abs(num) {
    if (num === undefined) {
        throw new Error("Invalid arg: num must be defined.");
    }
    return Math.abs(num);
}
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/max
/**
 * Returns the largest number in a list of numbers.
 *
 * @param nums List of numbers.
 * @returns A number representing the largest number in specified list of numbers.
 *
 * <h3>Example:</h3>
 * <code>
 * list = [8,9,6,1,3]<br/>
 * num = Math.max(list)</code><br/><br/>
 * Expected value of num is 9.
 */
function max(nums) {
    var e_1, _a;
    if (nums === undefined) {
        throw new Error("Invalid arg: nums must be defined.");
    }
    var maximum = Number.NEGATIVE_INFINITY;
    try {
        for (var nums_1 = __values(nums), nums_1_1 = nums_1.next(); !nums_1_1.done; nums_1_1 = nums_1.next()) {
            var num = nums_1_1.value;
            if (num > maximum) {
                maximum = num;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (nums_1_1 && !nums_1_1.done && (_a = nums_1.return)) _a.call(nums_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return maximum;
}
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/min
/**
 * Returns the smallest number in a list of numbers.
 *
 * @param num List of numbers.
 * @returns A number representing the smallest number in specified list of numbers.
 *
 * <h3>Example:</h3>
 * <code>
 * list = [8,9,6,1,3]<br/>
 * num = Math.max(list)</code><br/><br/>
 * Expected value of num is 1.
 */
function min(nums) {
    var e_2, _a;
    if (nums === undefined) {
        throw new Error("Invalid arg: nums must be defined.");
    }
    var minimum = Number.POSITIVE_INFINITY;
    try {
        for (var nums_2 = __values(nums), nums_2_1 = nums_2.next(); !nums_2_1.done; nums_2_1 = nums_2.next()) {
            var num = nums_2_1.value;
            if (num < minimum) {
                minimum = num;
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (nums_2_1 && !nums_2_1.done && (_a = nums_2.return)) _a.call(nums_2);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return minimum;
}
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random
/**
 * Returns a pseudo-random number between 0 (inclusive) and 1 (exclusive).
 *
 * @returns A pseudo-random number.
 */
function rand() {
    return Math.random();
}
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random
/**
 * Returns a pseudo-random integer number between two numbers.
 *
 * Lower bound number is inclusive and upper bound number is exclusive.
 * @param min Lower bound of range.
 * @param max Upper bound of range.
 * @returns A pseudo-random integer number.
 */
function randInt(min, max) {
    if (min === undefined) {
        throw new Error("Invalid arg: min must be defined.");
    }
    if (max === undefined) {
        throw new Error("Invalid arg: max must be defined.");
    }
    var lower = Math.ceil(min);
    var upper = Math.floor(max);
    return Math.floor(Math.random() * (upper - lower)) + lower;
}
/**
 * Returns a pseudo-random floating point number between two numbers.
 *
 * @param min Lower bound of range.
 * @param max Upper bound of range.
 * @returns A pseudo-random floating point number.
 */
function randFloat(min, max) {
    if (min === undefined) {
        throw new Error("Invalid arg: min must be defined.");
    }
    if (max === undefined) {
        throw new Error("Invalid arg: max must be defined.");
    }
    return (Math.random() * (max - min)) + min;
}


/***/ }),

/***/ "./src/app/core/modules/model.ts":
/*!***************************************!*\
  !*** ./src/app/core/modules/model.ts ***!
  \***************************************/
/*! exports provided: New, FromData, merge, exportObj */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "New", function() { return New; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FromData", function() { return FromData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "merge", function() { return merge; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exportObj", function() { return exportObj; });
/* harmony import */ var gs_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gs-json */ "./node_modules/gs-json/dist2015/index.js");
/* harmony import */ var gs_json__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(gs_json__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _libs_filesys_download__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./libs/filesys/download */ "./src/app/core/modules/libs/filesys/download.ts");
/**
 * Functions for working with models.
 * Models are datastructures that contain geometric entities with attributes,
 * possibly organised into groups.
 */
/**
 * Models can contain two types of geometric entities: points and objects.
 * The objects are further sudivided into different types, e.g. polylines, polymeshes, circle, etc.
 */


//  ===============================================================================================================
//  Model Constructors ===========================================================================================
//  ===============================================================================================================
/**
 * Creates a new empty model.
 *
 * @returns New model empty.
 */
function New() {
    return new gs_json__WEBPACK_IMPORTED_MODULE_0__["Model"]();
}
//  ===============================================================================================================
//  Model Functions ============================================================================================
//  ===============================================================================================================
/**
 * Creates a new model and populates the model with data.
 *
 * @param model_data The model data in gs-json format.
 * @returns New model if successful, null if unsuccessful or on error.
 */
function FromData(model_data) {
    if (typeof model_data == 'string') {
        return new gs_json__WEBPACK_IMPORTED_MODULE_0__["Model"](JSON.parse(model_data));
    }
    else {
        return new gs_json__WEBPACK_IMPORTED_MODULE_0__["Model"](model_data);
    }
}
/**
 * Merges the second model into the first model. The geometry, attribues, and groups are all merged.
 * If the models contain contain groups with the same names, then the groups will be merged.
 *
 * @param model1 The model to merge into.
 * @param model2 The model to merge.
 * @returns The merged model.
 */
function merge(model1, model2) {
    model1.merge(model2);
    return model1;
}
/**
 * Export model as obj file. Only pline and pmeshes will be exported.
 *
 * @param model The model to export.
 * @param filepath The path to the obj file.
 * @returns True if successful.
 */
function exportObj(model, filename) {
    return _libs_filesys_download__WEBPACK_IMPORTED_MODULE_1__["save"](gs_json__WEBPACK_IMPORTED_MODULE_0__["exportObj"](model), filename);
}


/***/ }),

/***/ "./src/app/core/modules/object.ts":
/*!****************************************!*\
  !*** ./src/app/core/modules/object.ts ***!
  \****************************************/
/*! exports provided: Get, Gets, GetFromGroup, move, rotate, scale, xformGcs2Lcs, xformLcs2Gcs, xformLcs2Lcs, mirror, del, unweld, addToGroup, removeFromGroup */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Get", function() { return Get; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Gets", function() { return Gets; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GetFromGroup", function() { return GetFromGroup; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "move", function() { return move; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "xformGcs2Lcs", function() { return xformGcs2Lcs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "xformLcs2Gcs", function() { return xformLcs2Gcs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "xformLcs2Lcs", function() { return xformLcs2Lcs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mirror", function() { return mirror; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "del", function() { return del; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unweld", function() { return unweld; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addToGroup", function() { return addToGroup; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeFromGroup", function() { return removeFromGroup; });
/* harmony import */ var gs_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gs-json */ "./node_modules/gs-json/dist2015/index.js");
/* harmony import */ var gs_json__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(gs_json__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _error_msgs_dev__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_error_msgs_dev */ "./src/app/core/modules/_error_msgs_dev.ts");
/* harmony import */ var _libs_threex_threex__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./libs/threex/threex */ "./src/app/core/modules/libs/threex/threex.ts");
/**
 * Objects are a type of entity. They consist of conics, polylines, polymeshes, planes and rays.
 *
 * Objects are formed by a combination of topologies. More information can be found on the page for topo.
 */
var __values = (undefined && undefined.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (undefined && undefined.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};




//  ===============================================================================================================
//  Object Get ====================================================================================================
//  ===============================================================================================================
/**
 * Gets an object from the model
 * @param model Model to get object from
 * @param id ID of object to get
 * @returns An object. Null if object does not exist.
 */
function Get(model, id) {
    var obj = _error_msgs_dev__WEBPACK_IMPORTED_MODULE_2__["checkObjID"](model, id);
    switch (obj.getObjType()) {
        case 1 /* ray */:
            return obj;
        case 2 /* plane */:
            return obj;
        case 3 /* circle */:
            return obj;
        case 4 /* ellipse */:
            return obj;
        case 100 /* polyline */:
            return obj;
        case 200 /* polymesh */:
            return obj;
        default:
            throw new Error("Object type not found: " + obj.getObjType());
    }
}
/**
 * Gets a list of objects from the model.
 * @param model Model to get objects from.
 * @param ids A point ID or list of point IDs, integer numbers. If null, then all objects are returned.
 * @returns A list of objects.
 */
function Gets(model, ids) {
    var e_1, _a;
    if (ids === undefined || ids === null) {
        return model.getGeom().getAllObjs();
    }
    if (!Array.isArray(ids)) {
        ids = [ids];
    }
    var objs = [];
    try {
        for (var ids_1 = __values(ids), ids_1_1 = ids_1.next(); !ids_1_1.done; ids_1_1 = ids_1.next()) {
            var id = ids_1_1.value;
            var obj = Get(model, id);
            if (obj !== null) {
                objs.push(obj);
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (ids_1_1 && !ids_1_1.done && (_a = ids_1.return)) _a.call(ids_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return objs;
}
/**
 * Gets all the objects from a group.
 * @param model Model to get the objects from.
 * @param group_name The group name.
 * @returns List of objects.
 */
function GetFromGroup(model, group_name) {
    var group = _error_msgs_dev__WEBPACK_IMPORTED_MODULE_2__["checkGroup"](model, group_name);
    return group.getObjs();
}
//  ===============================================================================================================
//  Object Constructors ===========================================================================================
//  ===============================================================================================================
//  ===============================================================================================================
//  Object Functions ==============================================================================================
//  ===============================================================================================================
/**
 * Moves objects by a translation vector.
 *
 * @param objs An object or a list of objects.
 * @param vector Translation vector.
 * @param copy If true, objects are copied before being moved.
 * @returns The moved objects.
 */
function move(objs, vector, copy) {
    if (copy === void 0) { copy = false; }
    var is_array = Array.isArray(objs);
    if (!Array.isArray(objs)) {
        objs = [objs];
    }
    var model = _error_msgs_dev__WEBPACK_IMPORTED_MODULE_2__["checkObjList"](objs, 1);
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_2__["checkXYZ"](vector);
    // translation matrix
    var matrix_trn = new three__WEBPACK_IMPORTED_MODULE_1__["Matrix4"]();
    matrix_trn.makeTranslation(vector[0], vector[1], vector[2]);
    // copy the objs
    if (copy) {
        objs = model.getGeom().copyObjs(objs, true);
    }
    // do the xform
    model.getGeom().xformObjs(objs, matrix_trn);
    // return either a single obj or array of objs
    if (is_array) {
        return objs;
    }
    return objs[0];
}
/**
 * Rotates object or a list of objects around an axis.
 *
 * @param objs An object or a list of objects.
 * @param origin An point on the axis, can be either a list of three numbers or a point.
 * @param axis An xyz vector along the axis.
 * @param angle The angle, in degrees, between 0 and 360.
 * @param copy If true, objects are copied before being rotated.
 * @returns The rotated objects.
 */
function rotate(objs, origin, axis, angle, copy) {
    if (copy === void 0) { copy = false; }
    var _a;
    var is_array = Array.isArray(objs);
    if (!Array.isArray(objs)) {
        objs = [objs];
    }
    var model = _error_msgs_dev__WEBPACK_IMPORTED_MODULE_2__["checkObjList"](objs, 1);
    var origin_xyz;
    if (origin instanceof gs_json__WEBPACK_IMPORTED_MODULE_0__["Point"]) {
        origin_xyz = origin.getPosition();
    }
    else {
        origin_xyz = origin;
        _error_msgs_dev__WEBPACK_IMPORTED_MODULE_2__["checkXYZ"](origin_xyz);
    }
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_2__["checkXYZ"](axis);
    var angle_rad = (angle / 180) * Math.PI;
    // rotation matrix
    var matrix_rot = new three__WEBPACK_IMPORTED_MODULE_1__["Matrix4"]();
    matrix_rot.makeRotationAxis(new ((_a = three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]).bind.apply(_a, __spread([void 0], axis)))(), angle_rad);
    // translation matrix
    var matrix_trn1 = new three__WEBPACK_IMPORTED_MODULE_1__["Matrix4"]();
    matrix_trn1.makeTranslation(-origin_xyz[0], -origin_xyz[1], -origin_xyz[2]);
    var matrix_trn2 = new three__WEBPACK_IMPORTED_MODULE_1__["Matrix4"]();
    matrix_trn2.makeTranslation(origin_xyz[0], origin_xyz[1], origin_xyz[2]);
    // copy objects
    if (copy) {
        objs = model.getGeom().copyObjs(objs, true);
    }
    // do the xform
    model.getGeom().xformObjs(objs, matrix_trn2.multiply(matrix_rot.multiply(matrix_trn1)));
    // return the result, either single obj or array
    if (is_array) {
        return objs;
    }
    return objs[0];
}
/**
 * Scales an object or a list of objects relative to an origin point.
 * The scale factor is specified by three vales, for scaling in x, y, and z.
 * Primitive objects, such as circles and arcs, can only be scaled uniformly.
 *
 * @param objs An object or a list of objects.
 * @param origin An origin point of the scale, can be either a list of three numbers or a point.
 * @param factor The scale factor, along the x, y and z axes.
 * @param copy If true, objects are copied before being scaled.
 * @returns The scaled objects.
 */
function scale(objs, origin, factor, copy) {
    if (copy === void 0) { copy = false; }
    var is_array = Array.isArray(objs);
    if (!Array.isArray(objs)) {
        objs = [objs];
    }
    var model = _error_msgs_dev__WEBPACK_IMPORTED_MODULE_2__["checkObjList"](objs, 1);
    var origin_xyz;
    if (origin instanceof gs_json__WEBPACK_IMPORTED_MODULE_0__["Point"]) {
        origin_xyz = origin.getPosition();
    }
    else {
        origin_xyz = origin;
        _error_msgs_dev__WEBPACK_IMPORTED_MODULE_2__["checkXYZ"](origin_xyz);
    }
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_2__["checkXYZ"](factor);
    // scale matrix
    var matrix_scale = new three__WEBPACK_IMPORTED_MODULE_1__["Matrix4"]();
    matrix_scale.makeScale(factor[0], factor[1], factor[2]);
    // translation matrix
    var matrix_trn1 = new three__WEBPACK_IMPORTED_MODULE_1__["Matrix4"]();
    matrix_trn1.makeTranslation(-origin_xyz[0], -origin_xyz[1], -origin_xyz[2]);
    var matrix_trn2 = new three__WEBPACK_IMPORTED_MODULE_1__["Matrix4"]();
    matrix_trn2.makeTranslation(origin_xyz[0], origin_xyz[1], origin_xyz[2]);
    // copy objects
    if (copy) {
        objs = model.getGeom().copyObjs(objs, true);
    }
    // do the xform
    model.getGeom().xformObjs(objs, matrix_trn2.multiply(matrix_scale.multiply(matrix_trn1)));
    // return the result, either single obj or array
    if (is_array) {
        return objs;
    }
    return objs[0];
}
/**
 * Transforms an object or list of objects to a target coordinate system (CS).
 * The source CS is assumed to be the Global Coordinate System (GCS).
 * The target coordinate system is specified by an origin,
 * a vector parallel to the x axis, and a vector in the xy plane (not parallel to the x axis).
 *
 * @param objs An object or a list of objects.
 * @param target_origin The origin point of the target coordinate system, can be either a list of three numbers or a point.
 * @param target_vec_x A vector parallel to the target x axis.
 * @param target_vec A vector in the target xy plane (not paralle to the x axis).
 * @param copy If true, objects are copied before being scaled.
 * @returns The transformed objects.
 */
function xformGcs2Lcs(objs, target_origin, target_vec_x, target_vec, copy) {
    if (copy === void 0) { copy = false; }
    var is_array = Array.isArray(objs);
    if (!Array.isArray(objs)) {
        objs = [objs];
    }
    var model = _error_msgs_dev__WEBPACK_IMPORTED_MODULE_2__["checkObjList"](objs, 1);
    var target_origin_xyz;
    if (target_origin instanceof gs_json__WEBPACK_IMPORTED_MODULE_0__["Point"]) {
        target_origin_xyz = target_origin.getPosition();
    }
    else {
        target_origin_xyz = target_origin;
        _error_msgs_dev__WEBPACK_IMPORTED_MODULE_2__["checkXYZ"](target_origin_xyz);
    }
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_2__["checkXYZ"](target_vec_x);
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_2__["checkXYZ"](target_vec);
    // matrix to xform from source to gcs, then from gcs to target
    var matrix_gcs_to_target = _libs_threex_threex__WEBPACK_IMPORTED_MODULE_3__["xformMatrixFromXYZVectors"](target_origin_xyz, target_vec_x, target_vec, false);
    // copy objects
    if (copy) {
        objs = model.getGeom().copyObjs(objs, true);
    }
    // do the xform
    model.getGeom().xformObjs(objs, matrix_gcs_to_target);
    // return the result, either single obj or array
    if (is_array) {
        return objs;
    }
    return objs[0];
}
/**
 * Transforms an object or list of objects from a source local coordinate system (LCS)
 * to the global coordinate system (GCS).
 * The source coordinate system is specified by an origin,
 * a vector parallel to the x axis, and a vector in the xy plane (not parallel to the x axis).
 *
 * @param objs An object or a list of objects.
 * @param source_origin The origin point of the source coordinate system, can be either a list of three numbers or a point.
 * @param source_vec_x A vector parallel to the source x axis.
 * @param source_vec A vector in the source xy plane (not paralle to the x axis).
 * @param copy If true, objects are copied before being scaled.
 * @returns The transformed objects.
 */
function xformLcs2Gcs(objs, source_origin, source_vec_x, source_vec, copy) {
    if (copy === void 0) { copy = false; }
    var is_array = Array.isArray(objs);
    if (!Array.isArray(objs)) {
        objs = [objs];
    }
    var model = _error_msgs_dev__WEBPACK_IMPORTED_MODULE_2__["checkObjList"](objs, 1);
    var source_origin_xyz;
    if (source_origin instanceof gs_json__WEBPACK_IMPORTED_MODULE_0__["Point"]) {
        source_origin_xyz = source_origin.getPosition();
    }
    else {
        source_origin_xyz = source_origin;
        _error_msgs_dev__WEBPACK_IMPORTED_MODULE_2__["checkXYZ"](source_origin_xyz);
    }
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_2__["checkXYZ"](source_vec_x);
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_2__["checkXYZ"](source_vec);
    // matrix to xform from source to gcs, then from gcs to target
    var matrix_source_to_gcs = _libs_threex_threex__WEBPACK_IMPORTED_MODULE_3__["xformMatrixFromXYZVectors"](source_origin_xyz, source_vec_x, source_vec, true);
    // copy objects
    if (copy) {
        objs = model.getGeom().copyObjs(objs, true);
    }
    // do the xform
    model.getGeom().xformObjs(objs, matrix_source_to_gcs);
    // return the result, either single obj or array
    if (is_array) {
        return objs;
    }
    return objs[0];
}
/**
 * Transforms an object or list of objects from a source to a target local coordinate system (LCS).
 * Each coordinate system is specified by an origin,
 * a vector parallel to the x axis, and a vector in the xy plane (not parallel to the x axis).
 *
 * @param objs An object or a list of objects.
 * @param source_origin The origin point of the source coordinate system, can be either a list of three numbers or a point.
 * @param source_vec_x A vector parallel to the source x axis.
 * @param source_vec A vector in the source xy plane (not paralle to the x axis).
 * @param target_origin The origin point of the target coordinate system, can be either a list of three numbers or a point.
 * @param target_vec_x A vector parallel to the target x axis.
 * @param target_vec A vector in the target xy plane (not paralle to the x axis).
 * @param copy If true, objects are copied before being scaled.
 * @returns The transformed objects.
 */
function xformLcs2Lcs(objs, source_origin, source_vec_x, source_vec, target_origin, target_vec_x, target_vec, copy) {
    if (copy === void 0) { copy = false; }
    var is_array = Array.isArray(objs);
    if (!Array.isArray(objs)) {
        objs = [objs];
    }
    var model = _error_msgs_dev__WEBPACK_IMPORTED_MODULE_2__["checkObjList"](objs, 1);
    var source_origin_xyz;
    if (source_origin instanceof gs_json__WEBPACK_IMPORTED_MODULE_0__["Point"]) {
        source_origin_xyz = source_origin.getPosition();
    }
    else {
        source_origin_xyz = source_origin;
        _error_msgs_dev__WEBPACK_IMPORTED_MODULE_2__["checkXYZ"](source_origin_xyz);
    }
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_2__["checkXYZ"](source_vec_x);
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_2__["checkXYZ"](source_vec);
    var target_origin_xyz;
    if (target_origin instanceof gs_json__WEBPACK_IMPORTED_MODULE_0__["Point"]) {
        target_origin_xyz = target_origin.getPosition();
    }
    else {
        target_origin_xyz = target_origin;
        _error_msgs_dev__WEBPACK_IMPORTED_MODULE_2__["checkXYZ"](target_origin_xyz);
    }
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_2__["checkXYZ"](target_vec_x);
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_2__["checkXYZ"](target_vec);
    // matrix to xform from source to gcs, then from gcs to target
    var matrix_source_to_gcs = _libs_threex_threex__WEBPACK_IMPORTED_MODULE_3__["xformMatrixFromXYZVectors"](source_origin_xyz, source_vec_x, source_vec, true);
    var matrix_gcs_to_target = _libs_threex_threex__WEBPACK_IMPORTED_MODULE_3__["xformMatrixFromXYZVectors"](target_origin_xyz, target_vec_x, target_vec, false);
    // copy objects
    if (copy) {
        objs = model.getGeom().copyObjs(objs, true);
    }
    // do the xform
    model.getGeom().xformObjs(objs, matrix_gcs_to_target.multiply(matrix_source_to_gcs));
    // return the result, either single obj or array
    if (is_array) {
        return objs;
    }
    return objs[0];
}
/**
 * Mirrors an object or a list of objects in a mirror plane.
 * The plane is defined by a point and a normal vector.
 *
 * @param objs An object or a list of objects.
 * @param origin An origin point on the mirror plane, can be either a list of three numbers or a point.
 * @param normal The normal vector of the mirror plane, a list of three numbers.
 * @param copy If true, objects are copied before being scaled.
 * @returns The scaled objects.
 */
function mirror(objs, origin, normal, copy) {
    if (copy === void 0) { copy = false; }
    var _a;
    var is_array = Array.isArray(objs);
    if (!Array.isArray(objs)) {
        objs = [objs];
    }
    var model = _error_msgs_dev__WEBPACK_IMPORTED_MODULE_2__["checkObjList"](objs, 1);
    var origin_xyz;
    if (origin instanceof gs_json__WEBPACK_IMPORTED_MODULE_0__["Point"]) {
        origin_xyz = origin.getPosition();
    }
    else {
        origin_xyz = origin;
        _error_msgs_dev__WEBPACK_IMPORTED_MODULE_2__["checkXYZ"](origin_xyz);
    }
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_2__["checkXYZ"](normal);
    // plane normal
    var _b = __read(new ((_a = three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]).bind.apply(_a, __spread([void 0], normal)))().normalize().toArray(), 3), a = _b[0], b = _b[1], c = _b[2];
    // mirror matrix
    var matrix_mirror = new three__WEBPACK_IMPORTED_MODULE_1__["Matrix4"]();
    matrix_mirror.set(1 - (2 * a * a), -2 * a * b, -2 * a * c, 0, -2 * a * b, 1 - (2 * b * b), -2 * b * c, 0, -2 * a * c, -2 * b * c, 1 - (2 * c * c), 0, 0, 0, 0, 1);
    // translation matrix
    var matrix_trn1 = new three__WEBPACK_IMPORTED_MODULE_1__["Matrix4"]();
    matrix_trn1.makeTranslation(-origin_xyz[0], -origin_xyz[1], -origin_xyz[2]);
    var matrix_trn2 = new three__WEBPACK_IMPORTED_MODULE_1__["Matrix4"]();
    matrix_trn2.makeTranslation(origin_xyz[0], origin_xyz[1], origin_xyz[2]);
    // copy objects
    if (copy) {
        objs = model.getGeom().copyObjs(objs, true);
    }
    // do the xform
    model.getGeom().xformObjs(objs, matrix_trn2.multiply(matrix_mirror.multiply(matrix_trn1)));
    // return the result, either single obj or array
    if (is_array) {
        return objs;
    }
    return objs[0];
}
/**
 * Deletes object or a list of objects from the model.
 *
 * @param objs Object or list of objects to delete.
 * @param keep_points If false, points that are not used in any other objects will be deleted.
 * @returns True if all objects we successfully deleted.
 */
function del(objs, keep_points) {
    if (keep_points === void 0) { keep_points = false; }
    var e_2, _a;
    if (!Array.isArray(objs)) {
        objs = [objs];
    }
    var model = _error_msgs_dev__WEBPACK_IMPORTED_MODULE_2__["checkObjList"](objs, 1);
    var ok = true;
    try {
        for (var objs_1 = __values(objs), objs_1_1 = objs_1.next(); !objs_1_1.done; objs_1_1 = objs_1.next()) {
            var obj = objs_1_1.value;
            if (!model.getGeom().delObj(obj, keep_points)) {
                ok = false;
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (objs_1_1 && !objs_1_1.done && (_a = objs_1.return)) _a.call(objs_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return ok;
}
/**
 * Unwelds objects, so that thier vertices no longer share any points.
 *
 * @param objs Object or list of objects to unweld.
 * @returns A list of new points generated by the unwelding process.
 */
function unweld(objs) {
    if (!Array.isArray(objs)) {
        objs = [objs];
    }
    var model = _error_msgs_dev__WEBPACK_IMPORTED_MODULE_2__["checkObjList"](objs, 1);
    return model.getGeom().unweldObjs(objs);
}
//  ===============================================================================================================
//  Groups ==============================================================================================
//  ===============================================================================================================
/**
 * Add objects to a group.
 *
 * @param group Name of group to add to.
 * @param objs List of objects to add.
 * @returns True if all objects we successfully added.
 */
function addToGroup(objs, group_name) {
    var e_3, _a;
    if (!Array.isArray(objs)) {
        objs = [objs];
    }
    var model = _error_msgs_dev__WEBPACK_IMPORTED_MODULE_2__["checkObjList"](objs, 1);
    var group = _error_msgs_dev__WEBPACK_IMPORTED_MODULE_2__["checkGroup"](model, group_name);
    var ok = true;
    try {
        for (var objs_2 = __values(objs), objs_2_1 = objs_2.next(); !objs_2_1.done; objs_2_1 = objs_2.next()) {
            var obj = objs_2_1.value;
            if (!group.addObj(obj)) {
                ok = false;
            }
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (objs_2_1 && !objs_2_1.done && (_a = objs_2.return)) _a.call(objs_2);
        }
        finally { if (e_3) throw e_3.error; }
    }
    return ok;
}
/**
 * Remove object from a group.
 *
 * @param group Name of group to add to.
 * @param objs List of object to remove.
 * @returns True if all objects we successfully removed.
 */
function removeFromGroup(objs, group_name) {
    var e_4, _a;
    if (!Array.isArray(objs)) {
        objs = [objs];
    }
    var model = _error_msgs_dev__WEBPACK_IMPORTED_MODULE_2__["checkObjList"](objs, 1);
    var group = _error_msgs_dev__WEBPACK_IMPORTED_MODULE_2__["checkGroup"](model, group_name);
    var ok = true;
    try {
        for (var objs_3 = __values(objs), objs_3_1 = objs_3.next(); !objs_3_1.done; objs_3_1 = objs_3.next()) {
            var obj = objs_3_1.value;
            if (!group.removeObj(obj)) {
                ok = false;
            }
        }
    }
    catch (e_4_1) { e_4 = { error: e_4_1 }; }
    finally {
        try {
            if (objs_3_1 && !objs_3_1.done && (_a = objs_3.return)) _a.call(objs_3);
        }
        finally { if (e_4) throw e_4.error; }
    }
    return ok;
}


/***/ }),

/***/ "./src/app/core/modules/output.ts":
/*!****************************************!*\
  !*** ./src/app/core/modules/output.ts ***!
  \****************************************/
/*! exports provided: Output */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Output", function() { return Output; });
var Output;
(function (Output) {
    function return_value(__model__, index) {
        if (index > __model__.length)
            return __model__;
        return __model__[index].value;
    }
    Output.return_value = return_value;
})(Output || (Output = {}));


/***/ }),

/***/ "./src/app/core/modules/plane.ts":
/*!***************************************!*\
  !*** ./src/app/core/modules/plane.ts ***!
  \***************************************/
/*! exports provided: Get, Copy, CopyToModel, FromOriginVectors, FromOriginXY, FromOriginYZ, FromOriginZX, FromOriginPoints, FromCircle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Get", function() { return Get; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Copy", function() { return Copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CopyToModel", function() { return CopyToModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FromOriginVectors", function() { return FromOriginVectors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FromOriginXY", function() { return FromOriginXY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FromOriginYZ", function() { return FromOriginYZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FromOriginZX", function() { return FromOriginZX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FromOriginPoints", function() { return FromOriginPoints; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FromCircle", function() { return FromCircle; });
/* harmony import */ var _libs_threex_threex__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libs/threex/threex */ "./src/app/core/modules/libs/threex/threex.ts");
/* harmony import */ var _error_msgs_dev__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_error_msgs_dev */ "./src/app/core/modules/_error_msgs_dev.ts");
/**
 * Function for working with planes.
 */


//  ===============================================================================================================
//  Plane Get =====================================================================================================
//  ===============================================================================================================
/**
 * Gets a plane from the model based on an ID number.
 * In the viewer, the object label can display (it starts with 'o'), which contains the ID.
 * For example, if the label is "o123", then the ID is the number 123.
 *
 * @param model Model to get plane from.
 * @param id ID number of plane.
 * @returns The plane object.
 */
function Get(model, id) {
    var obj = _error_msgs_dev__WEBPACK_IMPORTED_MODULE_1__["checkObjID"](model, id, 2 /* plane */);
    return obj;
}
/**
 * Create a copy of an existing plane.
 *
 * @param plane The plane object to copy.
 * @param copy_attribs If true, attributes are copied to the new plane.
 * @returns A new plane object.
 */
function Copy(plane, copy_attribs) {
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_1__["checkObj"](plane, 2 /* plane */);
    return plane.copy(copy_attribs);
}
/**
 * Copies a plane from one model into another model.
 *
 * @param model The model to copy to.
 * @param plane The plane object to copy.
 * @returns The copied plane object in the model.
 */
function CopyToModel(model, plane) {
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_1__["checkObj"](plane, 2 /* plane */);
    if (plane.getModel() === model) {
        throw new Error("Error: plane is already in model.");
    }
    return model.getGeom().copyPlaneFromModel(plane);
}
//  ===============================================================================================================
//  Plane Constructors ============================================================================================
//  ===============================================================================================================
/**
 * Creates a plane object from an origin point and two vectors.
 *
 * @param origin Point object, the origin of plane.
 * @param vec_x XYZ vector, the x-axis of plane.
 * @param vec XYZ vector, a vector in the plane. (This vector must not be co-dir with vec_x.)
 * @returns New plane object.
 */
function FromOriginVectors(origin, vec_x, vec) {
    var model = _error_msgs_dev__WEBPACK_IMPORTED_MODULE_1__["checkPoint"](origin);
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_1__["checkXYZ"](vec_x);
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_1__["checkXYZ"](vec);
    return model.getGeom().addPlane(origin, vec_x, vec);
}
/**
 * Creates a plane object from an origin point, parallel to the WCS XY plane .
 *
 * @param origin Point object, the origin of plane.
 * @returns New plane object.
 */
function FromOriginXY(origin) {
    var model = _error_msgs_dev__WEBPACK_IMPORTED_MODULE_1__["checkPoint"](origin);
    return model.getGeom().addPlane(origin, [1, 0, 0], [0, 1, 0]);
}
/**
 * Creates a plane object from an origin point, parallel to the WCS YZ plane .
 *
 * @param origin Point object, the origin of plane.
 * @returns New plane object.
 */
function FromOriginYZ(origin) {
    var model = _error_msgs_dev__WEBPACK_IMPORTED_MODULE_1__["checkPoint"](origin);
    return model.getGeom().addPlane(origin, [0, 1, 0], [0, 0, 1]);
}
/**
 * Creates a plane object from an origin point, parallel to the WCS ZX plane .
 *
 * @param origin Point object, the origin of plane.
 * @returns New plane object.
 */
function FromOriginZX(origin) {
    var model = _error_msgs_dev__WEBPACK_IMPORTED_MODULE_1__["checkPoint"](origin);
    return model.getGeom().addPlane(origin, [0, 0, 1], [1, 0, 0]);
}
/**
 * Creates a plane from an origin point and two other points on the plane.
 *
 * @param origin Point object, the origin of plane.
 * @param point1 Point object, a point on the plane. This will be used to define the plane X axis.
 * @param point2 Point object, a point on the plane.
 * @returns New plane object.
 */
function FromOriginPoints(origin, point1, point2) {
    var model = _error_msgs_dev__WEBPACK_IMPORTED_MODULE_1__["checkPoint"](origin);
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_1__["checkPoint"](point1);
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_1__["checkPoint"](point2);
    if (point1.getModel() !== model) {
        throw new Error("Points need to be in the same model");
    }
    if (point2.getModel() !== model) {
        throw new Error("Points need to be in the same model");
    }
    // create the plane
    var vec_x = _libs_threex_threex__WEBPACK_IMPORTED_MODULE_0__["vectorFromPointsAtoB"](origin, point1).toArray();
    var vec = _libs_threex_threex__WEBPACK_IMPORTED_MODULE_0__["vectorFromPointsAtoB"](origin, point2).toArray();
    var plane = model.getGeom().addPlane(origin, vec_x, vec);
    // return the new plane
    return plane;
}
/**
 * Creates a plane from a circle. The plane will have the same origin and orientation as the circle.
 *
 * @param circle The circle to create a plane from.
 * @returns New plane object.
 */
function FromCircle(circle) {
    var model = _error_msgs_dev__WEBPACK_IMPORTED_MODULE_1__["checkObj"](circle, 3 /* circle */);
    var vectors = circle.getAxes();
    return model.getGeom().addPlane(circle.getOrigin(), vectors[0], vectors[1]);
}
//  ===============================================================================================================
//  Plane Functions ===============================================================================================
//  ===============================================================================================================


/***/ }),

/***/ "./src/app/core/modules/pline.ts":
/*!***************************************!*\
  !*** ./src/app/core/modules/pline.ts ***!
  \***************************************/
/*! exports provided: Get, Copy, CopyToModel, FromPoints, FromCircle, From2Points, isClosed, setIsClosed, numEdges, numVertices, getPoints, getEndPoints, evalParam, divideMaxLength, divide, join, explode, extract, extrude, loft, pipe */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Get", function() { return Get; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Copy", function() { return Copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CopyToModel", function() { return CopyToModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FromPoints", function() { return FromPoints; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FromCircle", function() { return FromCircle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "From2Points", function() { return From2Points; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isClosed", function() { return isClosed; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setIsClosed", function() { return setIsClosed; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "numEdges", function() { return numEdges; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "numVertices", function() { return numVertices; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPoints", function() { return getPoints; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getEndPoints", function() { return getEndPoints; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "evalParam", function() { return evalParam; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divideMaxLength", function() { return divideMaxLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divide", function() { return divide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "join", function() { return join; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "explode", function() { return explode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extract", function() { return extract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extrude", function() { return extrude; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loft", function() { return loft; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pipe", function() { return pipe; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _libs_threex_threex__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./libs/threex/threex */ "./src/app/core/modules/libs/threex/threex.ts");
/* harmony import */ var _libs_poly_poly__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./libs/poly/poly */ "./src/app/core/modules/libs/poly/poly.ts");
/* harmony import */ var _libs_poly_polylinePipe__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./libs/poly/polylinePipe */ "./src/app/core/modules/libs/poly/polylinePipe.ts");
/* harmony import */ var _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_error_msgs_dev */ "./src/app/core/modules/_error_msgs_dev.ts");
/* harmony import */ var _libs_arr_arr__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./libs/arr/arr */ "./src/app/core/modules/libs/arr/arr.ts");
/**
 * Functions for working with polylines.
 */
var __read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (undefined && undefined.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __values = (undefined && undefined.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};






//  ===============================================================================================================
//  Pline Get and Copy ============================================================================================
//  ===============================================================================================================
/**
 * Gets a polyline from the model based on an ID number.
 * In the viewer, the object label can display (it starts with 'o'), which contains the ID.
 * For example, if the label is "o123", then the ID is the number 123.
 *
 * @param model Model to get polyline object from.
 * @param id ID number of polyline object.
 * @returns Polyline object.
 */
function Get(model, id) {
    var obj = _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkObjID"](model, id, 100 /* polyline */);
    return obj;
}
/**
 * Create a copy of a polyline.
 *
 * @param polyline The polyline to copy.
 * @param copy_attribs If true, attributes are copied to the new circle.
 * @returns Polyline object.
 */
function Copy(polyline, copy_attribs) {
    if (copy_attribs === void 0) { copy_attribs = true; }
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkObj"](polyline, 100 /* polyline */);
    return polyline.copy(copy_attribs);
}
/**
 * Copies a polyline from one model into another model.
 *
 * @param model The model to copy to.
 * @param polyline The polyline object to copy.
 * @returns The copied polyline object in the model.
 */
function CopyToModel(model, polyline) {
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkObj"](polyline, 100 /* polyline */);
    if (polyline.getModel() === model) {
        throw new Error("Error: polyline is already in model.");
    }
    //return model.getGeom().copyPolylineFromModel(polyline);
    throw new Error("Function not implemented yet...");
}
//  ===============================================================================================================
//  Pline Constructors ============================================================================================
//  ===============================================================================================================
/**
 * Creates a polyline by joining a list of points
 *
 * Straight line segments are cerated between every two points.
 *
 * @param points A list of points.
 * @param is_closed if true,
 *      creates a closed polyline object by joining the last point to the first point.
 * @returns Polyline object.
 */
function FromPoints(points, is_closed) {
    if (is_closed === void 0) { is_closed = false; }
    var model = _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkPointList"](points, 2);
    return model.getGeom().addPolyline(points, is_closed);
}
/**
 * Create a polyline by dividing a circle or arc into straight line segments.
 *
 * If it is a circle, then a a closed polyline is returned.
 *
 * @param circle Circle or circular arc to construct polyline from.
 * @param segments Number of segments in resulting polyline.
 * @returns Polyline object.
 */
function FromCircle(circle, segments) {
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkObj"](circle, 3 /* circle */);
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkPosNum"](segments);
    var m = circle.getModel();
    var points = circle.equiPoints(segments + 1);
    return m.getGeom().addPolyline(points, circle.isClosed());
}
/**
 * Create a polyline with a single straight line segment, connecting two points.
 *
 * @param start Start point of line
 * @param end End point of line.
 * @returns Polyline object.
 */
function From2Points(start, end) {
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkPoint"](start);
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkPoint"](end);
    return this.FromPoints([start, end], false);
}
//  ===============================================================================================================
//  Pline Simple Functions ===============================================================================================
//  ===============================================================================================================
/**
 * Checks if the polyline is closed.
 *
 * @param pline Polyline object.
 * @return True if the polyline is closed.
 */
function isClosed(pline) {
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkObj"](pline, 100 /* polyline */);
    return pline.isClosed();
}
/**
 * Sets the polyline to be open or closed.
 *
 * @param pline Polyline object.
 * @param is_closed True for closed, false for open.
 * @return True if the value was changed, false otherwise.
 */
function setIsClosed(pline, is_closed) {
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkObj"](pline, 100 /* polyline */);
    if (pline.isClosed() === is_closed) {
        return false;
    }
    pline.setIsClosed(is_closed);
    return true;
}
/**
 * Get the number of edges in the polyline.
 *
 * @param pline Polyline object.
 * @return The number of edges.
 */
function numEdges(pline) {
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkObj"](pline, 100 /* polyline */);
    return pline.numEdges();
}
/**
 * Get the number of vertices in the polyline.
 *
 * @param pline Polyline object.
 * @return The number of vertices.
 */
function numVertices(pline) {
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkObj"](pline, 100 /* polyline */);
    return pline.numVertices();
}
/**
 * Get all points in a polyline in sequence order.
 *
 * @param pline Polyline object.
 * @return A list of points.
 */
function getPoints(pline) {
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkObj"](pline, 100 /* polyline */);
    return pline.getPointsArr();
}
/**
 * Get the start and end points of a polyline.
 *
 * @param pline Polyline object.
 * @return A list with two points, or null if the polyline is closed.
 */
function getEndPoints(pline) {
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkObj"](pline, 100 /* polyline */);
    if (pline.isClosed()) {
        return null;
    }
    var points = pline.getPointsArr();
    return [points[0], points[points.length - 1]];
}
/**
 * Returns a point by evaluating the position along a polyline.
 * The position is specified by a t parameter that starts at 0 and ends at 1.
 * If the polyline is closed, 0 and 1 will have the same position.
 *
 * @param pline Polyline to evaluate.
 * @param t Parameter to evaluate (0 is the start of the polyline, 1 is the end of the polyline)
 * @returns Point.
 */
function evalParam(pline, t) {
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkObj"](pline, 100 /* polyline */);
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkPosNum"](t);
    var points = pline.getPointsArr();
    if (pline.isClosed()) {
        points.push(points[0]);
    }
    return _libs_poly_poly__WEBPACK_IMPORTED_MODULE_2__["pointsEvaluate"](points, t);
}
//  ===============================================================================================================
//  Pline Modelling Functions ===============================================================================================
//  ===============================================================================================================
/**
 * Divides a polyline. Each edge of the polyline is divided into different numbers of segments.
 * The number of segments for each edge is calculated by dividing the edge length by max_lenth,
 * and then rounding up to the nearest integer.
 *
 * The original polyline is not modified.
 *
 * @param pline The polyline to divide.
 * @param max_length The target maximum length of the segment,
 * may either be a single number or an list of numbers. If it is an list, then
 * the list length must be equal to the number of edges.
 * @returns A new polyline with subdivided edges.
 */
function divideMaxLength(pline, max_length) {
    var _a, _b, e_1, _c;
    var model = _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkObj"](pline, 100 /* polyline */);
    var num_edges = pline.numEdges();
    if (!Array.isArray(max_length)) {
        max_length = _libs_arr_arr__WEBPACK_IMPORTED_MODULE_5__["Arr"].make(num_edges, max_length);
    }
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkNumListLength"](max_length, num_edges);
    // get points
    var old_points = pline.getPointsArr();
    if (pline.isClosed()) {
        old_points.push(old_points[0]);
    }
    // create array to store new points
    var new_points = [];
    // loop through and add points
    for (var i = 0; i < old_points.length - 1; i++) {
        new_points.push(old_points[i]);
        var vp1 = new ((_a = three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]).bind.apply(_a, __spread([void 0], old_points[i].getPosition())))();
        var vp2 = new ((_b = three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]).bind.apply(_b, __spread([void 0], old_points[i + 1].getPosition())))();
        var num_segments = Math.ceil(vp1.distanceTo(vp2) / max_length[i]);
        var vpoints = _libs_threex_threex__WEBPACK_IMPORTED_MODULE_1__["interpVPoints"](vp1, vp2, num_segments - 1);
        try {
            for (var vpoints_1 = __values(vpoints), vpoints_1_1 = vpoints_1.next(); !vpoints_1_1.done; vpoints_1_1 = vpoints_1.next()) {
                var vpoint = vpoints_1_1.value;
                var new_point = model.getGeom().addPoint(vpoint.toArray());
                new_points.push(new_point);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (vpoints_1_1 && !vpoints_1_1.done && (_c = vpoints_1.return)) _c.call(vpoints_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    // add last point if pline is open
    if (!pline.isClosed()) {
        new_points.push(old_points[old_points.length - 1]);
    }
    // create the new polyline and return it
    return model.getGeom().addPolyline(new_points, pline.isClosed());
}
/**
 * Divides a polyline. Each edge of the polyline is divided into the same number of segments.
 * The original polyline is not modified.
 *
 * @param pline The polyline to divide.
 * @param num_segements The number of segments to create.
 * This may either be a single number or an list of numbers.
 * If it is an list, then the list length must be equal to the number of edges.
 * @returns A new polyline with subdivided edges.
 */
function divide(pline, num_segments) {
    var _a, _b, e_2, _c;
    var model = _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkObj"](pline, 100 /* polyline */);
    if (!Array.isArray(num_segments)) {
        num_segments = _libs_arr_arr__WEBPACK_IMPORTED_MODULE_5__["Arr"].make(pline.numEdges(), num_segments);
    }
    var num_edges = pline.numEdges();
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkPosNums"](num_segments);
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkNumListLength"](num_segments, num_edges);
    // get points
    var old_points = pline.getPointsArr();
    if (pline.isClosed()) {
        old_points.push(old_points[0]);
    }
    // create array to store new points
    var new_points = [];
    // loop through and add points
    for (var i = 0; i < old_points.length - 1; i++) {
        new_points.push(old_points[i]);
        var vp1 = new ((_a = three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]).bind.apply(_a, __spread([void 0], old_points[i].getPosition())))();
        var vp2 = new ((_b = three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]).bind.apply(_b, __spread([void 0], old_points[i + 1].getPosition())))();
        var vpoints = _libs_threex_threex__WEBPACK_IMPORTED_MODULE_1__["interpVPoints"](vp1, vp2, num_segments[i] - 1);
        try {
            for (var vpoints_2 = __values(vpoints), vpoints_2_1 = vpoints_2.next(); !vpoints_2_1.done; vpoints_2_1 = vpoints_2.next()) {
                var vpoint = vpoints_2_1.value;
                var new_point = model.getGeom().addPoint(vpoint.toArray());
                new_points.push(new_point);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (vpoints_2_1 && !vpoints_2_1.done && (_c = vpoints_2.return)) _c.call(vpoints_2);
            }
            finally { if (e_2) throw e_2.error; }
        }
    }
    // add last point if pline is open
    if (!pline.isClosed()) {
        new_points.push(old_points[old_points.length - 1]);
    }
    // create the new polyline and return it
    return model.getGeom().addPolyline(new_points, pline.isClosed());
}
/**
 * Joins polylines with shared end points. The original polylines are deleted.
 *
 * @param plines List of polylines to join.
 * @returns List of polyline objects.
 */
function join(plines) {
    var e_3, _a, e_4, _b, e_5, _c;
    var model = _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkObjList"](plines, 2, 100 /* polyline */);
    var geom = model.getGeom();
    // create an array of array of points
    var point_ids_arrays = [];
    try {
        for (var plines_1 = __values(plines), plines_1_1 = plines_1.next(); !plines_1_1.done; plines_1_1 = plines_1.next()) {
            var pline = plines_1_1.value;
            var points = pline.getPointsArr();
            var start_end = [points[0].getID(), points[points.length - 1].getID()];
            if (start_end[1] < start_end[0]) {
                points.reverse();
            }
            point_ids_arrays.push(points.map(function (p) { return p.getID(); }));
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (plines_1_1 && !plines_1_1.done && (_a = plines_1.return)) _a.call(plines_1);
        }
        finally { if (e_3) throw e_3.error; }
    }
    point_ids_arrays.sort();
    // create disjoint set
    var disjoint_sets = [];
    disjoint_sets.push([point_ids_arrays[0]]);
    point_ids_arrays.splice(0, 1);
    var max = 0;
    while (point_ids_arrays.length > 0 && max < 100) {
        max++;
        var tried_all = false;
        var last_disjoint_set = disjoint_sets[disjoint_sets.length - 1];
        var last_point_ids = last_disjoint_set[last_disjoint_set.length - 1];
        var current_start = last_disjoint_set[0][0];
        var current_end = last_point_ids[last_point_ids.length - 1];
        tried_all = true;
        for (var i = 0; i < point_ids_arrays.length; i++) {
            var point_ids = point_ids_arrays[i];
            var point_ids_start = point_ids[0];
            var point_ids_end = point_ids[point_ids.length - 1];
            if (current_end === point_ids_start) {
                tried_all = false;
                last_disjoint_set.push(point_ids);
                current_end = last_point_ids[last_point_ids.length - 1];
                point_ids_arrays.splice(i, 1);
                break;
            }
            else if (current_start === point_ids_end) {
                tried_all = false;
                last_disjoint_set.unshift(point_ids);
                current_start = last_disjoint_set[0][0];
                point_ids_arrays.splice(i, 1);
                break;
            }
            else if (current_end === point_ids_end) {
                tried_all = false;
                last_disjoint_set.push(point_ids.reverse());
                current_end = last_point_ids[last_point_ids.length - 1];
                point_ids_arrays.splice(i, 1);
                break;
            }
            else if (current_start === point_ids_start) {
                tried_all = false;
                last_disjoint_set.unshift(point_ids.reverse());
                current_start = last_disjoint_set[0][0];
                point_ids_arrays.splice(i, 1);
                break;
            }
        }
        if (tried_all || (current_start === current_end)) {
            disjoint_sets.push([point_ids_arrays[0]]);
            point_ids_arrays.splice(0, 1);
        }
    }
    // create polylines
    var new_plines = [];
    try {
        for (var disjoint_sets_1 = __values(disjoint_sets), disjoint_sets_1_1 = disjoint_sets_1.next(); !disjoint_sets_1_1.done; disjoint_sets_1_1 = disjoint_sets_1.next()) {
            var disjoint_set = disjoint_sets_1_1.value;
            var points = [];
            try {
                for (var disjoint_set_1 = __values(disjoint_set), disjoint_set_1_1 = disjoint_set_1.next(); !disjoint_set_1_1.done; disjoint_set_1_1 = disjoint_set_1.next()) {
                    var point_ids = disjoint_set_1_1.value;
                    for (var i = 0; i < point_ids.length - 1; i++) {
                        points.push(geom.getPoint(point_ids[i]));
                    }
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (disjoint_set_1_1 && !disjoint_set_1_1.done && (_c = disjoint_set_1.return)) _c.call(disjoint_set_1);
                }
                finally { if (e_5) throw e_5.error; }
            }
            var start = disjoint_set[0][0];
            var last_array = disjoint_set[disjoint_set.length - 1];
            var end = last_array[last_array.length - 1];
            if (start === end) {
                new_plines.push(geom.addPolyline(points, true));
            }
            else {
                points.push(geom.getPoint(end));
                new_plines.push(geom.addPolyline(points, false));
            }
        }
    }
    catch (e_4_1) { e_4 = { error: e_4_1 }; }
    finally {
        try {
            if (disjoint_sets_1_1 && !disjoint_sets_1_1.done && (_b = disjoint_sets_1.return)) _b.call(disjoint_sets_1);
        }
        finally { if (e_4) throw e_4.error; }
    }
    // delete the old polylines
    geom.delObjs(plines, true);
    // return the new plines
    return new_plines;
}
/**
 * Explodes a polyline into smaller polylines, each with only one segment.
 * The original polyline is not modified.
 *
 * @param pline Polyline to explode.
 * @returns List of polylines objects.
 */
function explode(pline) {
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkObj"](pline, 100 /* polyline */);
    return this.extract(pline, _libs_arr_arr__WEBPACK_IMPORTED_MODULE_5__["Arr"].makeSeq(pline.numEdges()));
}
/**
 * Creates new polyline by extracting line segments from an existing polyline.
 * The original polyline is not modified.
 *
 * The individual segments are no joined.
 *
 * @param pline Polyline to extract segments from
 * @param segment_index Index numbers of polyline segments to extract
 * @returns List of new polylines created from extract
 */
function extract(pline, segment_index) {
    var e_6, _a;
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkObj"](pline, 100 /* polyline */);
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkPosNums"](segment_index);
    // do the extraction
    var m = pline.getModel();
    var plines = [];
    var points = pline.getPointsArr();
    if (pline.isClosed()) {
        points.push(points[0]);
    }
    try {
        for (var segment_index_1 = __values(segment_index), segment_index_1_1 = segment_index_1.next(); !segment_index_1_1.done; segment_index_1_1 = segment_index_1.next()) {
            var i = segment_index_1_1.value;
            if (i >= points.length - 1) {
                throw new Error("Segment index exceeds polyline length.");
            }
            plines.push(m.getGeom().addPolyline([points[i], points[i + 1]], false));
        }
    }
    catch (e_6_1) { e_6 = { error: e_6_1 }; }
    finally {
        try {
            if (segment_index_1_1 && !segment_index_1_1.done && (_a = segment_index_1.return)) _a.call(segment_index_1);
        }
        finally { if (e_6) throw e_6.error; }
    }
    return plines;
}
/**
 * Create a new polymesh by extruding a polyline by a specified vector.
 * The original polyline is not modified.
 *
 * New points are created by translating the existing points by the specified vector.
 * Four-sided faces are the created between the original and new points.
 * The faces are joined to create a polymesh.
 *
 * If cap is true, input pline and moved pline are used as edges to create two polygons. The polygones are
 * joined to the polymesh.
 *
 * @param pline Polyline to extrude.
 * @param vector Vector describing direction and distance of extrusion.
 * @param cap Closes polymesh by creating a polygon on each end of the extrusion if true.
 * @returns Polymesh object.
 */
function extrude(pline, vector, cap) {
    if (cap === void 0) { cap = false; }
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkObj"](pline, 100 /* polyline */);
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkXYZ"](vector);
    // do the extrude
    var m = pline.getModel();
    var g = m.getGeom();
    var points1 = pline.getPointsArr();
    var points2 = points1.map(function (p) { return p.copy(); });
    _libs_threex_threex__WEBPACK_IMPORTED_MODULE_1__["movePointsAddXYZ"](points2, vector);
    var mesh_points = _libs_poly_poly__WEBPACK_IMPORTED_MODULE_2__["pointsLoft"]([points1, points2], pline.isClosed());
    if (cap) {
        mesh_points.push(points1.reverse());
        mesh_points.push(points2);
    }
    var pmesh = m.getGeom().addPolymesh(mesh_points);
    return pmesh;
}
/**
 * Create a new polymesh by lofting a list of polylines with equal numbers of segments.
 * The original polylines are not modified.
 *
 * Four-sided faces are the created between the points of consecutive polylines.
 * The faces are joined to create a polymesh.
 *
 * Throws an error if polylines do not have the same number of segments
 *
 * @param plines List of polylines to loft (in order).
 * @param is_closed Closes polymesh by lofting back to first polyline if true.
 * @returns Polymesh object.
 */
function loft(plines, is_closed) {
    if (is_closed === void 0) { is_closed = false; }
    var m = _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkObjList"](plines, 2, 100 /* polyline */);
    var g = m.getGeom();
    // get data
    if (is_closed) {
        plines.push(plines[0]);
    }
    var num_points = plines[0].numVertices();
    var num_plines = plines.length;
    var plines_closed = plines[0].isClosed();
    // get points
    var points = [];
    for (var i = 0; i < num_plines; i++) {
        if (plines[i].numVertices() !== num_points) {
            throw new Error("Plines do not have equal numbers of points.");
        }
        if (plines[i].isClosed() !== plines_closed) {
            throw new Error("Plines must all be either open or closed.");
        }
        points.push(plines[i].getPointsArr());
    }
    // make polymesh from points and return it
    return g.addPolymesh(_libs_poly_poly__WEBPACK_IMPORTED_MODULE_2__["pointsLoft"](points, plines_closed));
}
/**
 * Create a new polymesh by piping a polyline.
 *
 * @param polyline Polyline to pipe.
 * @param radius The radius of the pipe.
 * @param segments The number of polygon segments around the cicumference of the pipe.
 * @returns Polymesh object.
 */
function pipe(pline, radius, segments) {
    var m = _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkObj"](pline, 100 /* polyline */);
    // make polymesh
    return _libs_poly_polylinePipe__WEBPACK_IMPORTED_MODULE_3__["pipe"](pline, radius, segments);
}


/***/ }),

/***/ "./src/app/core/modules/pmesh.ts":
/*!***************************************!*\
  !*** ./src/app/core/modules/pmesh.ts ***!
  \***************************************/
/*! exports provided: Get, Copy, CopyToModel, FromPoints, FromPline, TriStripFromPoints, isClosed, numFaces, numWires, numEdges, numVertices, getPoints, extrude, explode, extractFaces, extractWires */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Get", function() { return Get; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Copy", function() { return Copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CopyToModel", function() { return CopyToModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FromPoints", function() { return FromPoints; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FromPline", function() { return FromPline; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TriStripFromPoints", function() { return TriStripFromPoints; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isClosed", function() { return isClosed; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "numFaces", function() { return numFaces; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "numWires", function() { return numWires; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "numEdges", function() { return numEdges; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "numVertices", function() { return numVertices; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPoints", function() { return getPoints; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extrude", function() { return extrude; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "explode", function() { return explode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractFaces", function() { return extractFaces; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractWires", function() { return extractWires; });
/* harmony import */ var gs_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gs-json */ "./node_modules/gs-json/dist2015/index.js");
/* harmony import */ var gs_json__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(gs_json__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _libs_threex_threex__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./libs/threex/threex */ "./src/app/core/modules/libs/threex/threex.ts");
/* harmony import */ var _libs_poly_poly__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./libs/poly/poly */ "./src/app/core/modules/libs/poly/poly.ts");
/* harmony import */ var _utils_dev__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_utils_dev */ "./src/app/core/modules/_utils_dev.ts");
/* harmony import */ var _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_error_msgs_dev */ "./src/app/core/modules/_error_msgs_dev.ts");
/* harmony import */ var _libs_arr_arr__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./libs/arr/arr */ "./src/app/core/modules/libs/arr/arr.ts");
/**
 * Functions for working with polymehes.
 */
var __read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (undefined && undefined.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __values = (undefined && undefined.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
/**
 * Polymeshes are geometric objects that can have multiple faces and multiple closed wires.
 * Faces define the surfaces in the polymesh. They can have three or more vertices,
 * they can be concave or convex, and planar or non-planar.
 * Wires define the naked edges, i.e. edges without any neighbours.
 * The wires in a polymesh are calculated automatically based on the connectivity between the faces.
 * The edges are straight line segments joining two vertices.
 * The polymesh can be either a closed or an open. A closed polymesh has no wires.
 */






//  ===============================================================================================================
//  Pmesh Get =====================================================================================================
//  ===============================================================================================================
/**
 * Gets a polymesh from the model based on an ID number.
 * In the viewer, the object label can display (it starts with 'o'), which contains the ID.
 * For example, if the label is "o123", then the ID is the number 123.
 *
 * @param model Model to get polymesh from.
 * @param id ID number of polymesh.
 * @returns Polymesh object.
 */
function Get(model, id) {
    var obj = _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkObjID"](model, id, 200 /* polymesh */);
    return obj;
}
/**
 * Create a copy of a polymesh.
 *
 * @param polymesh The polymesh to copy.
 * @param copy_attribs If true, attributes are copied to the new circle.
 * @returns Polymesh object.
 */
function Copy(polymesh, copy_attribs) {
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkObj"](polymesh, 200 /* polymesh */);
    return polymesh.copy(copy_attribs);
}
/**
 * Copies a polymesh from one model into another model.
 *
 * @param model The model to copy to.
 * @param polymesh The polymesh object to copy.
 * @returns The copied polymesh object in the model.
 */
function CopyToModel(model, polymesh) {
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkObj"](polymesh, 200 /* polymesh */);
    if (polymesh.getModel() === model) {
        throw new Error("Error: polymesh is already in model.");
    }
    //return model.getGeom().copyPolymeshFromModel(polymesh);
    throw new Error("Function not implemented yet.");
}
//  ===============================================================================================================
//  Pmesh Constructors ============================================================================================
//  ===============================================================================================================
/**
 * Creates a polymesh from a list of lists of face corner points.
 * For example [[p1, p2, p3], [p3, p2, p4]] would create a polymesh with two triangular faces.
 * In this example, the two faces share points p2 and p3.
 *
 * @param points List of lists of face corner points.
 * @returns Polymesh object.
 */
function FromPoints(points) {
    var model = _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkPointNestedList"](points, 1, 3);
    return model.getGeom().addPolymesh(points);
}
/**
 * Creates a polymesh from a polyline. The polymesh will have a single face.
 *
 * @param pline Polyline object to create the polymesh from.
 * @returns Polymesh object with single face.
 */
function FromPline(pline) {
    var model = _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkObj"](pline, 100 /* polyline */);
    return model.getGeom().addPolymesh([pline.getPointsArr()]);
}
/**
 * Creates a triangulated mesh from two lists of points.
 * For example [[p1, p2, p3], [p4, p5, p6]] would create a polymesh with four triangular faces.
 * The triangles would be as follows: [p1, p2, p4], [p5, p4, p1], [p2, p3, p5], [p6, p5, p3].
 * In this example, the two faces share points p2 and p3.
 *
 * @param points1 The first list of points.
 * @param points2 The second list of points.
 * @returns Polymesh object.
 */
function TriStripFromPoints(points1, points2) {
    var model = _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkPointList"](points1, 2);
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkPointList"](points2, 2);
    // sort, shortest list first
    var points = [];
    if (points1.length < points2.length) {
        points[0] = points1;
        points[1] = points2;
    }
    else {
        points[0] = points2;
        points[1] = points1;
    }
    // create quads, the split into two triangles along shortest diagonal
    var tri_points = [];
    for (var i = 0; i < points[0].length - 1; i++) {
        var p0 = points[0][i];
        var p1 = points[0][i + 1];
        var p2 = points[1][i + 1];
        var p3 = points[1][i];
        if (_libs_threex_threex__WEBPACK_IMPORTED_MODULE_1__["distSquPointToPoint"](p1, p3) < _libs_threex_threex__WEBPACK_IMPORTED_MODULE_1__["distSquPointToPoint"](p0, p2)) {
            tri_points.push([p0, p1, p3]);
            tri_points.push([p1, p2, p3]);
        }
        else {
            tri_points.push([p0, p1, p2]);
            tri_points.push([p0, p2, p3]);
        }
    }
    // add triangles for the remainder
    for (var i = points[0].length - 1; i < points[1].length - 1; i++) {
        var p0 = points[1][i + 1];
        var p1 = points[1][i];
        var p2 = points[0][points[0].length - 1];
        tri_points.push([p0, p1, p2]);
    }
    // generate mesh and return
    return model.getGeom().addPolymesh(tri_points);
}
//  ===============================================================================================================
//  Pmesh Simple Functions ===============================================================================================
//  ===============================================================================================================
/**
 * Checks if the polymesh is closed.
 *
 * @param pmesh Polymesh object.
 * @return True if the polymesh is closed.
 */
function isClosed(pmesh) {
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkObj"](pmesh, 200 /* polymesh */);
    return pmesh.numWires() === 0;
}
/**
 * Get the number of faces in a polymesh.
 *
 * @param pmesh Polymesh object.
 * @return The number of faces.
 */
function numFaces(pmesh) {
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkObj"](pmesh, 200 /* polymesh */);
    return pmesh.numFaces();
}
/**
 * Get the number of wires in a polymesh.
 *
 * @param pmesh Polymesh object.
 * @return The number of wires.
 */
function numWires(pmesh) {
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkObj"](pmesh, 200 /* polymesh */);
    return pmesh.numWires();
}
/**
 * Get the number of edges in a polymesh, for both the wires and the faces.
 *
 * @param pmesh Polymesh object.
 * @return List of two numbers, number of wire edges and number of face edges.
 */
function numEdges(pmesh) {
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkObj"](pmesh, 200 /* polymesh */);
    return [pmesh.numWireEdges(), pmesh.numFaceEdges()];
}
/**
 * Get the number of vertices in the polymesh, for both the wires and the faces.
 *
 * @param pmesh Polymesh object.
 * @return List of two numbers, number of wire vertices and number of face vertices.
 */
function numVertices(pmesh) {
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkObj"](pmesh, 200 /* polymesh */);
    return [pmesh.numWireVertices(), pmesh.numFaceVertices()];
}
/**
 * Get all points in a polymesh. The sequence of points is in face order.
 *
 * @param pmesh Polymesh object.
 * @return List of points.
 */
function getPoints(pmesh) {
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkObj"](pmesh, 200 /* polymesh */);
    return _libs_arr_arr__WEBPACK_IMPORTED_MODULE_5__["Arr"].flatten(pmesh.getPoints(gs_json__WEBPACK_IMPORTED_MODULE_0__["EGeomType"].faces));
}
//  ===============================================================================================================
//  Pmesh Modelling Functions ===============================================================================================
//  ===============================================================================================================
/**
 * Create a new polymesh by extruding an existing polymesh by a specified vector.
 * The original polymesh is not modified.
 *
 * New points are created by translating the existing points by the specified vector.
 * Top and bottom faces are created.
 * Four-sided faces are the created between the original and new points.
 * The faces are joined to create a polymesh.
 *
 * @param pmesh Polymesh to extrude.
 * @param vector The vector defining the extrusion length and direction.
 * @returns A polymesh if successful, null if unsuccessful or on error.
 */
function extrude(pmesh, vector) {
    // check args
    var model = _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkObj"](pmesh, 200 /* polymesh */);
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkXYZ"](vector);
    // make a copy
    var pmesh1_points = pmesh.getPoints();
    var pmesh2_points = _utils_dev__WEBPACK_IMPORTED_MODULE_3__["copyObjPoints"](pmesh, false);
    _libs_threex_threex__WEBPACK_IMPORTED_MODULE_1__["movePointsAddXYZ"](_libs_arr_arr__WEBPACK_IMPORTED_MODULE_5__["Arr"].flatten(pmesh2_points), vector);
    // create the sides
    var sides = _libs_poly_poly__WEBPACK_IMPORTED_MODULE_2__["pointsLoftLoop"]([pmesh1_points[0], pmesh2_points[0]], true);
    // combine everything
    var pmesh_points = __spread(pmesh1_points[1], pmesh2_points[1], sides);
    // return the new polymesh
    return model.getGeom().addPolymesh(pmesh_points);
}
/**
 * Explodes a polymesh into smaller polymeshes, each with only one face.
 * The original polymesh is not modified.
 *
 * @param pmesh Polymesh to explode.
 * @returns List of polymeshes.
 */
function explode(pmesh) {
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkObj"](pmesh, 200 /* polymesh */);
    return this.extractFaces(pmesh, _libs_arr_arr__WEBPACK_IMPORTED_MODULE_5__["Arr"].makeSeq(pmesh.numFaces()));
}
/**
 * Creates new set of polymeshes by extracting faces from an existing polymesh.
 * The original polymesh is not modified.
 *
 * The individual polymeshes are not joined.
 *
 * @param pmesh Polymesh to extract faces from
 * @param face_index Index numbers of polymesh faces to extract.
 * @returns List of new polymeshes.
 */
function extractFaces(pmesh, face_index) {
    var e_1, _a;
    var m = _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkObj"](pmesh, 200 /* polymesh */);
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkPosNums"](face_index);
    // do the extraction
    var new_pmeshes = [];
    var faces = pmesh.getFaces();
    try {
        for (var face_index_1 = __values(face_index), face_index_1_1 = face_index_1.next(); !face_index_1_1.done; face_index_1_1 = face_index_1.next()) {
            var i = face_index_1_1.value;
            if (i >= faces.length) {
                throw new Error("Face index exceeds the number of faces.");
            }
            var points = faces[i].getVertices().map(function (v) { return v.getPoint(); });
            new_pmeshes.push(m.getGeom().addPolymesh([points]));
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (face_index_1_1 && !face_index_1_1.done && (_a = face_index_1.return)) _a.call(face_index_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return new_pmeshes;
}
/**
 * Creates new set of polylines by extracting wires from an existing polymesh.
 * The original polymesh is not modified.
 *
 * Wires are the naked edges of a polymesh. They are always closed loops.
 *
 * @param pmesh Polymesh to extract wires from.
 * @param wire_index Index numbers of polymesh wires to extract.
 * @returns List of new polylines.
 */
function extractWires(pmesh, wire_index) {
    var e_2, _a;
    var m = _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkObj"](pmesh, 200 /* polymesh */);
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkPosNums"](wire_index);
    // do the extraction
    var new_plines = [];
    var wires = pmesh.getWires();
    try {
        for (var wire_index_1 = __values(wire_index), wire_index_1_1 = wire_index_1.next(); !wire_index_1_1.done; wire_index_1_1 = wire_index_1.next()) {
            var i = wire_index_1_1.value;
            if (i >= wires.length) {
                throw new Error("Face index exceeds the number of faces.");
            }
            var points = wires[i].getVertices().map(function (v) { return v.getPoint(); });
            new_plines.push(m.getGeom().addPolyline(points, true));
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (wire_index_1_1 && !wire_index_1_1.done && (_a = wire_index_1.return)) _a.call(wire_index_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return new_plines;
}


/***/ }),

/***/ "./src/app/core/modules/point.ts":
/*!***************************************!*\
  !*** ./src/app/core/modules/point.ts ***!
  \***************************************/
/*! exports provided: Get, Gets, GetFromGroup, GetFromObjs, Copy, CopyToModel, FromXYZ, FromXYZs, FromPointsMean, move, rotate, scale, del, getXYZ, setXYZ, mergeByTol, merge, addToGroup, removeFromGroup */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Get", function() { return Get; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Gets", function() { return Gets; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GetFromGroup", function() { return GetFromGroup; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GetFromObjs", function() { return GetFromObjs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Copy", function() { return Copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CopyToModel", function() { return CopyToModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FromXYZ", function() { return FromXYZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FromXYZs", function() { return FromXYZs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FromPointsMean", function() { return FromPointsMean; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "move", function() { return move; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "del", function() { return del; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getXYZ", function() { return getXYZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setXYZ", function() { return setXYZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mergeByTol", function() { return mergeByTol; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "merge", function() { return merge; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addToGroup", function() { return addToGroup; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeFromGroup", function() { return removeFromGroup; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _error_msgs_dev__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_error_msgs_dev */ "./src/app/core/modules/_error_msgs_dev.ts");
/**
 * Function for working with points.
 */
var __values = (undefined && undefined.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (undefined && undefined.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};


//  ===============================================================================================================
//  Point Get Copy ================================================================================================
//  ===============================================================================================================
/**
 * Gets a point from a model.
 *
 * @param model Model to get point from.
 * @param id ID of point to get.
 * @returns Point.
 */
function Get(model, id) {
    var point = _error_msgs_dev__WEBPACK_IMPORTED_MODULE_1__["checkPointID"](model, id);
    return point;
}
/**
 * Gets a list of points from the model.
 *
 * @param model Model to get points from.
 * @param ids A point ID or list of point IDs, integer numbers. If null, then all points are returned.
 * @returns A list of points.
 */
function Gets(model, ids) {
    var e_1, _a;
    if (ids === undefined || ids === null) {
        return model.getGeom().getAllPoints();
    }
    if (!Array.isArray(ids)) {
        ids = [ids];
    }
    var points = [];
    try {
        for (var ids_1 = __values(ids), ids_1_1 = ids_1.next(); !ids_1_1.done; ids_1_1 = ids_1.next()) {
            var id = ids_1_1.value;
            var point = Get(model, id);
            if (point !== null) {
                points.push(point);
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (ids_1_1 && !ids_1_1.done && (_a = ids_1.return)) _a.call(ids_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return points;
}
/**
 * Gets all the points from a group.
 *
 * @param model Model to get the points from.
 * @param group_name The group name.
 * @returns List of points.
 */
function GetFromGroup(model, group_name) {
    var group = _error_msgs_dev__WEBPACK_IMPORTED_MODULE_1__["checkGroup"](model, group_name);
    return group.getPoints();
}
/**
 * Gets a list of unique points for a list of objects.
 *
 * @param objs An object or list of objects.
 * @returns List of points.
 */
function GetFromObjs(objs) {
    var e_2, _a, e_3, _b;
    // TODO error checking of args
    if (!Array.isArray(objs)) {
        objs = [objs];
    }
    var points_map = new Map();
    var obj_points = [];
    try {
        for (var objs_1 = __values(objs), objs_1_1 = objs_1.next(); !objs_1_1.done; objs_1_1 = objs_1.next()) {
            var obj = objs_1_1.value;
            try {
                for (var _c = __values(obj.getPointsArr()), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var point = _d.value;
                    points_map.set(point.getID(), point);
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                }
                finally { if (e_3) throw e_3.error; }
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (objs_1_1 && !objs_1_1.done && (_a = objs_1.return)) _a.call(objs_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return Array.from(points_map.values());
}
/**
 * Copy a point within a model.
 *
 * @param point Point to copy.
 * @returns New point.
 */
function Copy(point) {
    var model = _error_msgs_dev__WEBPACK_IMPORTED_MODULE_1__["checkPoint"](point);
    return model.getGeom().addPoint(point.getPosition());
}
/**
 * Copy a point from one model into another model.
 *
 * @param model The model to copy to.
 * @param plane The plane object to copy.
 * @returns The copied plane object in the model.
 */
function CopyToModel(model, point) {
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_1__["checkPoint"](point);
    // check it is not already in the model
    if (point.getModel() === model) {
        throw new Error("Error: point is already in model.");
    }
    // copy circle and return it
    return model.getGeom().addPoint(point.getPosition());
}
//  ===============================================================================================================
//  Point Constructors ============================================================================================
//  ===============================================================================================================
/**
 * Creates a point from XYZ coordinates.
 *
 * @param __model__ Model to add points to.
 * @param xyz XYZ coordinates, as a list of three numbers.
 * @returns New point if successful, null if unsuccessful or on error.
 */
function FromXYZ(__model__, xyz) {
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_1__["checkXYZ"](xyz);
    return __model__.getGeom().addPoint(xyz);
}
/**
 * Creates a list of points from a list of X, Y and Z coordinates.
 * Points are returned in list order.
 *
 * @param __model__ Model to add points to.
 * @param xyzs A list XYZ coordinates, as a list of lists of three numbers.
 * @returns New list of points if successful, null if unsuccessful or on error
 */
function FromXYZs(__model__, xyzs) {
    var e_4, _a;
    var points = [];
    try {
        for (var _b = __values(xyzs), _c = _b.next(); !_c.done; _c = _b.next()) {
            var xyz = _c.value;
            _error_msgs_dev__WEBPACK_IMPORTED_MODULE_1__["checkXYZ"](xyz);
            points.push(__model__.getGeom().addPoint(xyz));
        }
    }
    catch (e_4_1) { e_4 = { error: e_4_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_4) throw e_4.error; }
    }
    return points;
}
/**
 * Creates a point that is at the center of a cluster of points.
 *
 * @param points List of points.
 * @returns New point if successful, null if unsuccessful or on error.
 */
function FromPointsMean(points) {
    var e_5, _a;
    var model = _error_msgs_dev__WEBPACK_IMPORTED_MODULE_1__["checkPointList"](points, 2);
    var xyz = [0, 0, 0];
    try {
        for (var points_1 = __values(points), points_1_1 = points_1.next(); !points_1_1.done; points_1_1 = points_1.next()) {
            var point = points_1_1.value;
            var pos = point.getPosition();
            xyz[0] += pos[0];
            xyz[1] += pos[1];
            xyz[2] += pos[2];
        }
    }
    catch (e_5_1) { e_5 = { error: e_5_1 }; }
    finally {
        try {
            if (points_1_1 && !points_1_1.done && (_a = points_1.return)) _a.call(points_1);
        }
        finally { if (e_5) throw e_5.error; }
    }
    return model.getGeom().addPoint([xyz[0] / points.length, xyz[1] / points.length, xyz[2] / points.length]);
}
//  ===============================================================================================================
//  Point Functions ============================================================================================
//  ===============================================================================================================
/**
 * Moves a point or a list of points by a translation vector.
 *
 * @param points A point or a list of points.
 * @param vector Translation vector.
 * @param copy If true, points are copied before being moved.
 * @returns The moved points.
 */
function move(points, vector, copy) {
    if (copy === void 0) { copy = false; }
    var is_array = Array.isArray(points);
    if (!Array.isArray(points)) {
        points = [points];
    }
    var model = _error_msgs_dev__WEBPACK_IMPORTED_MODULE_1__["checkPointList"](points, 1);
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_1__["checkXYZ"](vector);
    // translation matrix
    var matrix_trn = new three__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]();
    matrix_trn.makeTranslation(vector[0], vector[1], vector[2]);
    // copy points
    if (copy) {
        points = model.getGeom().copyPoints(points, true);
    }
    // do the xform
    model.getGeom().xformPoints(points, matrix_trn);
    // return either a single point or array of points
    if (is_array) {
        return points;
    }
    return points[0];
}
/**
 * Rotates a point or a list of points around an axis.
 *
 * @param points A point or a list of points.
 * @param origin An xyz point on the axis.
 * @param axis An xyz vector along the axis.
 * @param angle The angle, in degrees, between 0 and 360.
 * @param copy If true, points are copied before being rotated.
 * @returns The rotated points.
 */
function rotate(points, origin, axis, angle, copy) {
    if (copy === void 0) { copy = false; }
    var _a;
    // check args
    var is_array = Array.isArray(points);
    if (!Array.isArray(points)) {
        points = [points];
    }
    var model = _error_msgs_dev__WEBPACK_IMPORTED_MODULE_1__["checkPointList"](points, 1);
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_1__["checkXYZ"](origin);
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_1__["checkXYZ"](axis);
    var angle_rad = (angle / 180) * Math.PI;
    // rotation matrix
    var matrix_rot = new three__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]();
    matrix_rot.makeRotationAxis(new ((_a = three__WEBPACK_IMPORTED_MODULE_0__["Vector3"]).bind.apply(_a, __spread([void 0], axis)))(), angle_rad);
    // translation matrix
    var matrix_trn1 = new three__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]();
    matrix_trn1.makeTranslation(-origin[0], -origin[1], -origin[2]);
    var matrix_trn2 = new three__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]();
    matrix_trn2.makeTranslation(origin[0], origin[1], origin[2]);
    // copy points
    if (copy) {
        points = model.getGeom().copyPoints(points, true);
    }
    // do the xform
    model.getGeom().xformPoints(points, matrix_trn2.multiply(matrix_rot.multiply(matrix_trn1)));
    // return either a single point or array of points
    if (is_array) {
        return points;
    }
    return points[0];
}
/**
 * Scales a point or a list of points around an origin.
 *
 * @param points A point or a list of points.
 * @param origin An xyz origin point of the scale.
 * @param factor The scale factor, along the x, y and z axes.
 * @param copy If true, points are copied before being scaled.
 * @returns The scaled points.
 */
function scale(points, origin, factor, copy) {
    if (copy === void 0) { copy = false; }
    // check args
    var is_array = Array.isArray(points);
    if (!Array.isArray(points)) {
        points = [points];
    }
    var model = _error_msgs_dev__WEBPACK_IMPORTED_MODULE_1__["checkPointList"](points, 1);
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_1__["checkXYZ"](origin);
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_1__["checkXYZ"](factor);
    // scale matrix
    var matrix_scale = new three__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]();
    matrix_scale.makeScale(factor[0], factor[1], factor[2]);
    // translation matrix
    var matrix_trn1 = new three__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]();
    matrix_trn1.makeTranslation(-origin[0], -origin[1], -origin[2]);
    var matrix_trn2 = new three__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]();
    matrix_trn2.makeTranslation(origin[0], origin[1], origin[2]);
    // copy points
    if (copy) {
        points = model.getGeom().copyPoints(points, true);
    }
    // do the xform
    model.getGeom().xformPoints(points, matrix_trn2.multiply(matrix_scale.multiply(matrix_trn1)));
    // return either a single point or array of points
    if (is_array) {
        return points;
    }
    return points[0];
}
/**
 * Deletes a point or a list of points from the model.
 *
 * @param points Point or list of points to delete.
 * @returns True if successful
 */
function del(points) {
    var e_6, _a;
    if (!Array.isArray(points)) {
        points = [points];
    }
    var model = _error_msgs_dev__WEBPACK_IMPORTED_MODULE_1__["checkPointList"](points, 1);
    var ok = true;
    try {
        for (var points_2 = __values(points), points_2_1 = points_2.next(); !points_2_1.done; points_2_1 = points_2.next()) {
            var point = points_2_1.value;
            if (!point.exists()) {
                _error_msgs_dev__WEBPACK_IMPORTED_MODULE_1__["pointNotExist"]();
            }
            if (point.getModel() !== model) {
                _error_msgs_dev__WEBPACK_IMPORTED_MODULE_1__["pointInOtherModel"]();
            }
            if (!model.getGeom().delPoint(point)) {
                ok = false;
            }
        }
    }
    catch (e_6_1) { e_6 = { error: e_6_1 }; }
    finally {
        try {
            if (points_2_1 && !points_2_1.done && (_a = points_2.return)) _a.call(points_2);
        }
        finally { if (e_6) throw e_6.error; }
    }
    return ok;
}
/**
 * Get the XYZ coordinates of the point.
 *
 * @param point Point to get coordinates from.
 * @returns The XYZ coordinates if successful, null if unsuccessful or on error.
 */
function getXYZ(point) {
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_1__["checkPoint"](point);
    return point.getPosition();
}
/**
 * Set the XYZ coordinates of the point.
 *
 * @param point Point to set coorinates for.
 * @param xyz The new XYZ coordinates, as a list of three numbers.
 * @returns The old XYZ coordinates if successful, null if unsuccessful or on error.
 */
function setXYZ(point, xyz) {
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_1__["checkPoint"](point);
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_1__["checkXYZ"](xyz);
    return point.setPosition(xyz);
}
/**
 * Merges point or a list of points in the model.
 *
 * @param points Point or list of points to delete.
 * @returns True if successful, false otherwise.
 */
function mergeByTol(points, tolerance) {
    var e_7, _a;
    var model = _error_msgs_dev__WEBPACK_IMPORTED_MODULE_1__["checkPointList"](points, 2);
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_1__["checkPosNum"](tolerance);
    try {
        for (var points_3 = __values(points), points_3_1 = points_3.next(); !points_3_1.done; points_3_1 = points_3.next()) {
            var point = points_3_1.value;
            if (point.getModel() !== model) {
                throw new Error("Points must all be in same model.");
            }
            if (!point.exists()) {
                throw new Error("Point has been deleted.");
            }
        }
    }
    catch (e_7_1) { e_7 = { error: e_7_1 }; }
    finally {
        try {
            if (points_3_1 && !points_3_1.done && (_a = points_3.return)) _a.call(points_3);
        }
        finally { if (e_7) throw e_7.error; }
    }
    return model.getGeom().mergePoints(points, tolerance);
}
/**
 * Merges a cluster of points into a single point.
 * The cluster of points are deletetd and replaced by one new point located at the center of the cluster.
 * All objects in the model that are using those points will be updated.
 *
 * @param points Cluster of points to merge.
 * @returns New point if successful, null if unsuccessful or on error.
 */
function merge(points) {
    var e_8, _a;
    var model = _error_msgs_dev__WEBPACK_IMPORTED_MODULE_1__["checkPointList"](points, 2);
    try {
        for (var points_4 = __values(points), points_4_1 = points_4.next(); !points_4_1.done; points_4_1 = points_4.next()) {
            var point = points_4_1.value;
            if (point.getModel() !== model) {
                _error_msgs_dev__WEBPACK_IMPORTED_MODULE_1__["pointInOtherModel"]();
            }
            if (!point.exists()) {
                _error_msgs_dev__WEBPACK_IMPORTED_MODULE_1__["pointNotExist"]();
            }
        }
    }
    catch (e_8_1) { e_8 = { error: e_8_1 }; }
    finally {
        try {
            if (points_4_1 && !points_4_1.done && (_a = points_4.return)) _a.call(points_4);
        }
        finally { if (e_8) throw e_8.error; }
    }
    return model.getGeom().mergePoints(points)[0];
}
//  ===============================================================================================================
//  Groups ==============================================================================================
//  ===============================================================================================================
/**
 * Add points to a group.
 *
 * @param points List of points to add.
 * @param group_name Name of group to add to.
 * @returns True if all points were successfully added.
 */
function addToGroup(points, group_name) {
    var e_9, _a;
    if (!Array.isArray(points)) {
        points = [points];
    }
    var model = _error_msgs_dev__WEBPACK_IMPORTED_MODULE_1__["checkPointList"](points, 1);
    var group = _error_msgs_dev__WEBPACK_IMPORTED_MODULE_1__["checkGroup"](model, group_name);
    var ok = true;
    try {
        for (var points_5 = __values(points), points_5_1 = points_5.next(); !points_5_1.done; points_5_1 = points_5.next()) {
            var point = points_5_1.value;
            if (!point.exists()) {
                _error_msgs_dev__WEBPACK_IMPORTED_MODULE_1__["pointNotExist"]();
            }
            if (point.getModel() !== model) {
                _error_msgs_dev__WEBPACK_IMPORTED_MODULE_1__["pointInOtherModel"]();
            }
            if (!group.addPoint(point)) {
                ok = false;
            }
        }
    }
    catch (e_9_1) { e_9 = { error: e_9_1 }; }
    finally {
        try {
            if (points_5_1 && !points_5_1.done && (_a = points_5.return)) _a.call(points_5);
        }
        finally { if (e_9) throw e_9.error; }
    }
    return ok;
}
/**
 * Remove points from a group.
 *
 * @param group Name of group to remove from.
 * @param objs List of point to remove.
 * @returns True if all points we successfully removed.
 */
function removeFromGroup(points, group_name) {
    var e_10, _a;
    if (!Array.isArray(points)) {
        points = [points];
    }
    var model = _error_msgs_dev__WEBPACK_IMPORTED_MODULE_1__["checkPointList"](points, 1);
    var group = _error_msgs_dev__WEBPACK_IMPORTED_MODULE_1__["checkGroup"](model, group_name);
    var ok = true;
    try {
        for (var points_6 = __values(points), points_6_1 = points_6.next(); !points_6_1.done; points_6_1 = points_6.next()) {
            var point = points_6_1.value;
            if (!point.exists()) {
                _error_msgs_dev__WEBPACK_IMPORTED_MODULE_1__["pointNotExist"]();
            }
            if (point.getModel() !== model) {
                _error_msgs_dev__WEBPACK_IMPORTED_MODULE_1__["pointInOtherModel"]();
            }
            if (!group.removePoint(point)) {
                ok = false;
            }
        }
    }
    catch (e_10_1) { e_10 = { error: e_10_1 }; }
    finally {
        try {
            if (points_6_1 && !points_6_1.done && (_a = points_6.return)) _a.call(points_6);
        }
        finally { if (e_10) throw e_10.error; }
    }
    return ok;
}


/***/ }),

/***/ "./src/app/core/modules/query.ts":
/*!***************************************!*\
  !*** ./src/app/core/modules/query.ts ***!
  \***************************************/
/*! exports provided: Query */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Query", function() { return Query; });
/**
 * Query functions check if an entity fufils certain conditions.
 */
var __values = (undefined && undefined.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
//  ===============================================================================================================
//  Query Functions ===============================================================================================
//  ===============================================================================================================
/**
 *
 */
var x = "temp";
var Query;
(function (Query) {
    function set(__model__, indices, statement) {
        var e_1, _a, e_2, _b;
        var properties = statement.split('&');
        properties = properties.map(function (prop) {
            var property = prop.trim().substring(1).split('=');
            property[0] = property[0].trim();
            property[1] = property[1].trim();
            property[1] = property[1].substring(1, property[1].length - 1).trim();
            return property;
        });
        try {
            for (var indices_1 = __values(indices), indices_1_1 = indices_1.next(); !indices_1_1.done; indices_1_1 = indices_1.next()) {
                var index = indices_1_1.value;
                if (index > __model__.length) {
                    return;
                }
                try {
                    for (var properties_1 = __values(properties), properties_1_1 = properties_1.next(); !properties_1_1.done; properties_1_1 = properties_1.next()) {
                        var property = properties_1_1.value;
                        __model__[index]["properties"][property[0]] = property[1];
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (properties_1_1 && !properties_1_1.done && (_b = properties_1.return)) _b.call(properties_1);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (indices_1_1 && !indices_1_1.done && (_a = indices_1.return)) _a.call(indices_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    Query.set = set;
    function get(__model__, statement) {
        var property = statement.substring(1);
        if (property.indexOf('==') != -1) {
            property = property.split('==');
            property[0] = property[0].trim();
            property[1] = property[1].trim();
            property[1] = property[1].substring(1, property[1].length - 1).trim();
            var result = [];
            for (var i = 0; i < __model__.length; i++) {
                if (__model__[i]["properties"][property[0]] == property[1]) {
                    result.push(i);
                }
            }
            return result;
        }
        else if (property.indexOf('!=') != -1) {
            property = property.split('!=');
            property[0] = property[0].trim();
            property[1] = property[1].trim();
            property[1] = property[1].substring(1, property[1].length - 1).trim();
            var result = [];
            for (var i = 0; i < __model__.length; i++) {
                if (__model__[i]["properties"][property[0]] != property[1]) {
                    result.push(i);
                }
            }
            return result;
            /*
            } else if (property.indexOf('>=') != -1) {
                property = property.split('>=');
                property[1] =  property[1].substring(1,property[1].length-1)
        
                let result = [];
                
                for (let i = 0; i < __model__.length; i++){
                    if (__model__[i]["properties"][property[0]] >= property[1]){
                        result.push(i)
                    }
                }
                return result
            } else if (property.indexOf('<=') != -1) {
                property = property.split('<=');
                property[1] =  property[1].substring(1,property[1].length-1)
        
                let result = [];
                
                for (let i = 0; i < __model__.length; i++){
                    if (__model__[i]["properties"][property[0]] <= property[1]){
                        result.push(i)
                    }
                }
                return result
            */
        }
    }
    Query.get = get;
})(Query || (Query = {}));


/***/ }),

/***/ "./src/app/core/modules/ray.ts":
/*!*************************************!*\
  !*** ./src/app/core/modules/ray.ts ***!
  \*************************************/
/*! exports provided: Get, Copy, CopyToModel, FromOriginVector */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Get", function() { return Get; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Copy", function() { return Copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CopyToModel", function() { return CopyToModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FromOriginVector", function() { return FromOriginVector; });
/**
 * Rays are a type of object.
 *
 * Rays are imaginary lines that stretch infinitely along an axis and are defined by a single vector.
 */
//  ===============================================================================================================
//  Ray Get =======================================================================================================
//  ===============================================================================================================
/**
 * Gets a ray from the model based on an index number
 * @param model Model to get ray from
 * @param id Index number of ray
 * @returns Ray object if successful
 */
function Get(model, id) {
    // check args
    var obj = model.getGeom().getObj(id);
    if (obj === undefined) {
        return null;
    }
    if (obj.getObjType() !== 1 /* ray */) {
        throw new Error("Object is not a ray. Object type is: " + obj.getObjType());
    }
    // return the ray
    return obj;
}
/**
 * Create a copy of a ray.
 *
 * @param ray The ray to copy.
 * @returns A new ray.
 */
function Copy(ray, copy_attribs) {
    // check args
    if (!ray.exists()) {
        throw new Error("ray has been deleted.");
    }
    // copy and return
    return ray.copy(copy_attribs);
}
/**
 * Copies a ray from one model into another model.
 *
 * @param ray The ray object to copy.
 * @returns The ray object in the model.
 */
function CopyToModel(model, ray) {
    // check args
    if (!ray.exists()) {
        throw new Error("Error: ray has been deleted.");
    }
    // check it is not already in the model
    if (ray.getModel() === model) {
        throw new Error("Error: ray is already in model.");
    }
    // copy circle and return it
    return model.getGeom().copyRayFromModel(ray);
}
//  ===============================================================================================================
//  Ray Constructors ==============================================================================================
//  ===============================================================================================================
/**
 * Creates a ray from an origin point and one direction vector describing its direction
 * @param origin 3D point to use as origin of plane
 * @param vector Direction vector describing direction of ray
 * @returns New ray if successful, null if unsuccessful or on error
 */
function FromOriginVector(origin, vector) {
    // check args
    if (!origin.exists()) {
        throw new Error("Arg origin has been deleted.");
    }
    // create the new ray and return
    return origin.getGeom().addRay(origin, vector);
}
//  ===============================================================================================================
//  Ray Functions =================================================================================================
//  ===============================================================================================================


/***/ }),

/***/ "./src/app/core/modules/split.ts":
/*!***************************************!*\
  !*** ./src/app/core/modules/split.ts ***!
  \***************************************/
/*! exports provided: circleCircle2D, polylinePlane3D, polylinePolyline2D */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "circleCircle2D", function() { return circleCircle2D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "polylinePlane3D", function() { return polylinePlane3D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "polylinePolyline2D", function() { return polylinePolyline2D; });
/* harmony import */ var _libs_threex_threex__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libs/threex/threex */ "./src/app/core/modules/libs/threex/threex.ts");
/* harmony import */ var _libs_conics_circles__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./libs/conics/circles */ "./src/app/core/modules/libs/conics/circles.ts");
/* harmony import */ var _libs_poly_poly__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./libs/poly/poly */ "./src/app/core/modules/libs/poly/poly.ts");
/* harmony import */ var _libs_poly_polylinePlane__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./libs/poly/polylinePlane */ "./src/app/core/modules/libs/poly/polylinePlane.ts");
/* harmony import */ var _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_error_msgs_dev */ "./src/app/core/modules/_error_msgs_dev.ts");
/**
 * Functions for splitting geometric objects that insersect with one another.
 */





//  ===============================================================================================================
//  Split Constructors ============================================================================================
//  ===============================================================================================================
//  ===============================================================================================================
//  Split Functions ===============================================================================================
//  ===============================================================================================================
/**
 * Splits two co-planar circles.
 * If an intersection is found, then new arcs will be generated and the old circles will be deleted.
 * Returns null if circles are not co-planar.
 * Returns null if circles do not intersect.
 *
 * @param circle1 Circle object, the circle to split.
 * @param circle2 Circle object.
 * @returns Four circle objects (arcs) if successful, null if no intersection was found.
 */
function circleCircle2D(circle1, circle2) {
    var model = _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkObjList"]([circle1, circle2], 2, 3 /* circle */);
    var geom = model.getGeom();
    // do intersection
    var points = _libs_conics_circles__WEBPACK_IMPORTED_MODULE_1__["isectCircleCircle2D"](circle1, circle2);
    if (points === null) {
        return null;
    }
    if (points.length !== 2) {
        return null;
    }
    var circle1_origin = circle1.getOrigin();
    var circle2_origin = circle2.getOrigin();
    // get the 2 intersection points in the right order
    var order_pt0 = _libs_threex_threex__WEBPACK_IMPORTED_MODULE_0__["vectorFromPointsAtoB"](circle1_origin, points[0]);
    var order_pt1 = _libs_threex_threex__WEBPACK_IMPORTED_MODULE_0__["vectorFromPointsAtoB"](circle1_origin, points[1]);
    var angle_check = order_pt0.angleTo(order_pt1) * 180 / Math.PI;
    if (angle_check > 180) {
        points = [points[1], points[0]];
    }
    // arc 1 vectors
    var vec1_x = _libs_threex_threex__WEBPACK_IMPORTED_MODULE_0__["vectorFromPointsAtoB"](circle1_origin, points[1]);
    var vec1_2nd_x = _libs_threex_threex__WEBPACK_IMPORTED_MODULE_0__["vectorFromPointsAtoB"](circle1_origin, points[0]);
    var vec1_y = (_libs_threex_threex__WEBPACK_IMPORTED_MODULE_0__["orthoVectors"](vec1_x, vec1_2nd_x).normalize())
        .multiplyScalar(vec1_x.length());
    var vec1_2nd_y = _libs_threex_threex__WEBPACK_IMPORTED_MODULE_0__["orthoVectors"](vec1_2nd_x, vec1_x).normalize()
        .multiplyScalar(-vec1_2nd_x.length());
    // arc 1 angle
    var angle1 = vec1_x.angleTo(vec1_2nd_x) * 180 / Math.PI;
    // arc 1 a
    var vec1_x_xyz = vec1_x.toArray();
    var vec1_y_xyz = vec1_y.toArray();
    var arc1_a = geom.addCircle(circle1_origin, vec1_x_xyz, vec1_y_xyz, [0, angle1]);
    // arc 1 b
    var vec1_2nd_x_xyz = vec1_2nd_x.toArray();
    var vec1_2nd_y_xyz = vec1_2nd_y.toArray();
    var arc1_b = geom.addCircle(circle1_origin, vec1_2nd_x_xyz, vec1_2nd_y_xyz, [0, (360 - angle1)]);
    // arc 2 vectors
    var vec2_x = _libs_threex_threex__WEBPACK_IMPORTED_MODULE_0__["vectorFromPointsAtoB"](circle2_origin, points[0]);
    var vec2_2nd_x = _libs_threex_threex__WEBPACK_IMPORTED_MODULE_0__["vectorFromPointsAtoB"](circle2_origin, points[1]);
    var vec2_y = (_libs_threex_threex__WEBPACK_IMPORTED_MODULE_0__["orthoVectors"](vec2_x, vec2_2nd_x).normalize())
        .multiplyScalar(vec2_x.length());
    var vec2_2nd_y = (_libs_threex_threex__WEBPACK_IMPORTED_MODULE_0__["orthoVectors"](vec2_2nd_x, vec2_x).normalize())
        .multiplyScalar(-vec2_x.length());
    // arc 2 angle
    var angle2 = vec2_x.angleTo(vec2_2nd_x) * 180 / Math.PI;
    // arc 2 a
    var vec2_x_xyz = vec2_x.toArray();
    var vec2_y_xyz = vec2_y.toArray();
    var arc2_a = geom.addCircle(circle2_origin, vec2_x_xyz, vec2_y_xyz, [0, angle2]);
    // arc 2 b
    var vec2_2nd_x_xyz = vec2_2nd_x.toArray();
    var vec2_2nd_y_xyz = vec2_2nd_y.toArray();
    var arc2_b = geom.addCircle(circle2_origin, vec2_2nd_x_xyz, vec2_2nd_y_xyz, [0, (360 - angle2)]);
    // delete the old circles
    geom.delObj(circle1, false);
    geom.delObj(circle2, false);
    // return arcs
    return [arc1_b, arc1_a, arc2_a, arc2_b];
}
/**
 * Splits a polyine by a plane.
 * If intersection are found, then new polylines will be generated and the old polyline will be deleted.
 * If no intersections are found, then null is return and the old polyline remains unchanged.
 *
 * @param pline Polyline
 * @param plane Plane
 * @returns List of polylines.
 */
function polylinePlane3D(pline, plane) {
    var model = _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkObj"](pline, 100 /* polyline */);
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkObj"](plane, 2 /* plane */);
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkObjsSameModel"]([pline, plane]);
    var result = _libs_poly_polylinePlane__WEBPACK_IMPORTED_MODULE_3__["splitPolylinePlane3D"](pline, plane);
    if (result !== null) {
        model.getGeom().delObj(pline, false);
    }
    return result;
}
/**
 * Finds the intersection points between two coplanar polylines, and splits the polylines at those points.
 * If intersections are found, then new polylines will be generated and the old polyline will be deleted.
 * If no intersections are found, then null is return and the old polyline remains unchanged.
 *
 * @param pline1 The first polyline.
 * @param pline2 The second polylne.
 * @returns List of list of polylines. The first list containts the pieces from the first polyline.
 * The secbd list, the pieces from the second polyline.
 */
function polylinePolyline2D(pline1, pline2) {
    _error_msgs_dev__WEBPACK_IMPORTED_MODULE_4__["checkObjList"]([pline1, pline2], 2, 100 /* polyline */);
    return _libs_poly_poly__WEBPACK_IMPORTED_MODULE_2__["_splitPolylinePolyline2D"](pline1, pline2);
}


/***/ }),

/***/ "./src/app/core/modules/string.ts":
/*!****************************************!*\
  !*** ./src/app/core/modules/string.ts ***!
  \****************************************/
/*! exports provided: startsWith, endsWith, includes, len, replace, search, split, substring */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "startsWith", function() { return startsWith; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "endsWith", function() { return endsWith; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "includes", function() { return includes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "replace", function() { return replace; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "search", function() { return search; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "split", function() { return split; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "substring", function() { return substring; });
/**
 * The <i>String</i> module provides a set of functions for working with strings.
 * Strings are a data type for representing text, consisting of a sequence of characters.<br/>
 *
 * When instantiating a string, use double quotes as follows: <code>"This is some text."</code>.<br/>
 *
 * Regular expressions can be used to search for character matches in strings.
 */
//  ===============================================================================================================
//  String functions ==============================================================================================
//  ===============================================================================================================
/**
 * Checks if a string starts with the specified start string.
 *
 * @param str String to check.
 * @param start_str Start tring.
 * @returns True if str starts with search_str, false otherwise.
 *
 * <h3>Example:</h3>
 * <code>
 * string = "Orange"<br/>
 * result = String.startsWith(string,"Or")<br/>
 * </code>
 * <br/>Expected value of result is true.
 */
function startsWith(str, start_str) {
    if (str === undefined) {
        throw new Error("Invalid arg: str must be defined.");
    }
    if (start_str === undefined) {
        throw new Error("Invalid arg: start_str must be defined.");
    }
    return str.startsWith(start_str);
}
/**
 * Checks if a string ends with a specified end string.
 *
 * @param str String to check.
 * @param end_str End string.
 * @returns True if str ends with search_str, false otherwise.
 *
 * <h3>Example:</h3>
 * <code>string = "Orange"<br/>
 * result = String.endsWith(string,"ge")<br/></code>
 * <br/>Expected value of result is true.
 */
function endsWith(str, end_str) {
    if (str === undefined) {
        throw new Error("Invalid arg: str must be defined.");
    }
    if (end_str === undefined) {
        throw new Error("Invalid arg: end_str must be defined.");
    }
    return str.endsWith(end_str);
}
/**
 * Checks if a string contains a specified search string.
 *
 * @param str String to search.
 * @param search_str Sub-string to search for.
 * @returns True if str contains search_str, false otherwise.
 *
 * <h3>Example:</h3>
 * <code>string = "Orange"<br/>
 * incl = String.includes(string,"an")<br/></code>
 * <br/>Expected value of incl is true.
 */
function includes(str, search_str) {
    if (str === undefined) {
        throw new Error("Invalid arg: str must be defined.");
    }
    if (search_str === undefined) {
        throw new Error("Invalid arg: search_str must be defined.");
    }
    return str.includes(search_str);
}
/**
 * Returns the number of characters in a string.
 *
 * @param str String to find length of.
 * @returns Length of string.
 *
 * <h3>Example:</h3>
 * <code>string = "Orange"<br/>
 * length = String.len(string)<br/></code>
 * <br/>Expected value of length is 6.
 */
function len(str) {
    if (str === undefined) {
        throw new Error("Invalid arg: str must be defined.");
    }
    return str.length;
}
/**
 * Searches for and replaces the specified search string in a string.
 * The search string can also be a regular expression.
 *
 * @param str String.
 * @param search_str Sub-string or regular expression to search for.
 * @param new_str Replacement string.
 * @returns New string with replaced characters.
 *
 * <h3>Example:</h3>
 * <code>string = "Orange"<br/>
 * newString = String.Replace(string,"O","Ar")<br/></code>
 * <br/>Expected value of newString is "Arrange".
 */
function replace(str, search_str, new_str) {
    if (str === undefined) {
        throw new Error("Invalid arg: str must be defined.");
    }
    if (search_str === undefined) {
        throw new Error("Invalid arg: search_str must be defined.");
    }
    if (new_str === undefined) {
        throw new Error("Invalid arg: new_str must be defined.");
    }
    return str.replace(search_str, new_str);
}
/**
 * Returns the position index of the first occurance of the specified search string within a string.
 * If the specified sub-string cannot be found, then returns -1.
 *
 * @param str String to check.
 * @param search_str Sub-string or regular expression to search for.
 * @returns Number that represents position of search_str in str.
 *
 * <h3>Example:</h3>
 * <code>string = "Orange"<br/>
 * search = String.search(string,"e")<br/></code>
 * <br/>Expected value of search is 5.
 */
function search(str, search_str) {
    if (str === undefined) {
        throw new Error("Invalid arg: str must be defined.");
    }
    if (search_str === undefined) {
        throw new Error("Invalid arg: search_str must be defined.");
    }
    return str.search(search_str);
}
/**
 * Splits a string into a list of substrings using a specified separator string.
 *
 * @param str String.
 * @param separator String of characters used to split string.
 * @returns List of substrings.
 *
 * <h3>Example:</h3>
 * <code>string = "Orange"<br/>
 * split = String.split(string,"a")<br/></code>
 * <br/>Expected value of split is ["Or","nge"].
 */
function split(str, separator) {
    if (str === undefined) {
        throw new Error("Invalid arg: str must be defined.");
    }
    if (separator === undefined) {
        throw new Error("Invalid arg: separator must be defined.");
    }
    return str.split(separator);
}
/**
 * Extracts characters in a string between two specified indices and returns it as a new string.
 * Start index is inclusive and end index is exclusive.
 *
 * @param str String.
 * @param start Zero-based index to start extracting characters (inclusive).
 * @param end Zero-based index to stop extracting characters (exclusive).
 * @returns New string with extracted characters.
 *
 * <h3>Example:</h3>
 * <code>string = "Orange"<br/>
 * substring = String.substring(string,1,4)<br/></code>
 * <br/>Expected value of ends is "ran".
 */
function substring(str, start, end) {
    if (str === undefined) {
        throw new Error("Invalid arg: str must be defined.");
    }
    return str.substring(start, end);
}


/***/ }),

/***/ "./src/app/core/modules/topo.ts":
/*!**************************************!*\
  !*** ./src/app/core/modules/topo.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Topology are sub-components within each object that are connected together.<br/>
 * Topology consists of vertices, edges, wires and faces.<br/>
 */
//  ===============================================================================================================
//  Topo Constructors =============================================================================================
//  ===============================================================================================================
//  ===============================================================================================================
//  Topo Functions ================================================================================================
//  ===============================================================================================================
/**
 *
 */
var x = "temp";


/***/ }),

/***/ "./src/app/core/services/data.service.ts":
/*!***********************************************!*\
  !*** ./src/app/core/services/data.service.ts ***!
  \***********************************************/
/*! exports provided: DataService */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataService", function() { return DataService; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var _models_flowchart__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @models/flowchart */ "./src/app/shared/models/flowchart/index.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


var DataService = /** @class */ (function () {
    function DataService() {
    }
    DataService_1 = DataService;
    Object.defineProperty(DataService.prototype, "file", {
        get: function () { return DataService_1._data; },
        set: function (data) {
            DataService_1._data = {
                name: data.name,
                author: data.author,
                flowchart: data.flowchart,
                last_updated: data.last_updated,
                version: data.version
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DataService.prototype, "flowchart", {
        get: function () { return DataService_1._data.flowchart; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DataService.prototype, "node", {
        get: function () { return DataService_1._data.flowchart.nodes[DataService_1._selected]; },
        enumerable: true,
        configurable: true
    });
    ;
    var DataService_1;
    DataService._data = {
        name: "default_file",
        author: "new_user",
        last_updated: new Date(),
        version: 1,
        flowchart: _models_flowchart__WEBPACK_IMPORTED_MODULE_1__["FlowchartUtils"].newflowchart()
    };
    DataService._selected = 0;
    DataService = DataService_1 = __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Injectable"])()
    ], DataService);
    return DataService;
}());



/***/ }),

/***/ "./src/app/core/services/index.ts":
/*!****************************************!*\
  !*** ./src/app/core/services/index.ts ***!
  \****************************************/
/*! exports provided: DataService, ViewerService */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _data_service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./data.service */ "./src/app/core/services/data.service.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DataService", function() { return _data_service__WEBPACK_IMPORTED_MODULE_0__["DataService"]; });

/* harmony import */ var _viewer_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./viewer.service */ "./src/app/core/services/viewer.service.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ViewerService", function() { return _viewer_service__WEBPACK_IMPORTED_MODULE_1__["ViewerService"]; });





/***/ }),

/***/ "./src/app/core/services/viewer.service.ts":
/*!*************************************************!*\
  !*** ./src/app/core/services/viewer.service.ts ***!
  \*************************************************/
/*! exports provided: ViewerService */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ViewerService", function() { return ViewerService; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm5/index.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


var ViewerService = /** @class */ (function () {
    function ViewerService() {
        this.contextReceivedSource = new rxjs__WEBPACK_IMPORTED_MODULE_1__["Subject"]();
        this.contextReceived$ = this.contextReceivedSource.asObservable();
    }
    ViewerService.prototype.receiveContext = function (componentFactoryResolver, injector) {
        this.contextReceivedSource.next({ resolver: componentFactoryResolver, injector: injector });
    };
    ViewerService = __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Injectable"])()
    ], ViewerService);
    return ViewerService;
}());



/***/ }),

/***/ "./src/app/mViewer/mobius-viewer.component.html":
/*!******************************************************!*\
  !*** ./src/app/mViewer/mobius-viewer.component.html ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<div class='viewer-container'>  \r\n    <div class='container__header'>\r\n        <div class=\"tab\">\r\n            <button class='btn-tab' \r\n            [class.active]='view.name == activeView.name'\r\n            *ngFor='let view of Viewers;' \r\n            (click)='updateView(view)'>\r\n            {{view.name}}\r\n            </button>\r\n        </div>\r\n    </div>\r\n\r\n    <ng-container #vc></ng-container>\r\n</div>"

/***/ }),

/***/ "./src/app/mViewer/mobius-viewer.component.scss":
/*!******************************************************!*\
  !*** ./src/app/mViewer/mobius-viewer.component.scss ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ".viewer-container {\n  height: 100%; }\n\n.container__header {\n  flex: 0 1 auto;\n  min-height: 35px;\n  display: flex;\n  flex-direction: row;\n  justify-content: space-between;\n  padding: 0px 0px 0px 15px;\n  background-color: #ccc;\n  border-bottom: 3px solid #eeeeee;\n  line-height: 35px;\n  font-size: 18px;\n  font-weight: 600;\n  text-align: center; }\n\nbutton.btn {\n  margin: 10px;\n  font-size: 14px;\n  line-height: 18px;\n  border: 2px solid gray;\n  border-radius: 4px;\n  padding: 2px 10px;\n  background-color: transparent;\n  color: #505050; }\n\nbutton.btn:hover {\n  color: blue; }\n\n/* tab styling */\n\n.tab {\n  border: 2px;\n  overflow: hidden;\n  background-color: #ccc; }\n\n.tab button {\n  display: inline-block;\n  vertical-align: bottom;\n  background-color: inherit;\n  color: #505050;\n  border: none;\n  outline: none;\n  cursor: pointer;\n  padding: 8px 10px;\n  transition: 0.3s;\n  font-size: 14px; }\n\n.tab button:hover {\n  color: blue; }\n\n.tab button.active {\n  background-color: #ccc;\n  color: #000096;\n  font-weight: 600;\n  border-color: #222 !important; }\n"

/***/ }),

/***/ "./src/app/mViewer/mobius-viewer.component.ts":
/*!****************************************************!*\
  !*** ./src/app/mViewer/mobius-viewer.component.ts ***!
  \****************************************************/
/*! exports provided: ViewerContainerComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ViewerContainerComponent", function() { return ViewerContainerComponent; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var _viewers_config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./viewers.config */ "./src/app/mViewer/viewers.config.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __values = (undefined && undefined.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};


var ViewerContainerComponent = /** @class */ (function () {
    function ViewerContainerComponent(injector, r) {
        this.injector = injector;
        this.r = r;
        this.views = [];
        this.Viewers = _viewers_config__WEBPACK_IMPORTED_MODULE_1__["Viewers"];
    }
    ViewerContainerComponent.prototype.ngOnInit = function () {
        this.activeView = this.Viewers[0];
        this.updateView(this.activeView);
    };
    ViewerContainerComponent.prototype.ngOnDestroy = function () {
        var e_1, _a;
        console.log('onDestroy');
        try {
            for (var _b = __values(this.views), _c = _b.next(); !_c.done; _c = _b.next()) {
                var view = _c.value;
                view.destroy();
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    ViewerContainerComponent.prototype.ngOnChanges = function () {
        this.updateValue();
    };
    ViewerContainerComponent.prototype.createView = function (view) {
        var component = view.component;
        var factory = this.r.resolveComponentFactory(component);
        var componentRef = factory.create(this.injector);
        componentRef.instance["node"] = this.node;
        if (view.name == 'mobius-cesium') {
            componentRef.instance["mode"] = 'editor';
        }
        return componentRef;
    };
    ViewerContainerComponent.prototype.updateView = function (view) {
        this.activeView = view;
        if (this.views[this.activeView.name] == undefined) {
            this.views[this.activeView.name] = this.createView(view);
        }
        else {
            this.updateValue();
        }
        this.vc.detach();
        this.vc.insert(this.views[this.activeView.name].hostView);
    };
    ViewerContainerComponent.prototype.updateValue = function () {
        try {
            var componentRef = this.views[this.activeView.name];
            componentRef.instance["node"] = this.node;
        }
        catch (ex) {
            console.log("Active View not defined");
        }
    };
    __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"])('vc', { read: _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewContainerRef"] }),
        __metadata("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewContainerRef"])
    ], ViewerContainerComponent.prototype, "vc", void 0);
    __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(),
        __metadata("design:type", Object)
    ], ViewerContainerComponent.prototype, "node", void 0);
    ViewerContainerComponent = __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"])({
            selector: 'mviewer',
            template: __webpack_require__(/*! ./mobius-viewer.component.html */ "./src/app/mViewer/mobius-viewer.component.html"),
            styles: [__webpack_require__(/*! ./mobius-viewer.component.scss */ "./src/app/mViewer/mobius-viewer.component.scss")]
        }),
        __metadata("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_0__["Injector"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["ComponentFactoryResolver"]])
    ], ViewerContainerComponent);
    return ViewerContainerComponent;
}());



/***/ }),

/***/ "./src/app/mViewer/mobius-viewer.module.ts":
/*!*************************************************!*\
  !*** ./src/app/mViewer/mobius-viewer.module.ts ***!
  \*************************************************/
/*! exports provided: MobiusViewerModule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MobiusViewerModule", function() { return MobiusViewerModule; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm5/common.js");
/* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/forms */ "./node_modules/@angular/forms/fesm5/forms.js");
/* harmony import */ var _mobius_viewer_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mobius-viewer.component */ "./src/app/mViewer/mobius-viewer.component.ts");
/* harmony import */ var _viewers_config__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./viewers.config */ "./src/app/mViewer/viewers.config.ts");
/* harmony import */ var _viewers_gs_viewer_gs_viewer_module__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./viewers/gs-viewer/gs-viewer.module */ "./src/app/mViewer/viewers/gs-viewer/gs-viewer.module.ts");
/* harmony import */ var _viewers_mobius_cesium_mobius_cesium_module__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./viewers/mobius-cesium/mobius-cesium.module */ "./src/app/mViewer/viewers/mobius-cesium/mobius-cesium.module.ts");
/* harmony import */ var _viewers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./viewers */ "./src/app/mViewer/viewers/index.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (undefined && undefined.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};









//import { VisualiseComponent } from "./viewers/mobius-cesium/setting/visualise.component";
//import { AttributesComponent } from "./viewers/mobius-cesium/setting/attributes.copmponent";
var MobiusViewerModule = /** @class */ (function () {
    function MobiusViewerModule() {
    }
    MobiusViewerModule = __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"])({
            declarations: [
                _mobius_viewer_component__WEBPACK_IMPORTED_MODULE_3__["ViewerContainerComponent"],
                _viewers__WEBPACK_IMPORTED_MODULE_7__["TextViewerComponent"],
                _viewers__WEBPACK_IMPORTED_MODULE_7__["ConsoleViewerComponent"],
            ],
            exports: [_mobius_viewer_component__WEBPACK_IMPORTED_MODULE_3__["ViewerContainerComponent"]],
            imports: [_angular_common__WEBPACK_IMPORTED_MODULE_1__["CommonModule"],
                _angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormsModule"],
                _viewers_gs_viewer_gs_viewer_module__WEBPACK_IMPORTED_MODULE_5__["GSViewer"],
                _viewers_mobius_cesium_mobius_cesium_module__WEBPACK_IMPORTED_MODULE_6__["MobiusCesium"],
            ],
            entryComponents: __spread(_viewers_config__WEBPACK_IMPORTED_MODULE_4__["VIEWER_ARR"]),
            providers: []
        }),
        __metadata("design:paramtypes", [])
    ], MobiusViewerModule);
    return MobiusViewerModule;
}());



/***/ }),

/***/ "./src/app/mViewer/viewers.config.ts":
/*!*******************************************!*\
  !*** ./src/app/mViewer/viewers.config.ts ***!
  \*******************************************/
/*! exports provided: VIEWER_ARR, Viewers */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VIEWER_ARR", function() { return VIEWER_ARR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Viewers", function() { return Viewers; });
/* harmony import */ var _viewers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./viewers */ "./src/app/mViewer/viewers/index.ts");
/* harmony import */ var _viewers_gs_viewer_gs_viewer_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./viewers/gs-viewer/gs-viewer.component */ "./src/app/mViewer/viewers/gs-viewer/gs-viewer.component.ts");
/* harmony import */ var _viewers_console_viewer_component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./viewers/console-viewer.component */ "./src/app/mViewer/viewers/console-viewer.component.ts");
// Step-1: Add new ViewerComponet here



var VIEWER_ARR = [
    _viewers__WEBPACK_IMPORTED_MODULE_0__["TextViewerComponent"],
    _viewers_console_viewer_component__WEBPACK_IMPORTED_MODULE_2__["ConsoleViewerComponent"],
    //JSONViewerComponent, 
    //ThreeViewerComponent
    // Step-2: Add Component here
    //CesiumViewerComponent,
    _viewers_gs_viewer_gs_viewer_component__WEBPACK_IMPORTED_MODULE_1__["GSViewerComponent"],
];
var Viewers = [
    { name: 'Summary', icon: undefined, component: _viewers__WEBPACK_IMPORTED_MODULE_0__["TextViewerComponent"] },
    { name: 'gs-viewer', icon: undefined, component: _viewers_gs_viewer_gs_viewer_component__WEBPACK_IMPORTED_MODULE_1__["GSViewerComponent"] },
    { name: 'Console', icon: undefined, component: _viewers_console_viewer_component__WEBPACK_IMPORTED_MODULE_2__["ConsoleViewerComponent"] },
];


/***/ }),

/***/ "./src/app/mViewer/viewers/console-viewer.component.ts":
/*!*************************************************************!*\
  !*** ./src/app/mViewer/viewers/console-viewer.component.ts ***!
  \*************************************************************/
/*! exports provided: ConsoleViewerComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConsoleViewerComponent", function() { return ConsoleViewerComponent; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

var ConsoleViewerComponent = /** @class */ (function () {
    function ConsoleViewerComponent() {
        console.log("Console Viewer Created");
        this.consoleText = console.log.bind(console);
    }
    __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(),
        __metadata("design:type", Object)
    ], ConsoleViewerComponent.prototype, "node", void 0);
    ConsoleViewerComponent = __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"])({
            selector: 'console-viewer',
            template: "<h3></h3>\n             <div>{{ consoleText || \"\" }}</div>",
            styles: []
        }),
        __metadata("design:paramtypes", [])
    ], ConsoleViewerComponent);
    return ConsoleViewerComponent;
}());



/***/ }),

/***/ "./src/app/mViewer/viewers/gs-viewer/data/DataSubscriber.ts":
/*!******************************************************************!*\
  !*** ./src/app/mViewer/viewers/gs-viewer/data/DataSubscriber.ts ***!
  \******************************************************************/
/*! exports provided: DataSubscriber */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataSubscriber", function() { return DataSubscriber; });
/* harmony import */ var _data_service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./data.service */ "./src/app/mViewer/viewers/gs-viewer/data/data.service.ts");

var DataSubscriber = /** @class */ (function () {
    function DataSubscriber(injector) {
        var _this = this;
        this.dataService = injector.get(_data_service__WEBPACK_IMPORTED_MODULE_0__["DataService"]);
        this._subscription = this.dataService.getMessage().subscribe(function (message) {
            _this._message = message;
            _this.notify(message.text);
        });
    }
    DataSubscriber.prototype.notify = function (message) {
        console.warn("Notify function not Implemented");
    };
    return DataSubscriber;
}());



/***/ }),

/***/ "./src/app/mViewer/viewers/gs-viewer/data/data.service.ts":
/*!****************************************************************!*\
  !*** ./src/app/mViewer/viewers/gs-viewer/data/data.service.ts ***!
  \****************************************************************/
/*! exports provided: DataService */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataService", function() { return DataService; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var rxjs_Subject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rxjs/Subject */ "./node_modules/rxjs-compat/_esm5/Subject.js");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var gs_json__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! gs-json */ "./node_modules/gs-json/dist2015/index.js");
/* harmony import */ var gs_json__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(gs_json__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var three_orbit_controls__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three-orbit-controls */ "./node_modules/three-orbit-controls/index.js");
/* harmony import */ var three_orbit_controls__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(three_orbit_controls__WEBPACK_IMPORTED_MODULE_4__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





var DataService = /** @class */ (function () {
    function DataService() {
        // intializations
        // this only runs once
        this.selecting = [];
        this.grid = true;
        this.scenechildren = [];
        this.textlabels = [];
        this.point = true;
        this.click = false;
        this.checkpointid = false;
        this.checkedgeid = false;
        this.imVisible = false;
        // ---- 
        // Subscription Handling
        // 
        this.subject = new rxjs_Subject__WEBPACK_IMPORTED_MODULE_1__["Subject"]();
        var default_width = 1510, default_height = 720;
        // scene
        var scene = new three__WEBPACK_IMPORTED_MODULE_2__["Scene"]();
        scene.background = new three__WEBPACK_IMPORTED_MODULE_2__["Color"](0xcccccc);
        // renderer
        var renderer = new three__WEBPACK_IMPORTED_MODULE_2__["WebGLRenderer"]({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        // camera settings
        var aspect_ratio = this._width / this._height;
        var camera = new three__WEBPACK_IMPORTED_MODULE_2__["PerspectiveCamera"](50, aspect_ratio, 0.01, 1000); //0.0001, 100000000 );
        camera.position.y = 10;
        camera.up.set(0, 0, 1);
        camera.lookAt(scene.position);
        camera.updateProjectionMatrix();
        // orbit controls
        var _OC = three_orbit_controls__WEBPACK_IMPORTED_MODULE_4__(three__WEBPACK_IMPORTED_MODULE_2__);
        var controls = new _OC(camera, renderer.domElement);
        controls.enableKeys = false;
        // default directional lighting
        var directional_light = new three__WEBPACK_IMPORTED_MODULE_2__["DirectionalLight"](0xffffff, 0.5);
        directional_light.castShadow = false;
        directional_light.position.copy(camera.position);
        controls.addEventListener('change', function () {
            directional_light.position.copy(camera.position);
        });
        directional_light.target.position.set(0, 0, 0);
        scene.add(directional_light);
        // default ambient lighting
        var default_hue = 0;
        var default_saturation = 0.01;
        var default_lightness = 0.47;
        var hemi_light = new three__WEBPACK_IMPORTED_MODULE_2__["HemisphereLight"](0xffffff, 0.5);
        hemi_light.color.setHSL(default_hue, default_saturation, default_lightness);
        scene.add(hemi_light);
        this._scene = scene;
        this._renderer = renderer;
        this._camera = camera;
        this._orbitControls = controls;
        // add it to alight - what does alight do?
        this._alight = hemi_light;
        //this._alight.push(hemi_light);
        this.checkname = [];
        this.pointname = [];
    }
    DataService.prototype.sendMessage = function (message) {
        this.subject.next({ text: message });
    };
    DataService.prototype.clearMessage = function () {
        this.subject.next();
    };
    DataService.prototype.getMessage = function () {
        return this.subject.asObservable();
    };
    //
    //  Getter and Setting for gs-model
    //
    DataService.prototype.getGsModel = function () {
        return this._gsModel;
    };
    DataService.prototype.setGsModel = function (model) {
        this._gsModel = model;
        if (this._gsModel !== undefined) {
            this.generateSceneMaps();
        }
        else {
            // remove all children from the scene
            for (var i = 0; i < this._scene.children.length; i++) {
                if (this._scene.children[i].type === "Scene") {
                    this._scene.remove(this._scene.children[i]);
                }
            }
        }
        this.sendMessage("model_update");
    };
    DataService.prototype.generateSceneMaps = function () {
        var scene_and_maps = gs_json__WEBPACK_IMPORTED_MODULE_3__["genThreeOptModelAndMaps"](this._gsModel);
        this.scenemaps = scene_and_maps;
    };
    DataService.prototype.getscememaps = function () {
        return this.scenemaps;
    };
    DataService.prototype.getScene = function (width, height) {
        if (width && height) {
            this._width = width;
            this._height = height;
        }
        return this._scene;
    };
    DataService.prototype.getRenderer = function () {
        this._camera.aspect = this._width / this._height;
        this._camera.updateProjectionMatrix();
        this._renderer.setSize(this._width, this._height);
        return this._renderer;
    };
    DataService.prototype.getCamera = function () {
        return this._camera;
    };
    DataService.prototype.getControls = function () {
        return this._orbitControls;
    };
    //
    //
    //
    DataService.prototype.getalight = function () {
        return this._alight;
    };
    DataService.prototype.addraycaster = function (raycaster) {
        this.raycaster = raycaster;
    };
    DataService.prototype.getraycaster = function () {
        return this.raycaster;
    };
    DataService.prototype.gethue = function (_hue) {
        this.hue = _hue;
    };
    DataService.prototype.getsaturation = function (_saturation) {
        this.saturation = _saturation;
    };
    DataService.prototype.getlightness = function (_lightness) {
        this.lightness = _lightness;
    };
    DataService.prototype.getpointsize = function (pointszie) {
        this.pointsize = pointszie;
    };
    DataService.prototype.getmaterialpoint = function (materialpoint) {
        this.materialpoint = materialpoint;
    };
    DataService.prototype.getradius = function (point) {
        this.pointradius = point;
    };
    DataService.prototype.getcenterx = function (centerx) {
        this.centerx = centerx;
    };
    DataService.prototype.getcentery = function (centery) {
        this.centery = centery;
    };
    DataService.prototype.getcenterz = function (centerz) {
        this.centerz = centerz;
    };
    DataService.prototype.getcentersize = function (centersize) {
        this.centersize = centersize;
    };
    DataService.prototype.addGeom = function (Geom) {
        this._Geom = Geom;
    };
    DataService.prototype.getGeom = function () {
        return this._Geom;
    };
    DataService.prototype.addscenechange = function (scenechange) {
        this.scenechange = scenechange;
    };
    DataService.prototype.getscenechange = function () {
        return this.scenechange;
    };
    DataService.prototype.addINTERSECTEDColor = function (INTERSECTEDColor) {
        if (this.INTERSECTEDColor == null) {
            this.INTERSECTEDColor = INTERSECTEDColor;
        }
    };
    DataService.prototype.getINTERSECTEDColor = function () {
        return this.INTERSECTEDColor;
    };
    DataService.prototype.addselecting = function (selecting) {
        if (selecting[selecting.length - 1] == undefined) {
            this.selecting = [];
        }
        this.sendMessage();
    };
    DataService.prototype.pushselecting = function (selecting) {
        this.selecting.push(selecting);
        this.sendMessage();
    };
    DataService.prototype.spliceselecting = function (index, number) {
        this.selecting.splice(index, number);
        this.sendMessage();
    };
    DataService.prototype.getselecting = function () {
        return this.selecting;
    };
    DataService.prototype.addclickshow = function (clickshow) {
        this.clickshow = clickshow;
    };
    DataService.prototype.addattrvertix = function (attributevertix) {
        this.attributevertix = attributevertix;
    };
    DataService.prototype.getattrvertix = function () {
        return this.attributevertix;
    };
    DataService.prototype.addgrid = function (grid) {
        this.grid = grid;
    };
    DataService.prototype.addaxis = function (axis) {
        this.axis = axis;
    };
    DataService.prototype.addshadow = function (shadow) {
        this.shadow = shadow;
    };
    DataService.prototype.addframe = function (frame) {
        this.frame = frame;
    };
    DataService.prototype.addpoint = function (point) {
        this.point = point;
    };
    DataService.prototype.getSelectingIndex = function (uuid) {
        for (var i = 0; i < this.selecting.length; i++) {
            if (this.selecting[i].uuid == uuid) {
                return i;
            }
        }
        return -1;
    };
    DataService.prototype.addscenechild = function (scenechildren) {
        this.scenechildren = scenechildren;
        this.sendMessage();
    };
    DataService.prototype.getscenechild = function () {
        this.sendMessage();
        return this.scenechildren;
    };
    DataService.prototype.addlabel = function (label) {
        this.label = label;
        this.sendMessage();
    };
    DataService.prototype.getlabel = function () {
        this.sendMessage();
        return this.label;
    };
    DataService.prototype.addgetpoints = function (getpoints) {
        this.getpoints = getpoints;
    };
    DataService.prototype.addpointname = function (pointname) {
        this.pointname = pointname;
    };
    DataService = __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Injectable"])(),
        __metadata("design:paramtypes", [])
    ], DataService);
    return DataService;
}());



/***/ }),

/***/ "./src/app/mViewer/viewers/gs-viewer/gs-viewer.component.html":
/*!********************************************************************!*\
  !*** ./src/app/mViewer/viewers/gs-viewer/gs-viewer.component.html ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<div id=\"appdiv\" (mousedown)=\"leaflet()\">\r\n\t<as-split direction=\"vertical\">\r\n\t\t<as-split-area [size]=\"90\" id=\"splitcontainer\">\r\n\t\t  <div style=\"height: 100%\">\r\n\t\t    <as-split direction=\"horizontal\">\r\n\t\t      <as-split-area [size]=\"0.5\" id=\"splitgroups\" style=\"overflow-x:hidden;overflow-y: auto;\">\r\n\t\t        <app-groups></app-groups>\r\n\t\t      </as-split-area>\r\n\t\t      <as-split-area [size]=\"99.5\" id=\"splitviewer\">\r\n\t\t        <!-- <app-viewer *ngIf=\"imVisible===false\"></app-viewer>\r\n\t\t        <app-map *ngIf=\"imVisible===true\"></app-map> -->\r\n\t\t        <app-viewer></app-viewer>\r\n\t\t      </as-split-area>\r\n\t\t    </as-split>\r\n\t\t  </div>\r\n\t\t</as-split-area>\r\n\t\t<as-split-area [size]=\"10\" id=\"splittoolwindow\">\r\n\t\t\t<app-toolwindow></app-toolwindow>\r\n\t\t</as-split-area>\r\n\t</as-split>\r\n</div>"

/***/ }),

/***/ "./src/app/mViewer/viewers/gs-viewer/gs-viewer.component.scss":
/*!********************************************************************!*\
  !*** ./src/app/mViewer/viewers/gs-viewer/gs-viewer.component.scss ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "@import url(\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css\");\n@font-face {\n  font-family: \"FontAwesome\"; }\n.font-awesome-hand {\n  font-family: FontAwesome; }\n.font-awesome-hand::after {\n  font-family: FontAwesome; }\nhtml, body {\n  font-family: 'Open Sans', sans-serif;\n  text-align: justify;\n  margin: 0px;\n  padding: 0px; }\n#appdiv {\n  height: 95%;\n  background-color: white; }\n#splittoolwindow {\n  overflow: scroll !important; }\na {\n  text-decoration: none;\n  color: #fff;\n  text-transform: uppercase; }\n.toolbar {\n  background-color: #333; }\n.toolbar ul {\n  list-style: none;\n  overflow: hidden;\n  margin-bottom: 0px;\n  z-index: 1; }\n.toolbar div > ul > li {\n  display: inline-block;\n  float: left; }\n.toolbar div > ul > li:hover {\n  background-color: #fff; }\n.toolbar div > ul > li:hover a {\n  color: #333; }\n.toolbar div > ul > li > a {\n  font-size: 12px;\n  line-height: 20px;\n  display: block;\n  float: left;\n  padding: 0 16px; }\n/**\r\n * Carets\r\n */\n.toolbar div ul li i.icon-sort {\n  display: none; }\n.toolbar div ul li:hover i.icon-sort {\n  display: inline; }\n.toolbar div ul li:hover i.icon-caret-down {\n  display: none; }\n.toolbar .dropdown i {\n  margin: 0px; }\n.toolbar div > ul > li > a:hover {\n  background-color: #fff;\n  color: #333; }\n.dropdown {\n  float: left; }\n/**\r\n * Sub navigaton\r\n **/\n.sub {\n  min-width: 180px;\n  margin: 20px;\n  display: none;\n  position: absolute;\n  border-left: 1px solid #ebebeb;\n  border-right: 1px solid #ebebeb;\n  border-bottom: 1px solid #ebebeb; }\n.sub li a {\n  display: block;\n  background-color: #fff;\n  color: #333 !important;\n  border-left: 4px solid #fff;\n  padding: 4px 12px;\n  font-size: 12px;\n  line-height: 26px; }\n.sub li a:hover {\n  border-left: 4px solid #ff0000;\n  float: top; }\n.toolbar div > ul > li:hover .sub {\n  display: block; }\n.sub li a {\n  transition: all .5s linear;\n  overflow: hidden; }\n#toolwindow {\n  position: relative;\n  background-color: slategrey; }\n.sidebar {\n  position: absolute;\n  top: 0px;\n  right: 0px;\n  height: 100%; }\n.tool-form {\n  padding-top: 10px;\n  padding-left: 10px;\n  color: white; }\n.tool-form-heading {\n  border-bottom: 2px solid #ddd;\n  margin: 0px;\n  padding-bottom: 3px; }\n.tool-form label {\n  font-family: 'Open Sans', sans-serif;\n  font-size: 13px;\n  color: black;\n  display: block;\n  margin: 0px 0px 15px 0px; }\n.tool-form label > span {\n  width: 150px;\n  font-family: 'Open Sans', sans-serif;\n  font-size: 13px;\n  float: left;\n  padding-top: 4px;\n  padding-right: 5px; }\n.tool-form span.required {\n  color: red; }\n.tool-form .tel-number-field {\n  width: 30px;\n  text-align: center; }\n.tool-form input.input-field {\n  width: 30px; }\n.tool-form input.file-input-field {\n  border: 1px solid #ccc;\n  height: 20px;\n  display: inline-block;\n  padding: 6px 6px;\n  cursor: pointer;\n  background-color: #888888; }\n.tool-form input.input-field,\n.tool-form .tel-number-field,\n.tool-form .textarea-field,\n.tool-form .select-field {\n  height: 20px;\n  overflow: hidden;\n  width: 240px;\n  background-color: #888888;\n  border-radius: 5px;\n  color: #ffffff; }\n.tool-form .input-field:focus,\n.tool-form .tel-number-field:focus,\n.tool-form .textarea-field:focus,\n.tool-form .select-field:focus {\n  border: 1px solid #0C0; }\n.tool-form .textarea-field {\n  height: 100px;\n  width: 55%; }\n.tool-form input[type=submit],\n.tool-form input[type=button] {\n  height: 25px;\n  border: none;\n  padding: 2px 8px 2px 8px;\n  background: #444466;\n  color: #fff;\n  box-shadow: 1px 1px 4px #DADADA;\n  -moz-box-shadow: 1px 1px 4px #DADADA;\n  -webkit-box-shadow: 1px 1px 4px #DADADA;\n  border-radius: 3px;\n  -webkit-border-radius: 3px;\n  -moz-border-radius: 3px;\n  color: #ffffff; }\n.tool-form input[type=submit]:hover,\n.tool-form input[type=button]:hover {\n  background: #333377;\n  color: #fff; }\n.rightstyle {\n  width: 30px;\n  height: 100%;\n  float: right;\n  background: #FFFFFF;\n  background-repeat: repeat;\n  background-attachment: scroll;\n  overflow: auto; }\n.leftstyle {\n  background: #e6e6e6;\n  height: 100%; }\n.slider {\n  width: 0;\n  height: 0;\n  border-top: 30px solid transparent;\n  border-right: 10px solid black;\n  border-bottom: 30px solid transparent; }\n"

/***/ }),

/***/ "./src/app/mViewer/viewers/gs-viewer/gs-viewer.component.ts":
/*!******************************************************************!*\
  !*** ./src/app/mViewer/viewers/gs-viewer/gs-viewer.component.ts ***!
  \******************************************************************/
/*! exports provided: GSViewerComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GSViewerComponent", function() { return GSViewerComponent; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var _data_data_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data/data.service */ "./src/app/mViewer/viewers/gs-viewer/data/data.service.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


var GSViewerComponent = /** @class */ (function () {
    function GSViewerComponent(dataService) {
        this.dataService = dataService;
        this.imVisible = false;
    }
    ;
    GSViewerComponent.prototype.setModel = function (data) {
        try {
            this.dataService.setGsModel(data);
        }
        catch (ex) {
            this.text = '';
            this.data = undefined;
            console.error("Error generating model");
        }
    };
    GSViewerComponent.prototype.ngOnInit = function () {
        if (this.node.type == 'output') {
            this.data = this.node.input.value;
        }
        else {
            this.data = this.node.output.value;
        }
        this.setModel(this.data);
    };
    GSViewerComponent.prototype.ngDoCheck = function () {
        if (!this.node)
            return;
        var val = this.node.output.value;
        if (this.node.type == 'output')
            val = this.node.input.value;
        if (this.data !== val) {
            this.data = val;
            this.setModel(this.data);
        }
    };
    GSViewerComponent.prototype.leaflet = function () {
        this.imVisible = this.dataService.imVisible;
    };
    __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(),
        __metadata("design:type", Object)
    ], GSViewerComponent.prototype, "node", void 0);
    GSViewerComponent = __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"])({
            selector: 'gs-viewer',
            template: __webpack_require__(/*! ./gs-viewer.component.html */ "./src/app/mViewer/viewers/gs-viewer/gs-viewer.component.html"),
            styles: [__webpack_require__(/*! ./gs-viewer.component.scss */ "./src/app/mViewer/viewers/gs-viewer/gs-viewer.component.scss")]
        }),
        __metadata("design:paramtypes", [_data_data_service__WEBPACK_IMPORTED_MODULE_1__["DataService"]])
    ], GSViewerComponent);
    return GSViewerComponent;
}());



/***/ }),

/***/ "./src/app/mViewer/viewers/gs-viewer/gs-viewer.module.ts":
/*!***************************************************************!*\
  !*** ./src/app/mViewer/viewers/gs-viewer/gs-viewer.module.ts ***!
  \***************************************************************/
/*! exports provided: GSViewer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GSViewer", function() { return GSViewer; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm5/common.js");
/* harmony import */ var angular_split__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! angular-split */ "./node_modules/angular-split/fesm5/angular-split.js");
/* harmony import */ var _angular_material_slider__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/material/slider */ "./node_modules/@angular/material/esm5/slider.es5.js");
/* harmony import */ var _gs_viewer_component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./gs-viewer.component */ "./src/app/mViewer/viewers/gs-viewer/gs-viewer.component.ts");
/* harmony import */ var _viewer_viewer_component__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./viewer/viewer.component */ "./src/app/mViewer/viewers/gs-viewer/viewer/viewer.component.ts");
/* harmony import */ var _setting_setting_component__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./setting/setting.component */ "./src/app/mViewer/viewers/gs-viewer/setting/setting.component.ts");
/* harmony import */ var _toolwindow_toolwindow_component__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./toolwindow/toolwindow.component */ "./src/app/mViewer/viewers/gs-viewer/toolwindow/toolwindow.component.ts");
/* harmony import */ var _data_data_service__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./data/data.service */ "./src/app/mViewer/viewers/gs-viewer/data/data.service.ts");
/* harmony import */ var _toolwindow_groups_component__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./toolwindow/groups.component */ "./src/app/mViewer/viewers/gs-viewer/toolwindow/groups.component.ts");
/* harmony import */ var ngx_pagination__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ngx-pagination */ "./node_modules/ngx-pagination/dist/ngx-pagination.js");
/* harmony import */ var _angular_material_expansion__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @angular/material/expansion */ "./node_modules/@angular/material/esm5/expansion.es5.js");
/* harmony import */ var _angular_material_tabs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @angular/material/tabs */ "./node_modules/@angular/material/esm5/tabs.es5.js");
/* harmony import */ var _angular_material_tooltip__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @angular/material/tooltip */ "./node_modules/@angular/material/esm5/tooltip.es5.js");
/* harmony import */ var _angular_material_sort__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @angular/material/sort */ "./node_modules/@angular/material/esm5/sort.es5.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};















var GSViewer = /** @class */ (function () {
    function GSViewer() {
    }
    GSViewer_1 = GSViewer;
    GSViewer.forRoot = function () {
        return {
            ngModule: GSViewer_1,
            providers: [
                _data_data_service__WEBPACK_IMPORTED_MODULE_8__["DataService"]
            ]
        };
    };
    var GSViewer_1;
    GSViewer = GSViewer_1 = __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"])({
            imports: [_angular_common__WEBPACK_IMPORTED_MODULE_1__["CommonModule"],
                angular_split__WEBPACK_IMPORTED_MODULE_2__["AngularSplitModule"],
                _angular_material_slider__WEBPACK_IMPORTED_MODULE_3__["MatSliderModule"],
                ngx_pagination__WEBPACK_IMPORTED_MODULE_10__["NgxPaginationModule"],
                _angular_material_expansion__WEBPACK_IMPORTED_MODULE_11__["MatExpansionModule"],
                _angular_material_tabs__WEBPACK_IMPORTED_MODULE_12__["MatTabsModule"],
                _angular_material_tooltip__WEBPACK_IMPORTED_MODULE_13__["MatTooltipModule"],
                _angular_material_sort__WEBPACK_IMPORTED_MODULE_14__["MatSortModule"]
            ],
            exports: [_gs_viewer_component__WEBPACK_IMPORTED_MODULE_4__["GSViewerComponent"]],
            declarations: [_gs_viewer_component__WEBPACK_IMPORTED_MODULE_4__["GSViewerComponent"],
                _viewer_viewer_component__WEBPACK_IMPORTED_MODULE_5__["ViewerComponent"],
                _setting_setting_component__WEBPACK_IMPORTED_MODULE_6__["SettingComponent"],
                _toolwindow_toolwindow_component__WEBPACK_IMPORTED_MODULE_7__["ToolwindowComponent"],
                _toolwindow_groups_component__WEBPACK_IMPORTED_MODULE_9__["GroupsComponent"]],
            providers: [_data_data_service__WEBPACK_IMPORTED_MODULE_8__["DataService"]],
        })
    ], GSViewer);
    return GSViewer;
}());



/***/ }),

/***/ "./src/app/mViewer/viewers/gs-viewer/setting/setting.component.css":
/*!*************************************************************************!*\
  !*** ./src/app/mViewer/viewers/gs-viewer/setting/setting.component.css ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#settingview{\r\n  position:absolute;\r\n  background-color: white;\r\n  top:0px;\r\n  right:30px;\r\n  color:#395d73;\r\n  width:400px;\r\n  height:430px;\r\n}\r\n#grid{\r\n  margin-left: 20px;\r\n  font-family:sans-serif;\r\n  margin-top:10px;\r\n}\r\n#axis{\r\n  margin-left: 30px;\r\n  font-family:sans-serif;\r\n}\r\n#shadow{\r\n  margin-left: 30px;\r\n  font-family:sans-serif;\r\n}\r\n#frame{\r\n  margin-left: 30px;\r\n  font-family:sans-serif;\r\n}\r\n#nomal{\r\n  margin-left: 20px;\r\n  font-family:sans-serif;\r\n}\r\n#point{\r\n  margin-left: 20px;\r\n  font-family:sans-serif;\r\n}\r\n#huerange{\r\n  margin-left: 41px;\r\n  width: 60%;\r\n  font-family:sans-serif;\r\n}\r\n#satrange{\r\n  margin-left: 18px;\r\n  width: 60%;\r\n  font-family:sans-serif;\r\n}\r\n#lirange{\r\n  margin-left: 20px;\r\n  width: 60%;\r\n  font-family:sans-serif;\r\n}\r\n#oprange{\r\n  margin-left: 20px;\r\n  width: 60%;\r\n  font-family:sans-serif;\r\n}\r\n#name{\r\n  font-family:sans-serif;\r\n}\r\n#redrange{\r\n  margin-left: 60px;\r\n  width: 60%;\r\n  font-family:sans-serif;\r\n}\r\n#greenrange{\r\n  margin-left: 60px;\r\n  width: 60%;\r\n  font-family:sans-serif;\r\n}\r\n#bluerange{\r\n  margin-left: 60px;\r\n  width: 60%;\r\n  font-family:sans-serif;\r\n}\r\n#linerange{\r\n  margin-left: 5px;\r\n  width: 50%;\r\n  font-family:sans-serif;\r\n}\r\n#pointrange{\r\n  margin-left: 3px;\r\n  width: 50%;\r\n  font-family:sans-serif;\r\n}\r\n#sizerange{\r\n  width: 50%;\r\n  font-family:sans-serif;\r\n}\r\n#centerx{\r\n  width:30px;\r\n  margin-left:10px;\r\n}\r\n#centery{\r\n  width:30px;\r\n  margin-left:10px;\r\n}\r\n#centerz{\r\n  width:30px;\r\n  margin-left:10px;\r\n}\r\n#centersize{\r\n  width:30px;\r\n  margin-left:10px;\r\n}\r\n.name{\r\n  margin-left: 10px;\r\n}\r\n.center{\r\n  margin-left: 10px;\r\n}\r\n::ng-deep .mat-accent .mat-slider-thumb {\r\n    background-color: #395d73;\r\n    font-family:sans-serif;\r\n}\r\n::ng-deep .mat-accent .mat-slider-thumb-label {\r\n    background-color: #395d73;\r\n    font-family:sans-serif;\r\n}\r\n::ng-deep .mat-accent .mat-slider-track-fill {\r\n    background-color: #395d73;\r\n    font-family:sans-serif;\r\n} "

/***/ }),

/***/ "./src/app/mViewer/viewers/gs-viewer/setting/setting.component.html":
/*!**************************************************************************!*\
  !*** ./src/app/mViewer/viewers/gs-viewer/setting/setting.component.html ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<div id=\"settingview\" (click)=\"setting($event)\">\r\n  <input id=\"grid\" #grid type=\"checkbox\" [checked]=\"gridVisible\" (click)=\"changegrid()\"> <label id=\"name\" value=\"gridVisible\">grid</label>\r\n  <input id=\"axis\"  type=\"checkbox\" [checked]=\"axisVisible\" (click)=\"changeaxis()\"> <label id=\"name\" value=\"axisVisible\">axis</label>\r\n  <input id=\"shadow\"  type=\"checkbox\" [checked]=\"shadowVisible\" (click)=\"changeshadow()\"> <label id=\"name\" value=\"shadowVisible\">shadow</label>\r\n  <input id=\"frame\"  type=\"checkbox\" [checked]=\"frameVisible\" (click)=\"changeframe()\"> <label id=\"name\" value=\"frameVisible\">frame</label><br/>\r\n  <!-- <input id=\"nomal\"  type=\"checkbox\" [checked]=\"normalVisible\" (click)=\"changenormal()\"> <label id=\"name\" value=\"nomalVisible\">nomal</label> -->\r\n  <input id=\"point\"  type=\"checkbox\" [checked]=\"pointVisible\" (click)=\"changepoint()\"> <label id=\"name\" value=\"pointVisible\">point</label><br/>\r\n  \r\n  <hr/><label class=\"name\" >Grid Center</label><br/>\r\n  <label class=\"name\" >X</label><input type=\"text\" name=\"center\" id=\"centerx\" #centerx value={{_centerx}} (change)=changecenter(centerx.value,centery.value,centerz.value,size.value)>\r\n  &nbsp;&nbsp;&nbsp;&nbsp;<label id=\"name\" >Y</label><input type=\"text\" name=\"center\" #centery id=\"centery\" value={{_centery}} (change)=changecenter(centerx.value,centery.value,centerz.value,size.value)>\r\n  &nbsp;&nbsp;&nbsp;&nbsp;<label id=\"name\" >Z</label><input type=\"text\" name=\"center\"  #centerz id=\"centerz\" value={{_centerz}} (change)=changecenter(centerx.value,centery.value,centerz.value,size.value)>\r\n  &nbsp;&nbsp;&nbsp;&nbsp;<label id=\"name\" >Size</label><input type=\"text\" name=\"center\"  #size id=\"centersize\" value={{_centersize}} (change)=changecenter(centerx.value,centery.value,centerz.value,size.value)>\r\n  &nbsp;&nbsp;&nbsp;&nbsp;<button (click)=\"getcenter()\">Get</button><br/>\r\n  <!--< button (click)=\"changecenter(centerx.value,centery.value,centerz.value)\">Set</button> -->\r\n  <!-- <hr/>&nbsp;&nbsp;&nbsp;&nbsp;<label id=\"name\" >Raycaster Precision</label>&nbsp;&nbsp;<br/>-->\r\n  <label class=\"name\" >Line Precision</label>\r\n  <mat-slider class=\"slider\" name=\"range\" id=\"linerange\" min=0 max=1 step=0.01  value={{_linepre}} #linepre (change)=\"changeline(linepre.value)\" ></mat-slider><label id=\"name\" >{{linepre.value.toPrecision(2)}}</label><br/>\r\n  <!-- &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<label id=\"name\" >Point Precision</label>\r\n  <mat-slider class=\"slider\" name=\"range\" id=\"pointrange\" min=0 max=1 step=0.01  value={{_pointpre}} #pointpre (change)=\"changepoint(pointpre.value)\" ></mat-slider><label id=\"name\" >{{pointpre.value.toPrecision(2)}}</label><br/> -->\r\n  <label class=\"name\" >Points Size</label>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n  <mat-slider class=\"slider\" name=\"range\" id=\"sizerange\" min=0 max=5 step=0.1  value={{_pointsize}} #pointsize (change)=\"changepointsize(pointsize.value)\" ></mat-slider><label id=\"name\" >{{pointsize.value.toPrecision(2)}}</label><br/>\r\n\r\n  <hr/><label class=\"name\" >Hemisphere Light</label>&nbsp;&nbsp;<br/>\r\n  <label class=\"name\" >hue</label>&nbsp;&nbsp;&nbsp;\r\n  <mat-slider class=\"slider\" name=\"range\" id=\"huerange\" min=0 max=1 step=0.01  value={{hue}} #slider (change)=\"changelight(slider.value,slider1.value,slider2.value)\" ></mat-slider><label id=\"name\" >{{slider.value.toPrecision(2)}}</label><br/>\r\n  <label class=\"name\" >saturation</label>\r\n  <mat-slider name=\"range\" id=\"satrange\" min=0 max=1 step=0.01 value={{saturation}} #slider1 (change)=\"changelight(slider.value,slider1.value,slider2.value)\" ></mat-slider><label id=\"name\" >{{slider1.value.toPrecision(2)}}</label><br/>\r\n  <label class=\"name\" >lightness</label>\r\n  <mat-slider name=\"range\" id=\"lirange\" min=0 max=1 step=0.01 value={{lightness}} #slider2 (change)=\"changelight(slider.value,slider1.value,slider2.value)\" ></mat-slider><label id=\"name\" >{{slider2.value.toPrecision(2)}}</label><br/>\r\n  <!-- &nbsp;&nbsp;&nbsp;&nbsp;<label id=\"name\" >opacity</label>&nbsp;&nbsp;&nbsp;\r\n  <mat-slider name=\"range\" id=\"oprange\" min=0 max=1 step=0.01 value={{opacity}} #slider3 (change)=\"changeopa(slider3.value)\" ></mat-slider><label id=\"name\" >{{slider3.value.toPrecision(2)}}</label><br/> -->\r\n  <!-- <hr/>&nbsp;&nbsp;&nbsp;&nbsp;<label id=\"name\" >Backeground Color</label>&nbsp;&nbsp;<br/>\r\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<label id=\"name\" >R</label>\r\n  <mat-slider  name=\"range\" id=\"redrange\" min=0 max=1 step=0.01  value={{red}} #slider4 (change)=\"changeback(slider4.value,slider5.value,slider6.value)\" ></mat-slider><label id=\"name\" >{{slider4.value.toPrecision(2)}}</label><br/>\r\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<label id=\"name\" >G</label>\r\n  <mat-slider name=\"range\" id=\"greenrange\" min=0 max=1 step=0.01 value={{green}} #slider5 (change)=\"changeback(slider4.value,slider5.value,slider6.value)\" ></mat-slider><label id=\"name\" >{{slider5.value.toPrecision(2)}}</label><br/>\r\n  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<label id=\"name\" >B</label>\r\n  <mat-slider name=\"range\" id=\"bluerange\" min=0 max=1 step=0.01 value={{blue}} #slider6 (change)=\"changeback(slider4.value,slider5.value,slider6.value)\" ></mat-slider><label id=\"name\" >{{slider6.value.toPrecision(2)}}</label><br/> -->\r\n</div>"

/***/ }),

/***/ "./src/app/mViewer/viewers/gs-viewer/setting/setting.component.ts":
/*!************************************************************************!*\
  !*** ./src/app/mViewer/viewers/gs-viewer/setting/setting.component.ts ***!
  \************************************************************************/
/*! exports provided: SettingComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SettingComponent", function() { return SettingComponent; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var _data_data_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../data/data.service */ "./src/app/mViewer/viewers/gs-viewer/data/data.service.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



var SettingComponent = /** @class */ (function () {
    function SettingComponent(dataService) {
        this.dataService = dataService;
        // avoid manipulating the scene here
        // shift to dataservice
        this.scene = this.dataService.getScene();
        this.alight = this.dataService.getalight();
        this.hue = this.dataService.hue;
        this.saturation = this.dataService.saturation;
        this.lightness = this.dataService.lightness;
        this._centerx = this.dataService.centerx;
        this._centery = this.dataService.centery;
        this._centerz = this.dataService.centerz;
        this._centersize = this.dataService.centersize;
        this.raycaster = this.dataService.getraycaster();
        this._linepre = this.raycaster.linePrecision;
        this._pointpre = this.raycaster.params.Points.threshold;
        this._pointsize = this.dataService.pointsize;
    }
    SettingComponent.prototype.ngOnInit = function () {
        if (this.hue == undefined) {
            this.hue = 0;
        }
        else {
            this.hue = this.dataService.hue;
        }
        if (this.saturation == undefined) {
            this.saturation = 0.01;
        }
        else {
            this.saturation = this.dataService.saturation;
        }
        if (this.lightness == undefined) {
            this.lightness = 0.47;
        }
        else {
            this.lightness = this.dataService.lightness;
        }
        this.gridVisible = this.dataService.grid;
        this.axisVisible = this.dataService.axis;
        this.shadowVisible = this.dataService.shadow;
        this.frameVisible = this.dataService.frame;
        this.pointVisible = this.dataService.point;
        if (this._centerx == undefined) {
            this._centerx = 0;
        }
        else {
            this._centerx = this.dataService.centerx;
        }
        if (this._centery == undefined) {
            this._centery = 0;
        }
        else {
            this._centery = this.dataService.centery;
        }
        if (this._centerz == undefined) {
            this._centerz = 0;
        }
        else {
            this._centerz = this.dataService.centerz;
        }
        if (this._centersize == undefined) {
            this._centersize = 100;
        }
        else {
            this._centersize = this.dataService.centersize;
        }
        this.raycaster = this.dataService.getraycaster();
        if (this._linepre == undefined) {
            this._linepre = 0.05;
        }
        else {
            this._linepre = this.raycaster.linePrecision;
        }
        if (this._pointpre == undefined) {
            this._pointpre = 1;
        }
        else {
            this._pointpre = this.raycaster.params.Points.threshold;
        }
        if (this._pointsize == undefined) {
            this._pointsize = 1;
        }
        else {
            this._pointsize = this.dataService.pointsize;
        }
    };
    SettingComponent.prototype.changegrid = function () {
        this.gridVisible = !this.gridVisible;
        if (this.gridVisible) {
            var gridhelper = new three__WEBPACK_IMPORTED_MODULE_0__["GridHelper"](100, 100);
            gridhelper.name = "GridHelper";
            var vector = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](0, 1, 0);
            gridhelper.lookAt(vector);
            this.scene.add(gridhelper);
        }
        else {
            this.scene.remove(this.scene.getObjectByName("GridHelper"));
        }
        this.dataService.addgrid(this.gridVisible);
    };
    SettingComponent.prototype.changecenter = function (centerx, centery, centerz, centersize) {
        if (this.gridVisible) {
            var gridhelper = this.scene.getObjectByName("GridHelper");
            gridhelper = new three__WEBPACK_IMPORTED_MODULE_0__["GridHelper"](centersize, centersize);
            gridhelper.position.set(centerx, centery, centerz);
            console.log(gridhelper);
            this._centerx = centerx;
            this._centery = centery;
            this._centerz = centerz;
            this._centersize = centersize;
            this.dataService.getcenterx(centerx);
            this.dataService.getcentery(centery);
            this.dataService.getcenterz(centerz);
            this.dataService.getcentersize(centersize);
        }
    };
    SettingComponent.prototype.changeline = function (lineprecision) {
        this._linepre = lineprecision;
        this.raycaster.linePrecision = lineprecision;
        this.dataService.addraycaster(this.raycaster);
    };
    SettingComponent.prototype.changepoint = function () {
        this.pointVisible = !this.pointVisible;
        var children = [];
        for (var i = 0; i < this.scene.children.length; i++) {
            if (this.scene.children[i].type === "Scene") {
                for (var j = 0; j < this.scene.children[i].children.length; j++) {
                    if (this.scene.children[i].children[j].type === "Points") {
                        children.push(this.scene.children[i].children[j]);
                    }
                }
            }
        }
        if (this.pointVisible) {
            for (var i = 0; i < children.length; i++) {
                children[i]["material"].transparent = false;
                children[i]["material"].opacity = 1;
            }
        }
        else {
            for (var i = 0; i < children.length; i++) {
                children[i]["material"].transparent = true;
                children[i]["material"].opacity = 0;
            }
        }
        this.dataService.addpoint(this.pointVisible);
    };
    SettingComponent.prototype.changepointsize = function (pointsize) {
        this._pointsize = pointsize;
        for (var i = 0; i < this.scene.children.length; i++) {
            if (this.scene.children[i].name === "sphereInter") {
                var geometry = new three__WEBPACK_IMPORTED_MODULE_0__["SphereGeometry"](pointsize / 3);
                this.scene.children[i]["geometry"] = geometry;
            }
            if (this.scene.children[i].name === "selects" && this.scene.children[i].type === "Points") {
                this.scene.children[i]["material"].size = pointsize;
            }
        }
        this.dataService.getpointsize(pointsize);
    };
    SettingComponent.prototype.changeaxis = function () {
        this.axisVisible = !this.axisVisible;
        if (this.axisVisible) {
            var axishelper = new three__WEBPACK_IMPORTED_MODULE_0__["AxesHelper"](10);
            axishelper.name = "AxisHelper";
            this.scene.add(axishelper);
        }
        else {
            this.scene.remove(this.scene.getObjectByName("AxisHelper"));
        }
        this.dataService.addaxis(this.axisVisible);
    };
    SettingComponent.prototype.changeshadow = function () {
        this.shadowVisible = !this.shadowVisible;
        for (var i = 0; i < this.scene.children.length; i++) {
            if (this.scene.children[i].type === "DirectionalLight") {
                if (this.shadowVisible) {
                    this.scene.children[i].castShadow = true;
                }
                else {
                    this.scene.children[i].castShadow = false;
                }
            }
        }
        this.dataService.addshadow(this.shadowVisible);
    };
    SettingComponent.prototype.changelight = function (_hue, _saturation, _lightness) {
        this.hue = _hue;
        this.saturation = _saturation;
        this.lightness = _lightness;
        var alight = this.alight;
        this.dataService.gethue(_hue);
        this.dataService.getsaturation(_saturation);
        this.dataService.getlightness(_lightness);
        this.alight.color.setHSL(_hue, _saturation, _lightness);
    };
    SettingComponent.prototype.changeframe = function () {
        this.frameVisible = !this.frameVisible;
        if (this.frameVisible) {
            for (var i = 0; i < this.scene.children.length; i++) {
                if (this.scene.children[i].type === "Scene") {
                    if (this.scene.children[i].children[0].type === "Mesh") {
                        this.scene.children[i].children[0].visible = false;
                    }
                }
            }
        }
        else {
            for (var i = 0; i < this.scene.children.length; i++) {
                if (this.scene.children[i].type === "Scene") {
                    if (this.scene.children[i].children[0].type === "Mesh") {
                        this.scene.children[i].children[0].visible = true;
                    }
                }
            }
        }
        this.dataService.addframe(this.frameVisible);
    };
    SettingComponent.prototype.changenormal = function () {
        this.nomalVisible = !this.nomalVisible;
        if (this.nomalVisible) {
            /*for(var i=0;i<this.scene.children.length;i++){
              if(this.scene.children[i].type==="Scene"){
                for(var j=0;j<this.scene.children[i].children.length;j++){
                  if(this.scene.children[i].children[j].type==="Mesh"){
                    var mesh=this.scene.children[i].children[j];
                    var faceNormalsHelper = new THREE.FaceNormalsHelper( mesh, 10 );
                    mesh.add( faceNormalsHelper );
                    var verticehelper = new THREE.VertexNormalsHelper( mesh, 10 );
                    this.scene.add(verticehelper);
                    console.log(this.scene);
                    //facehelper.visible=false;
                    //this.scene.add(verticehelper);
                  }
                }
              }
            }*/
        }
    };
    SettingComponent.prototype.setting = function (event) {
        event.stopPropagation();
    };
    SettingComponent = __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
            selector: 'app-setting',
            template: __webpack_require__(/*! ./setting.component.html */ "./src/app/mViewer/viewers/gs-viewer/setting/setting.component.html"),
            styles: [__webpack_require__(/*! ./setting.component.css */ "./src/app/mViewer/viewers/gs-viewer/setting/setting.component.css")]
        }),
        __metadata("design:paramtypes", [_data_data_service__WEBPACK_IMPORTED_MODULE_2__["DataService"]])
    ], SettingComponent);
    return SettingComponent;
}());



/***/ }),

/***/ "./src/app/mViewer/viewers/gs-viewer/toolwindow/groups.component.css":
/*!***************************************************************************!*\
  !*** ./src/app/mViewer/viewers/gs-viewer/toolwindow/groups.component.css ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#setandgroup{\r\n  position: relative;\r\n  background-color: #F1F1F1 !important;\r\n  height: 100%;\r\n  width: 100%;\r\n  font-family: Roboto,\"Helvetica Neue\",sans-serif;\r\n  font-size: 12px !important;\r\n  line-height: 14px;\r\n  overflow-x: hidden !important;\r\n}\r\n#groupsview{\r\n  color:#395d73;\r\n  background-color: #F1F1F1 !important;\r\n  font-family: Roboto,\"Helvetica Neue\",sans-serif;\r\n  font-size: 12px !important;\r\n}\r\n#settingview{\r\n  font-family: Roboto,\"Helvetica Neue\",sans-serif;\r\n  background-color: #F1F1F1 !important;\r\n  font-size: 12px !important;\r\n  line-height: 14px;\r\n  overflow-x: hidden !important;\r\n  overflow-y: hidden !important;\r\n  width: 1600px;\r\n  height: 800px;\r\n  color: #395d73;\r\n}\r\n.check{\r\n  margin-left:10px;\r\n}\r\n#GridCenter{\r\n  margin-left: 10px;\r\n  margin-top: 3px !important;\r\n  height: 8px;\r\n  vertical-align: bottom;\r\n}\r\n#centerx{\r\n  width:50px;\r\n  margin-left: 10px;\r\n/*  margin-left:25px;*/\r\n}\r\n#centery{\r\n  width:50px;\r\n  /*margin-left:25px;*/\r\n}\r\n#centerz{\r\n  width:50px;\r\n  /*margin-left:25px;*/\r\n}\r\n#centersize{\r\n  width:50px;\r\n  margin-left:9px;\r\n}\r\n.name{\r\n  width: 100%;\r\n  margin-left: 10px;\r\n  margin-top: 8px;\r\n}\r\n#slider-conainer{\r\n  align-items: center !important;\r\n  display: flex;\r\n  float: right;\r\n}\r\n/*::ng-deep .mat-accent .mat-slider-thumb {\r\n    background-color: #395d73;\r\n    font-family:sans-serif;\r\n} \r\n::ng-deep .mat-accent .mat-slider-thumb-label {\r\n    background-color: white;\r\n    color:#395d73;\r\n    font-family:sans-serif;\r\n}\r\n::ng-deep .mat-accent .mat-slider-track-fill {\r\n    background-color: #395d73;\r\n    font-family:sans-serif;\r\n}\r\n\r\n/deep/.mat-slider-min-value.mat-slider-thumb-label-showing .mat-slider-thumb, .mat-slider-min-value.mat-slider-thumb-label-showing .mat-slider-thumb-label {\r\n    background-color: #395d73;\r\n}\r\n/*::ng-deep .mat-expansion-panel {\r\n  margin: 0px !important;\r\n  overflow: hidden !important;\r\n}\r\n/deep/ .slider {\r\n  height: 25px !important;\r\n  vertical-align: unset !important;\r\n  width: unset !important;\r\n}\r\n*/\r\n/deep/.mat-accent .mat-slider-thumb {\r\n    background-color: #395d73 !important;\r\n    cursor: -webkit-grab;\r\n}\r\n/deep/.mat-slider-track-fill{\r\n  background-color: #395d73 !important;\r\n}\r\n/deep/.mat-slider-thumb-label-text {\r\n    color: #395d73 !important;\r\n    font-size: 12px !important;\r\n}\r\n/deep/.mat-slider-thumb-label{\r\n    height: 15px !important;\r\n    width: 15px !important;\r\n    top: -20px !important;\r\n    right: -7px !important;\r\n    background-color: white !important;\r\n    border: 1px solid #395d73 !important;\r\n}\r\n.mat-slider{\r\n    width: 50px !important;\r\n}\r\n/deep/.mat-tab-label, /deep/.mat-tab-label-active{\r\n  min-width: 3px!important;\r\n  padding: 3px!important;\r\n  margin: 3px!important;\r\n  color:#395d73;\r\n}\r\n/deep/.mat-tab-label{\r\n  height: 30px !important;\r\n}\r\n/deep/.mat-tab-header-pagination-controls-enabled .mat-tab-header-pagination{\r\n  display: none !important;\r\n}\r\n/deep/.mat-ink-bar{\r\n  background-color: #395d73 !important;\r\n}\r\n.mat-tab{\r\n  min-width: 30px !important;\r\n}\r\n/deep/.mat-tab-body-content{\r\n  overflow: hidden !important;\r\n}\r\n.mat-expansion-panel-spacing {\r\n  margin-top:0px;\r\n  margin-bottom: 0px;\r\n}\r\n.mat-expansion-panel{\r\n  background-color: #F1F1F1 !important;\r\n  border-color: #395d73;\r\n  line-height: 14px;\r\n  font-weight: bold !important;\r\n  font-size: 12px !important;\r\n  overflow: hidden !important;\r\n}\r\n#groupname{\r\n  margin-right: 0px;\r\n}\r\n.mat-header{\r\n  flex-direction: row;\r\n  font-family: Roboto,\"Helvetica Neue\",sans-serif;\r\n  margin-left: 0px;\r\n  color:#395d73;\r\n  border: 0;\r\n  height: 20px;\r\n}\r\n.mat-list-text{\r\n  cursor :pointer;\r\n  color:#f3a32a;\r\n  font-family: sans-serif;\r\n  font-size: 14px;\r\n  font-weight: 700px;\r\n  line-height: 14px;\r\n  border-top: 2px !important;\r\n  /*margin-top: 2px;*/\r\n}\r\n.mat-list-descr{\r\n  cursor :default;\r\n  color:#f3a32a;\r\n  font-family: sans-serif;\r\n  font-size: 14px;\r\n  font-weight: 700px;\r\n  line-height: 14px;\r\n  border-top: 2px !important;\r\n  margin-top: 8px;\r\n}\r\n.mat-list-text-parent{\r\n  cursor :pointer;\r\n  color:#f3a32a;\r\n  font-family: sans-serif;\r\n  font-size: 14px;\r\n  font-weight: 700px;\r\n  line-height: 14px;\r\n  border-top: 2px !important;\r\n  /*margin-top: 2px;*/\r\n}\r\nhr {\r\n  display: block;\r\n  height: 1px;\r\n  border: 0;\r\n  border-top: 1px solid #ccc;\r\n  /*margin: 1em 0;*/\r\n  padding: 0; \r\n  color:#395d73;\r\n  width: 100%;\r\n  background-color: #395d73;\r\n}\r\n\r\n"

/***/ }),

/***/ "./src/app/mViewer/viewers/gs-viewer/toolwindow/groups.component.html":
/*!****************************************************************************!*\
  !*** ./src/app/mViewer/viewers/gs-viewer/toolwindow/groups.component.html ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<div id=\"setandgroup\" >\r\n<mat-tab-group class=\"mat-tab-group\">\r\n  <mat-tab label=\"Groups\" >\r\n  \t<div id=\"groupsview\">\r\n\t<mat-accordion>\r\n\t  <mat-expansion-panel *ngFor=\"let group of groups\">\r\n\t\t  <mat-expansion-panel-header *ngIf=\"group.parent===null\" class=\"mat-header\">\r\n\t\t    <div class=\"mat-header\"><label id=\"groupname\">{{group.name}}</label></div>\r\n\t\t  </mat-expansion-panel-header>\r\n\t\t    <!-- <div class=\"mat-list-text-parent\"><span id=\"parent\">parent : {{group.parent}} </span></div> -->\r\n\t\t    <div ><span class=\"mat-list-text\" (click)=\"selectpoint(group)\">point : {{group.num_point}} </span></div>\r\n\t\t    <div ><span class=\"mat-list-text\" (click)=\"selectvertice(group)\">vertice : {{group.num_vertice}} </span></div>\r\n\t\t    <div ><span class=\"mat-list-text\" (click)=\"selectedge(group)\">edge : {{group.num_edge}} </span></div>\r\n\t\t    <div ><span class=\"mat-list-text\" (click)=\"selectwire(group)\">wire : {{group.num_wire}} </span></div>\r\n\t\t    <div ><span class=\"mat-list-text\" (click)=\"selectface(group)\">face : {{group.num_face}} </span></div>\r\n\t\t    <div ><span class=\"mat-list-text\" (click)=\"selectobject(group)\">object : {{group.num_object}} </span><hr/></div>\r\n\t\t    <div class=\"mat-list-descr\" *ngFor=\"let prop of group.props\"><span >{{prop[0]}} : {{prop[1]}} </span></div>\r\n\t\t    <div *ngIf=\"group.child!==null\" >\r\n \t\t    \t<mat-accordion>\r\n\t\t\t  \t\t<mat-expansion-panel >\r\n\t\t\t  \t\t\t<mat-expansion-panel-header ><div class=\"mat-header\"><label id=\"groupname\">{{group.child.name}}</label></div></mat-expansion-panel-header>\r\n\t\t\t  \t\t\t<div class=\"mat-list-text-parent\"><span id=\"parent\">parent : {{group.child.parent}} </span><hr></div>\r\n\t\t\t  \t\t\t<div ><span class=\"mat-list-text\" (click)=\"selectpoint(group)\">point : {{group.child.num_point}} </span></div>\r\n\t\t\t\t\t    <div ><span class=\"mat-list-text\" (click)=\"selectvertice(group)\">vertice : {{group.child.num_vertice}} </span></div>\r\n\t\t\t\t\t    <div ><span class=\"mat-list-text\" (click)=\"selectedge(group)\">edge : {{group.child.num_edge}} </span></div>\r\n\t\t\t\t\t    <div ><span class=\"mat-list-text\" (click)=\"selectwire(group)\">wire : {{group.child.num_wire}} </span></div>\r\n\t\t\t\t\t    <div ><span class=\"mat-list-text\" (click)=\"selectface(group)\">face : {{group.child.num_face}} </span></div>\r\n\t\t\t\t\t    <div ><span class=\"mat-list-text\" (click)=\"selectobject(group)\">object : {{group.child.num_object}} </span><hr/></div>\r\n\t\t\t\t\t    <div class=\"mat-list-descr\" *ngFor=\"let prop of group.child.props\"><span >{{prop[0]}} : {{prop[1]}} </span></div>\r\n \t\t\t  \t\t</mat-expansion-panel>\r\n\t\t \t\t </mat-accordion>\r\n\t\t\t</div>\r\n \t\t</mat-expansion-panel>\r\n\t</mat-accordion>\r\n\t</div>\r\n  </mat-tab>\r\n  <mat-tab label=\"Settings\" >\r\n  \t<div id=\"settingview\">\r\n  \t\t<input id=\"grid\" class=\"check\" #grid type=\"checkbox\" [checked]=\"gridVisible\" (click)=\"changegrid()\"> <label id=\"name\" value=\"gridVisible\">grid</label><br/>\r\n\t\t<input id=\"axis\" class=\"check\" type=\"checkbox\" [checked]=\"axisVisible\" (click)=\"changeaxis()\"> <label id=\"name\" value=\"axisVisible\">axis</label><br/>\r\n\t\t<input id=\"shadow\" class=\"check\"  type=\"checkbox\" [checked]=\"shadowVisible\" (click)=\"changeshadow()\"> <label id=\"name\" value=\"shadowVisible\">shadow</label><br/>\r\n\t\t<input id=\"frame\" class=\"check\" type=\"checkbox\" [checked]=\"frameVisible\" (click)=\"changeframe()\"> <label id=\"name\" value=\"frameVisible\">wireframe</label><br/>\r\n\t\t<input id=\"point\" class=\"check\" type=\"checkbox\" [checked]=\"pointVisible\" (click)=\"changepoint()\"> <label id=\"name\" value=\"pointVisible\">point</label><br/>\r\n\t\t<hr/><div  id=\"GridCenter\" >Grid Center<button (click)=\"getcenter()\" style=\"margin-left: 30px;width: 40px;height: 20px; font-family: sans-serif;font-size: 12px;\">Get</button></div><br/>\r\n\t\t<label class=\"name\" >XYZ</label><input type=\"text\" name=\"center\" id=\"centerx\" #centerx value={{_centerx}} (change)=changecenter(centerx.value,centery.value,centerz.value)><input type=\"text\" name=\"center\" #centery id=\"centery\" value={{_centery}} (change)=changecenter(centerx.value,centery.value,centerz.value)><input type=\"text\" name=\"center\"  #centerz id=\"centerz\" value={{_centerz}} (change)=changecenter(centerx.value,centery.value,centerz.value)><br/>\r\n\t\t<label class=\"name\" >Size</label><input type=\"text\" name=\"center\"  #size id=\"centersize\" value={{_centersize}} (change)=changecentersize(size.value)><br/>\r\n\t\t<hr/><div style=\"margin-left: 10px;\"><label  >Selection Settings:</label></div><!-- <br/> -->\r\n\t\t<div class=\"name\"><label >Line Precision</label></div><!-- <br/> -->\r\n  \t\t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<label class=\"name\" >Radius</label>&nbsp;<input type=\"text\" value={{_linepre}} #linetext (change)=\"changeline(linetext.value)\" style=\"width: 30px; \">&nbsp;<span>0</span>\r\n\r\n  \t\t<mat-slider class=\"slider\" name=\"range\" id=\"linerange\" min=0 max=1 step=0.01 thumbLabel=true value=\"_linepre\" #linepre (change)=\"changeline(linepre.value.toPrecision(2))\" >\r\n  \t\t</mat-slider>\r\n\r\n  \t\t<span>1</span><br/>\r\n  \t\t<div class=\"name\"><label>Points Precision</label></div><!-- <br/> -->\r\n  \t\t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<label class=\"name\" >Radius</label>&nbsp;<input type=\"text\" value={{_materialpoint}} #pointtext1 (change)=\"changeradius(pointtext1.value)\" style=\"width: 30px; \">&nbsp;<span>0</span><mat-slider class=\"slider\" name=\"range\" id=\"sizerange\" min=0 max=5 step=0.1 thumbLabel=true value={{_materialpoint}} #pointsize1 (change)=\"changeradius(pointsize1.value.toPrecision(2))\" ></mat-slider><span>5</span><br/>\r\n  \t\t<!-- &nbsp;&nbsp;&nbsp;&nbsp;<label class=\"name\" >Selected</label>&nbsp;<input type=\"text\" value={{_pointsize}} #pointtext (change)=\"changepointsize(pointtext.value)\" style=\"width: 30px; \">&nbsp;<span>0</span><mat-slider class=\"slider\" name=\"range\" id=\"sizerange\" min=0 max=5 step=0.1 thumbLabel=true value={{_pointsize}} #pointsize (change)=\"changepointsize(pointsize.value.toPrecision(2))\" ></mat-slider><span>5</span><br/> -->\r\n  \t\t<div class=\"name\"><label >Points Size</label></div><!-- <br/> -->\r\n  \t\t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<label class=\"name\" >Size</label>&nbsp;<input type=\"text\" value={{_pointsize}} #pointtext (change)=\"changepointsize(pointtext.value)\" style=\"width: 30px; \">&nbsp;<span>0</span><mat-slider class=\"slider\" name=\"range\" id=\"sizerange\" min=0 max=5 step=0.1 thumbLabel=true value={{_pointsize}} #pointsize (change)=\"changepointsize(pointsize.value.toPrecision(2))\" ></mat-slider><span>5</span><br/><!-- <input type=\"text\" value={{_materialpoint}} #pointtext1 (change)=\"changematerialpoint(pointtext1.value)\" style=\"width: 30px; \">&nbsp;<span>0</span><mat-slider class=\"slider\" name=\"range\" id=\"sizerange\" min=0 max=5 step=0.1 thumbLabel=true value={{_pointsize1}} #pointsize1 (change)=\"changematerialpoint(pointsize1.value.toPrecision(2))\" ></mat-slider><span>5</span><br/> -->\r\n  \t\t<hr/><label class=\"name\" >Hemisphere Light</label>&nbsp;&nbsp;<br/>\r\n\t\t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<label class=\"name\" >Hue</label>&nbsp;\r\n\t\t<input type=\"text\" value={{hue}} #huetext (change)=\"changelight(huetext.value,slider1.value,slider2.value)\" style=\"width: 30px; \">&nbsp;<span>0</span><mat-slider class=\"slider\" name=\"range\" id=\"huerange\" min=0 max=1 step=0.01 thumbLabel=true value={{hue}} #slider (change)=\"changelight(slider.value,slider1.value,slider2.value)\" ></mat-slider><span>1</span><br/>\r\n\t\t&nbsp;<label class=\"name\" >Saturation</label>&nbsp;\r\n\t\t<input type=\"text\" value={{saturation}} #satutext (change)=\"changelight(slider.value,satutext.value,slider2.value)\" style=\"width: 30px; \">&nbsp;<span>0</span><mat-slider class=\"slider\" name=\"range\" id=\"satrange\" min=0 max=1 step=0.01 thumbLabel=true value={{saturation}} #slider1 (change)=\"changelight(slider.value,slider1.value,slider2.value)\" ></mat-slider><span>1</span><br/>\r\n\t\t&nbsp;&nbsp;<label class=\"name\" >Lightness</label>&nbsp;\r\n\t\t<input type=\"text\" value={{lightness}} #lighttext (change)=\"changelight(slider.value,slider1.value,lighttext.value)\" style=\"width: 30px; \">&nbsp;<span>0</span><mat-slider class=\"slider\" name=\"range\" id=\"lirange\" min=0 max=1 step=0.01 thumbLabel=true value={{lightness}} #slider2 (change)=\"changelight(slider.value,slider1.value,slider2.value)\" ></mat-slider><span>1</span><br/>\r\n  \t</div>\r\n  </mat-tab>\r\n</mat-tab-group>\r\n</div>\r\n"

/***/ }),

/***/ "./src/app/mViewer/viewers/gs-viewer/toolwindow/groups.component.ts":
/*!**************************************************************************!*\
  !*** ./src/app/mViewer/viewers/gs-viewer/toolwindow/groups.component.ts ***!
  \**************************************************************************/
/*! exports provided: GroupsComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GroupsComponent", function() { return GroupsComponent; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var _data_DataSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../data/DataSubscriber */ "./src/app/mViewer/viewers/gs-viewer/data/DataSubscriber.ts");
/* harmony import */ var gs_json__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! gs-json */ "./node_modules/gs-json/dist2015/index.js");
/* harmony import */ var gs_json__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(gs_json__WEBPACK_IMPORTED_MODULE_3__);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




/*import {MatTabsModule} from '@angular/material/tabs';*/
var GroupsComponent = /** @class */ (function (_super) {
    __extends(GroupsComponent, _super);
    function GroupsComponent(injector, myElement) {
        var _this = _super.call(this, injector) || this;
        _this.scene = _this.dataService.getScene();
        _this.renderer = _this.dataService.getRenderer();
        _this.camera = _this.dataService.getCamera();
        _this.myElement = myElement;
        _this._centerx = _this.dataService.centerx;
        _this._centery = _this.dataService.centery;
        _this._centerz = _this.dataService.centerz;
        _this._centersize = _this.dataService.centersize;
        _this.raycaster = _this.dataService.getraycaster();
        _this._pointsize = _this.dataService.pointsize;
        _this._materialpoint = _this.dataService.pointradius;
        _this.alight = _this.dataService.getalight();
        _this.hue = _this.dataService.hue;
        _this.saturation = _this.dataService.saturation;
        _this.lightness = _this.dataService.lightness;
        return _this;
    }
    GroupsComponent.prototype.ngOnInit = function () {
        this.model = this.dataService.getGsModel();
        this.updateModel();
        this.gridVisible = this.dataService.grid;
        this.axisVisible = this.dataService.axis;
        this.shadowVisible = this.dataService.shadow;
        this.frameVisible = this.dataService.frame;
        this.pointVisible = this.dataService.point;
        if (this._centerx === undefined || this._centerx === 0) {
            this._centerx = 0;
        }
        else {
            this._centerx = this.dataService.centerx;
        }
        if (this._centery === undefined || this._centery === 0) {
            this._centery = 0;
        }
        else {
            this._centery = this.dataService.centery;
        }
        if (this._centerz === undefined || this._centerz === 0) {
            this._centerz = 0;
        }
        else {
            this._centerz = this.dataService.centerz;
        }
        if (this._centersize === undefined || this._centersize === 100) {
            this._centersize = 100;
        }
        else {
            this._centersize = this.dataService.centersize;
        }
        this.raycaster = this.dataService.getraycaster();
        if (this._linepre === undefined || this._linepre === 0.05) {
            this._linepre = 0.05;
        }
        else {
            this._linepre = this.raycaster.linePrecision;
        }
        if (this._pointsize === undefined || this._pointsize === 1) {
            this._pointsize = 1;
        }
        else {
            this._pointsize = this.dataService.pointsize;
        }
        if (this._materialpoint === undefined || this._materialpoint === 0.1) {
            this._materialpoint = 0.1;
        }
        else {
            this._materialpoint = this.dataService.pointradius;
        }
        if (this.hue === undefined || this.hue === 0) {
            this.hue = 0;
        }
        else {
            this.hue = this.dataService.hue;
        }
        if (this.saturation === undefined || this.saturation === 0.01) {
            this.saturation = 0.01;
        }
        else {
            this.saturation = this.dataService.saturation;
        }
        if (this.lightness == undefined || this.lightness === 0.47) {
            this.lightness = 0.47;
        }
        else {
            this.lightness = this.dataService.lightness;
        }
    };
    GroupsComponent.prototype.notify = function (message) {
        if (message == "model_update" && this.scene) {
            this.ngOnInit();
        }
    };
    GroupsComponent.prototype.updateModel = function () {
        if (this.model !== undefined) {
            try {
                this.scene_and_maps = this.dataService.getscememaps();
                this.getgroupname();
            }
            catch (ex) {
                console.error("Error displaying model:", ex);
            }
        }
    };
    GroupsComponent.prototype.animate = function (self) {
    };
    GroupsComponent.prototype.changegrid = function () {
        this.gridVisible = !this.gridVisible;
        if (this.gridVisible) {
            var gridhelper = new three__WEBPACK_IMPORTED_MODULE_0__["GridHelper"](this._centersize, 10);
            gridhelper.name = "GridHelper";
            var vector = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](0, 1, 0);
            gridhelper.lookAt(vector);
            gridhelper.position.set(this._centerx, this._centery, this._centerz);
            this.scene.add(gridhelper);
        }
        else {
            this.scene.remove(this.scene.getObjectByName("GridHelper"));
        }
        this.renderer.render(this.scene, this.camera);
        this.dataService.addgrid(this.gridVisible);
    };
    GroupsComponent.prototype.changepoint = function () {
        this.pointVisible = !this.pointVisible;
        var children = [];
        for (var i = 0; i < this.scene.children.length; i++) {
            if (this.scene.children[i].type === "Scene") {
                for (var j = 0; j < this.scene.children[i].children.length; j++) {
                    if (this.scene.children[i].children[j].type === "Points") {
                        children.push(this.scene.children[i].children[j]);
                    }
                }
            }
        }
        if (this.pointVisible) {
            for (var i = 0; i < children.length; i++) {
                children[i]["material"].transparent = false;
                children[i]["material"].opacity = 1;
            }
        }
        else {
            for (var i = 0; i < children.length; i++) {
                children[i]["material"].transparent = true;
                children[i]["material"].opacity = 0;
            }
        }
        this.renderer.render(this.scene, this.camera);
        this.dataService.addpoint(this.pointVisible);
    };
    GroupsComponent.prototype.changeaxis = function () {
        this.axisVisible = !this.axisVisible;
        if (this.axisVisible) {
            var axishelper = new three__WEBPACK_IMPORTED_MODULE_0__["AxesHelper"](10);
            axishelper.name = "AxisHelper";
            this.scene.add(axishelper);
        }
        else {
            this.scene.remove(this.scene.getObjectByName("AxisHelper"));
        }
        this.renderer.render(this.scene, this.camera);
        this.dataService.addaxis(this.axisVisible);
    };
    GroupsComponent.prototype.changeshadow = function () {
        this.shadowVisible = !this.shadowVisible;
        for (var i = 0; i < this.scene.children.length; i++) {
            if (this.scene.children[i].type === "DirectionalLight") {
                if (this.shadowVisible) {
                    this.scene.children[i].castShadow = true;
                }
                else {
                    this.scene.children[i].castShadow = false;
                }
            }
        }
        this.renderer.render(this.scene, this.camera);
        this.dataService.addshadow(this.shadowVisible);
    };
    GroupsComponent.prototype.changeframe = function () {
        this.frameVisible = !this.frameVisible;
        if (this.frameVisible) {
            for (var i = 0; i < this.scene.children.length; i++) {
                if (this.scene.children[i].type === "Scene") {
                    if (this.scene.children[i].children[0].type === "Mesh") {
                        this.scene.children[i].children[0].visible = false;
                    }
                }
            }
        }
        else {
            for (var i = 0; i < this.scene.children.length; i++) {
                if (this.scene.children[i].type === "Scene") {
                    if (this.scene.children[i].children[0].type === "Mesh") {
                        this.scene.children[i].children[0].visible = true;
                    }
                }
            }
        }
        this.renderer.render(this.scene, this.camera);
        this.dataService.addframe(this.frameVisible);
    };
    GroupsComponent.prototype.changecenter = function (centerx, centery, centerz) {
        if (this.gridVisible) {
            var gridhelper = this.scene.getObjectByName("GridHelper");
            gridhelper.position.set(centerx, centery, centerz);
            this._centerx = centerx;
            this._centery = centery;
            this._centerz = centerz;
            this.dataService.getcenterx(centerx);
            this.dataService.getcentery(centery);
            this.dataService.getcenterz(centerz);
        }
        this.renderer.render(this.scene, this.camera);
    };
    GroupsComponent.prototype.changecentersize = function (centersize) {
        if (this.gridVisible) {
            this._centersize = centersize;
            this.scene.remove(this.scene.getObjectByName("GridHelper"));
            var gridhelper = new three__WEBPACK_IMPORTED_MODULE_0__["GridHelper"](centersize, centersize);
            gridhelper.name = "GridHelper";
            var vector = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](0, 1, 0);
            gridhelper.lookAt(vector);
            gridhelper.position.set(this._centerx, this._centery, this._centerz);
            this.scene.add(gridhelper);
            this.dataService.getcentersize(centersize);
        }
        this.renderer.render(this.scene, this.camera);
    };
    GroupsComponent.prototype.getcenter = function () {
        for (var i = 0; i < this.scene.children.length; i++) {
            if (this.scene.children[i].type === "Scene") {
                for (var j = 0; j < this.scene.children[i].children.length; j++) {
                    if (this.scene.children[i].children[j].name === "All points") {
                        var center = this.scene.children[i].children[j]["geometry"].boundingSphere.center;
                        var radius = this.scene.children[i].children[j]["geometry"].boundingSphere.radius;
                        var max = Math.ceil(radius + Math.max(Math.abs(center.x), Math.abs(center.y), Math.abs(center.z))) * 2;
                        this._centerx = center.x;
                        this._centery = center.y;
                        this._centerz = center.z;
                        this._centersize = max;
                    }
                }
            }
        }
        this.scene.remove(this.scene.getObjectByName("GridHelper"));
        var gridhelper = new three__WEBPACK_IMPORTED_MODULE_0__["GridHelper"](this._centersize, 10);
        gridhelper.name = "GridHelper";
        var vector = new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](0, 1, 0);
        gridhelper.lookAt(vector);
        gridhelper.position.set(this._centerx, this._centery, this._centerz);
        this.scene.add(gridhelper);
        this.dataService.getcenterx(this._centerx);
        this.dataService.getcentery(this._centery);
        this.dataService.getcenterz(this._centerz);
        this.dataService.getcentersize(this._centersize);
        this.renderer.render(this.scene, this.camera);
    };
    //chiange line precision
    GroupsComponent.prototype.changeline = function (lineprecision) {
        this._linepre = lineprecision;
        this.raycaster = this.dataService.getraycaster();
        this.raycaster.linePrecision = lineprecision;
        this.dataService.addraycaster(this.raycaster);
        if (this.dataService.SelectVisible === 'Edges' || this.dataService.SelectVisible === 'Wires') {
            for (var i = 0; i < this.scene.children.length; i++) {
                if (this.scene.children[i].name === "sphereInter") {
                    var geometry = new three__WEBPACK_IMPORTED_MODULE_0__["SphereGeometry"](lineprecision * 15);
                    this.scene.children[i]["geometry"] = geometry;
                }
            }
        }
        this.renderer.render(this.scene, this.camera);
    };
    //change points size
    GroupsComponent.prototype.changepointsize = function (pointsize) {
        this._pointsize = pointsize;
        for (var i = 0; i < this.scene.children.length; i++) {
            if (this.scene.children[i].name === "Scene") {
                for (var j = 0; j < this.scene.children[i].children.length; j++) {
                    if (this.scene.children[i].children[j].name === "All points") {
                        this.scene.children[i].children[j]["material"].size = pointsize * 10;
                    }
                }
            }
            if (this.scene.children[i].name === "selects" && this.scene.children[i].type === "Points") {
                this.scene.children[i]["material"].size = pointsize;
            }
        }
        this.renderer.render(this.scene, this.camera);
        this.dataService.getpointsize(pointsize);
        //this.dataService.getmaterialpoint(pointsize);
    };
    //change radius
    GroupsComponent.prototype.changeradius = function (point) {
        this._materialpoint = point;
        if (this.dataService.SelectVisible !== 'Edges' && this.dataService.SelectVisible !== 'Wires') {
            for (var i = 0; i < this.scene.children.length; i++) {
                if (this.scene.children[i].name === "sphereInter") {
                    var geometry = new three__WEBPACK_IMPORTED_MODULE_0__["SphereGeometry"](point * 10);
                    this.scene.children[i]["geometry"] = geometry;
                }
            }
        }
        this.renderer.render(this.scene, this.camera);
        this.dataService.getradius(point);
    };
    GroupsComponent.prototype.changelight = function (_hue, _saturation, _lightness) {
        this.hue = _hue;
        this.saturation = _saturation;
        this.lightness = _lightness;
        var alight = this.alight;
        this.dataService.gethue(_hue);
        this.dataService.getsaturation(_saturation);
        this.dataService.getlightness(_lightness);
        this.alight.color.setHSL(_hue, _saturation, _lightness);
        this.renderer.render(this.scene, this.camera);
    };
    GroupsComponent.prototype.getgroupname = function () {
        this.groups = [];
        var allgroup = this.model.getAllGroups();
        for (var i = 0; i < allgroup.length; i++) {
            var group = {};
            group.parent = allgroup[i].getParentGroup().getName();
            group.props = allgroup[i].getProps();
            group.name = allgroup[i].getName();
            group.num_point = allgroup[i].getPoints().length;
            group.points = allgroup[i].getPoints();
            group.num_vertice = allgroup[i].getTopos(gs_json__WEBPACK_IMPORTED_MODULE_3__["EGeomType"].vertices).length;
            group.vertices = allgroup[i].getTopos(gs_json__WEBPACK_IMPORTED_MODULE_3__["EGeomType"].vertices);
            group.num_edge = allgroup[i].getTopos(gs_json__WEBPACK_IMPORTED_MODULE_3__["EGeomType"].edges).length;
            group.edges = allgroup[i].getTopos(gs_json__WEBPACK_IMPORTED_MODULE_3__["EGeomType"].edges);
            group.num_wire = allgroup[i].getTopos(gs_json__WEBPACK_IMPORTED_MODULE_3__["EGeomType"].wires).length;
            group.wires = allgroup[i].getTopos(gs_json__WEBPACK_IMPORTED_MODULE_3__["EGeomType"].wires);
            group.num_face = allgroup[i].getTopos(gs_json__WEBPACK_IMPORTED_MODULE_3__["EGeomType"].faces).length;
            group.faces = allgroup[i].getTopos(gs_json__WEBPACK_IMPORTED_MODULE_3__["EGeomType"].faces);
            group.num_object = allgroup[i].getObjs().length;
            group.objects = allgroup[i].getObjs();
            group.child = null;
            this.groups.push(group);
        }
        this.addchildren();
        //this.renderer.render(this.scene, this.camera);
    };
    GroupsComponent.prototype.addchildren = function () {
        for (var i = 0; i < this.groups.length; i++) {
            if (this.groups[i].parent !== null) {
                for (var j = 0; j < this.groups.length; j++) {
                    if (this.groups[i].parent === this.groups[j].name) {
                        this.groups[j].child = this.groups[i];
                    }
                }
            }
        }
    };
    GroupsComponent.prototype.selectpoint = function (group) {
        if (group.point !== 0 || group.child.num_point !== 0) {
            var pointinitial = false;
            var grouppoints = void 0;
            ;
            if (group.point !== 0) {
                grouppoints = group.points;
                for (var j = 0; j < this.scene.children.length; j++) {
                    for (var i = 0; i < grouppoints.length; i++) {
                        if (grouppoints[i].getLabel() === this.scene.children[j].userData.id) {
                            pointinitial = true;
                            this.scene.remove(this.scene.children[j]);
                        }
                    }
                }
            }
            if (group.child.num_point !== 0) {
                grouppoints = group.child.points;
                for (var j = 0; j < this.scene.children.length; j++) {
                    for (var i = 0; i < grouppoints.length; i++) {
                        if (grouppoints[i].getLabel() === this.scene.children[j].userData.id) {
                            pointinitial = true;
                            this.scene.remove(this.scene.children[j]);
                        }
                    }
                }
            }
            if (pointinitial === false) {
                for (var i = 0; i < grouppoints.length; i++) {
                    var point = {};
                    var label = grouppoints[i].getLabel();
                    //let id:string=grouppoints[i]._id;
                    var id = grouppoints[i].getID();
                    var verts_xyz = grouppoints[i].getLabelCentroid();
                    var geometry = new three__WEBPACK_IMPORTED_MODULE_0__["Geometry"]();
                    geometry.vertices.push(new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](verts_xyz[0], verts_xyz[1], verts_xyz[2]));
                    var pointsmaterial = new three__WEBPACK_IMPORTED_MODULE_0__["PointsMaterial"]({ color: 0x00ff00, size: 2 });
                    if (this.dataService.pointsize !== undefined) {
                        pointsmaterial.size = this.dataService.pointsize;
                    }
                    var points = new three__WEBPACK_IMPORTED_MODULE_0__["Points"](geometry, pointsmaterial);
                    points.userData.id = label;
                    //points["material"].needsUpdate=true;
                    points.name = "selects";
                    this.scene.add(points);
                    point.label = label;
                    point.id = id;
                    point.label_xyz = verts_xyz;
                    point.path = id;
                    point.type = "All points";
                }
            }
        }
    };
    GroupsComponent.prototype.selectvertice = function (group) {
        if (group.vertice !== 0) {
            var vertixinitial = false;
            var groupvertices = group.vertices;
            for (var j = 0; j < this.scene.children.length; j++) {
                for (var i = 0; i < groupvertices.length; i++) {
                    if (groupvertices[i].getLabel() === this.scene.children[j].userData.id) {
                        vertixinitial = true;
                        this.scene.remove(this.scene.children[j]);
                    }
                }
            }
            if (vertixinitial === false) {
                for (var i = 0; i < groupvertices.length; i++) {
                    var point = [];
                    var label = groupvertices[i].getLabel();
                    var id = groupvertices[i].getPoint().getID();
                    var verts_xyz = groupvertices[i].getLabelCentroid();
                    var geometry = new three__WEBPACK_IMPORTED_MODULE_0__["Geometry"]();
                    geometry.vertices.push(new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](verts_xyz[0], verts_xyz[1], verts_xyz[2]));
                    var pointsmaterial = new three__WEBPACK_IMPORTED_MODULE_0__["PointsMaterial"]({ color: 0x00ff00, size: 2 });
                    if (this.dataService.pointsize !== undefined) {
                        pointsmaterial.size = this.dataService.pointsize;
                    }
                    var points = new three__WEBPACK_IMPORTED_MODULE_0__["Points"](geometry, pointsmaterial);
                    points.userData.id = label;
                    //points["material"].needsUpdate=true;
                    points.name = "selects";
                    this.scene.add(points);
                    point.label = label;
                    point.id = id;
                    point.label_xyz = verts_xyz;
                    point.path = id;
                    point.type = "All points";
                }
            }
        }
    };
    GroupsComponent.prototype.selectedge = function (group) {
        if (group.edge !== 0) {
            var edgeinitial = false;
            var groupedges = group.edges;
            for (var j = 0; j < this.scene.children.length; j++) {
                for (var i = 0; i < groupedges.length; i++) {
                    if (groupedges[i].getLabel() === this.scene.children[j].userData.id) {
                        edgeinitial = true;
                        this.scene.remove(this.scene.children[j]);
                    }
                }
            }
            if (edgeinitial === false) {
                for (var i = 0; i < groupedges.length; i++) {
                    var edge = [];
                    var label = groupedges[i].getLabel();
                    var id = groupedges[i].getLabel();
                    var label_xyz = groupedges[i].getLabelCentroid();
                    var verts = groupedges[i].getVertices();
                    var verts_xyz = verts.map(function (v) { return v.getPoint().getPosition(); });
                    var geometry = new three__WEBPACK_IMPORTED_MODULE_0__["Geometry"]();
                    for (var i = 0; i < verts_xyz.length; i++) {
                        geometry.vertices.push(new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](verts_xyz[i][0], verts_xyz[i][1], verts_xyz[i][2]));
                    }
                    var material = new three__WEBPACK_IMPORTED_MODULE_0__["LineBasicMaterial"]({ color: 0x00ff00, side: three__WEBPACK_IMPORTED_MODULE_0__["DoubleSide"] });
                    var line = new three__WEBPACK_IMPORTED_MODULE_0__["Line"](geometry, material);
                    line.userData.id = edge.getLabel();
                    //line["material"].needsUpdate=true;
                    line.name = "selects";
                    this.scene.add(line);
                }
            }
        }
    };
    GroupsComponent.prototype.selectwire = function (group) {
        if (group.wire !== 0) {
            var groupwires = group.wires;
            var wireinitial = false;
            for (var j = 0; j < this.scene.children.length; j++) {
                for (var i = 0; i < groupwires.length; i++) {
                    if (groupwires[i].getLabel() === this.scene.children[j].userData.id) {
                        wireinitial = true;
                        this.scene.remove(this.scene.children[j]);
                    }
                }
            }
            if (wireinitial === false) {
                for (var i = 0; i < groupwires.length; i++) {
                    var wire = [];
                    var label = groupwires[i].getLabel();
                    var label_xyz = groupwires[i].getLabelCentroid();
                    var verts = groupwires[i].getVertices();
                    var verts_xyz = verts.map(function (v) { return v.getPoint().getPosition(); });
                    if (groupwires[i].isClosed()) {
                        verts_xyz.push(verts_xyz[0]);
                    }
                    var geometry = new three__WEBPACK_IMPORTED_MODULE_0__["Geometry"]();
                    for (var i = 0; i < verts_xyz.length; i++) {
                        geometry.vertices.push(new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](verts_xyz[i][0], verts_xyz[i][1], verts_xyz[i][2]));
                    }
                    var material = new three__WEBPACK_IMPORTED_MODULE_0__["LineBasicMaterial"]({ color: 0x00ff00, side: three__WEBPACK_IMPORTED_MODULE_0__["DoubleSide"] });
                    var line = new three__WEBPACK_IMPORTED_MODULE_0__["Line"](geometry, material);
                    line.userData.id = label;
                    //line["material"].needsUpdate=true;
                    line.name = "selects";
                    this.scene.add(line);
                }
            }
        }
    };
    GroupsComponent.prototype.selectface = function (group) {
        if (group.face !== 0) {
            var groupfaces = group.faces;
            var faceinitial = false;
            for (var j = 0; j < this.scene.children.length; j++) {
                for (var i = 0; i < groupfaces.length; i++) {
                    if (groupfaces[i].getLabel() === this.scene.children[j].userData.id) {
                        faceinitial = true;
                        this.scene.remove(this.scene.children[j]);
                    }
                }
            }
            if (faceinitial === false) {
                for (var i = 0; i < groupfaces.length; i++) {
                    var face = [];
                    var label = groupfaces[i].getLabel();
                    var label_xyz = face.getLabelCentroid();
                    var verts = face.getVertices();
                    var verts_xyz = verts.map(function (v) { return v.getPoint().getPosition(); });
                    var geometry = new three__WEBPACK_IMPORTED_MODULE_0__["Geometry"]();
                    for (var i = 0; i < verts_xyz.length; i++) {
                        geometry.vertices.push(new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](verts_xyz[i][0], verts_xyz[i][1], verts_xyz[i][2]));
                    }
                    var material = new three__WEBPACK_IMPORTED_MODULE_0__["LineBasicMaterial"]({ color: 0x00ff00, side: three__WEBPACK_IMPORTED_MODULE_0__["DoubleSide"] });
                    var line = new three__WEBPACK_IMPORTED_MODULE_0__["Line"](geometry, material);
                    line.userData.id = face.getLabel();
                    //line["material"].needsUpdate=true;
                    line.name = "selects";
                    this.scene.add(line);
                }
            }
        }
    };
    GroupsComponent.prototype.selectobject = function (group) {
        if (group.face !== 0) {
            this.selectface(group);
        }
        else if (group.wire !== 0) {
            this.selectwire(group);
        }
        else if (group.edge !== 0) {
            this.selectedge(group);
        }
        else if (group.point !== 0) {
            this.selectpoint(group);
        }
    };
    GroupsComponent = __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
            selector: 'app-groups',
            template: __webpack_require__(/*! ./groups.component.html */ "./src/app/mViewer/viewers/gs-viewer/toolwindow/groups.component.html"),
            styles: [__webpack_require__(/*! ./groups.component.css */ "./src/app/mViewer/viewers/gs-viewer/toolwindow/groups.component.css")]
        }),
        __metadata("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_1__["Injector"], _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]])
    ], GroupsComponent);
    return GroupsComponent;
}(_data_DataSubscriber__WEBPACK_IMPORTED_MODULE_2__["DataSubscriber"]));



/***/ }),

/***/ "./src/app/mViewer/viewers/gs-viewer/toolwindow/toolwindow.component.css":
/*!*******************************************************************************!*\
  !*** ./src/app/mViewer/viewers/gs-viewer/toolwindow/toolwindow.component.css ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#toolwindow{\r\n  background-color:white;\r\n  font-family:sans-serif;\r\n  width: 100%;\r\n  position:relative;\r\n}\r\n#gsattri-bar{\r\n  background-color: #f1f1f1 !important;\r\n  position:relative;\r\n  display: inline-flex;\r\n  width: 100%;\r\n}\r\n#toolbar{\r\n  background-color: #f1f1f1 !important;\r\n  width: 48%;\r\n  height: 30px;\r\n  margin:0px;\r\n  overflow: hidden !important;\r\n  font-family:sans-serif;\r\n  position: relative !important;\r\n}\r\n#pagination{\r\n  width: 48%;\r\n  height: 30px;\r\n  position: relative ;\r\n  top:unset !important;\r\n  margin: 0px;\r\n  background-color: #f1f1f1 !important;\r\n}\r\n.table_ojbs{\r\n  table-layout:fixed;\r\n  overflow-x: scroll !important;\r\n  font-family:sans-serif;\r\n}\r\n.Number{\r\n  overflow:hidden; \r\n  white-space:nowrap; \r\n}\r\n#toolview{\r\n  position:relative;\r\n  margin-top: 0px;\r\n  width: 100%;\r\n  float: left;\r\n}\r\n#selectedname{\r\n  font-size: 12px;\r\n  vertical-align: middle;\r\n}\r\n#gsv-point{\r\n  margin-left:25px;\r\n}\r\n#gsv-selected{\r\n  margin-left:30px;\r\n}\r\n.gsv-toolbar{\r\n  font-size:15px;\r\n  background-color:transparent;\r\n  border:0;\r\n  font-family:sans-serif;\r\n  padding-top:1px;\r\n  padding-right: 6px;\r\n  padding-bottom: 1px;\r\n  padding-left: 6px;\r\n  align-items: flex-start;\r\n  text-align: center;\r\n  cursor: default;\r\n  color: unset;\r\n  margin-right: 0px;\r\n  margin-left: 0px;\r\n  margin-bottom: 1px;\r\n  margin-top: 1px;\r\n  box-sizing: border-box;\r\n  border-width: unset;\r\n  border-style: unset;\r\n  border-color: unset;\r\n  -o-border-image: unset;\r\n     border-image: unset;\r\n}\r\n.visible{\r\n  background-color: white !important;\r\n  color:#395d73;\r\n}\r\n.selectvisible{\r\n  background-color:  white !important;\r\n  color:#395d73;\r\n}\r\n#table{\r\n  width:100% ;\r\n  height: 15px;\r\n}\r\n#tablename{\r\n  width:100% ;\r\n  height: 15px;\r\n  color:grey;\r\n}\r\n.table_text{\r\n  width:180px;\r\n  word-wrap:break-word;\r\n  font-weight: normal;\r\n}\r\n#numberbutton{\r\n  width:100%;\r\n  border:0;\r\n}\r\n#attrib{\r\n  overflow: hidden !important;\r\n  text-overflow: ellipsis !important;\r\n  table-layout:fixed !important;\r\n  white-space: nowrap !important;\r\n}\r\n/*.selectid{\r\n  background-color:#66CCFF;\r\n}*/\r\n#select{\r\n  position: relative;\r\n  float:right;\r\n  margin-right: 30px;\r\n}\r\n.my-pagination /deep/ .ngx-pagination{\r\n  margin:0px !important;\r\n  color:black !important;\r\n  float: right;\r\n  margin-right:20px !important;\r\n}\r\n.my-pagination /deep/ .ngx-pagination .current {\r\n  margin-top:0px;\r\n  color:black;\r\n  background-color: white;\r\n}\r\n"

/***/ }),

/***/ "./src/app/mViewer/viewers/gs-viewer/toolwindow/toolwindow.component.html":
/*!********************************************************************************!*\
  !*** ./src/app/mViewer/viewers/gs-viewer/toolwindow/toolwindow.component.html ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<div id=\"toolwindow\">\r\n  <div id=\"gsattri-bar\" >\r\n  <div id=\"toolbar\">\r\n    <div style=\"width: 350px;position: relative;\">\r\n    <button id=\"gsv-point\" class=\"gsv-toolbar\" [class.visible]=\"Visible === 'Points'\" (click)=\"point(Visible)\"><span matTooltip=\"View Point Attributes\">P</span></button>\r\n    <button id=\"gsv-vertice\" class=\"gsv-toolbar\" [class.visible]=\"Visible === 'Vertices'\" (click)=\"vertice(Visible)\"><span matTooltip=\"View Vertice Attributes\">V</span></button>\r\n    <button id=\"gsv-edge\" class=\"gsv-toolbar\" [class.visible]=\"Visible === 'Edges'\" (click)=\"edge(Visible)\"><span matTooltip=\"View Edge Attributes\">E</span></button>\r\n    <button id=\"gsv-wire\" class=\"gsv-toolbar\" [class.visible]=\"Visible === 'Wires'\" (click)=\"wire(Visible)\"><span matTooltip=\"View Wire Attributes\">W</span></button>\r\n    <button id=\"gsv-face\" class=\"gsv-toolbar\" [class.visible]=\"Visible === 'Faces'\" (click)=\"face(Visible)\"><span matTooltip=\"View Face Attributes\">F</span></button>\r\n    <button id=\"gsv-object\" class=\"gsv-toolbar\" [class.visible]=\"Visible === 'Objs'\" (click)=\"object(Visible)\"><span matTooltip=\"View Object Attributes\">O</span></button>\r\n    <input id=\"gsv-selected\" class=\"gsv-toolbar\" type=\"checkbox\" (click)=\"changeselected()\">\r\n    <label id=\"selectedname\" value=\"selected\">Show selected only</label>\r\n  </div>\r\n  </div>\r\n  <div id=\"pagination\" >\r\n    <pagination-controls *ngIf=\"Visible === 'Points'\" class=\"my-pagination\" (pageChange)=\"p1 = $event\"></pagination-controls> \r\n    <pagination-controls *ngIf=\"Visible === 'Vertices'\" class=\"my-pagination\" (pageChange)=\"p2 = $event\"></pagination-controls> \r\n    <pagination-controls *ngIf=\"Visible === 'Edges'\" class=\"my-pagination\" (pageChange)=\"p3 = $event\"></pagination-controls> \r\n    <pagination-controls *ngIf=\"Visible === 'Wires'\" class=\"my-pagination\" (pageChange)=\"p4 = $event\"></pagination-controls> \r\n    <pagination-controls *ngIf=\"Visible === 'Faces'\" class=\"my-pagination\" (pageChange)=\"p5 = $event\"></pagination-controls>\r\n    <pagination-controls *ngIf=\"Visible === 'Objs'\" class=\"my-pagination\" (pageChange)=\"p6 = $event\"></pagination-controls>  \r\n  </div>\r\n</div>\r\n  <div id=\"toolview\">\r\n    <div *ngIf=\"Visible === 'Points'\">\r\n      <table matSort border=\"1\" cellspacing=\"0\" cellpadding=\"0\" bordercolor=\"#d0d0d0\" (matSortChange)=\"sortData($event)\">\r\n        <tr>\r\n          <th mat-sort-header=\"id\" align=center width=\"180px\"><div class=\"table_text\" >Points ID <input type=\"checkbox\" id=\"id\" class=\"checkbox\" style=\"float:right\" [checked]=\"checkpointid\" (click)=\"checkbox()\"></div></th>\r\n          <th mat-sort-header=\"x\" width=\"180px\" align=center><div class=\"table_text\">X<input type=\"checkbox\" style=\"float:right\" id=\"X\"  class=\"checkbox\" [checked]=\"checkX\" (click)=\"checkbox()\"></div></th>\r\n          <th mat-sort-header=\"y\" width=\"180px\" align=center><div class=\"table_text\">Y<input type=\"checkbox\" style=\"float:right\" id=\"Y\" class=\"checkbox\" [checked]=\"checkY\" (click)=\"checkbox()\"></div></th>\r\n          <th mat-sort-header=\"z\" width=\"180px\" align=center><div class=\"table_text\">Z<input type=\"checkbox\" style=\"float:right\" id=\"Z\" class=\"checkbox\" [checked]=\"checkZ\" (click)=\"checkbox()\"></div></th>\r\n          <th mat-sort-header={{name}} align=center width=\"180px\" class=\"checkbox\" *ngFor=\"let name of point_name;let idx=index\"><div class=\"table_text\" >{{name}}<input type=\"checkbox\" id={{name}} style=\"float:right\" (click)=\"checkbox()\"></div></th>\r\n      <!-- </table>\r\n      <table border=\"1\" cellspacing=\"0\" cellpadding=\"0\"  bordercolor=\"#d0d0d0\" *ngFor=\"let datascale of attribute| paginate: { itemsPerPage: 50, currentPage: p1 }\"> -->\r\n        <tr  *ngFor=\"let datascale of attribute| paginate: { itemsPerPage: 50, currentPage: p1 }\">\r\n          <td name=\"Number\" align=center  width=\"180px\"><div class=\"table_text\"><button width=\"180px\" id=\"numberbutton\" (click)=Onselect(datascale)>{{datascale.id}}</button></div></td>\r\n          <td width=\"180px\" align=center><div class=\"table_text\">{{datascale.x}}</div></td>\r\n          <td width=\"180px\" align=center><div class=\"table_text\">{{datascale.y}}</div></td>\r\n          <td width=\"180px\" align=center><div class=\"table_text\">{{datascale.z}}</div></td>\r\n          <td  id=\"attrib\" width=\"180px\" align=center *ngFor=\"let name of point_name; let idx=index\"><div class=\"table_text\" >{{datascale[idx]}}</div></td> \r\n        <tr>\r\n      </table>\r\n    </div>\r\n    <div *ngIf=\"Visible === 'Vertices'\">\r\n      <table matSort border=\"1\" cellspacing=\"0\" cellpadding=\"0\" bordercolor=\"#d0d0d0\" (matSortChange)=\"sortData($event)\">\r\n        <tr>\r\n          <th mat-sort-header=\"vertixlabel\" align=center width=\"180px\"><div class=\"table_text\">Vertices Label<input type=\"checkbox\" id=\"vertixid\" style=\"float:right\" [checked]=\"vertixid\" (click)=\"checkbox()\"></div></th>\r\n          <th mat-sort-header=\"pointid\" align=center width=\"180px\"><div class=\"table_text\">Points ID<input type=\"checkbox\" id=\"pointid\" style=\"float:right\"  [checked]=\"pointid\" (click)=\"checkbox()\"></div></th>\r\n          <th mat-sort-header={{name}} align=center width=\"180px\" *ngFor=\"let name of vertex_name\"><div class=\"table_text\">{{name}}<input type=\"checkbox\" id={{name}} style=\"float:right\" (click)=\"checkbox()\"></div></th>\r\n        </tr>\r\n      <!-- </table>\r\n      <table border=\"1\" cellspacing=\"0\" cellpadding=\"0\" bordercolor=\"#d0d0d0\" *ngFor=\"let datascale of attribute| paginate: { itemsPerPage: 50, currentPage: p2 }\"> -->\r\n        <tr *ngFor=\"let datascale of attribute| paginate: { itemsPerPage: 50, currentPage: p2 }\">\r\n          <td name=\"Number\" align=center  width=\"180px\"><div class=\"table_text\"><button  id=\"numberbutton\">{{datascale.vertixlabel}}</button></div></td>\r\n          <td  align=center  width=\"180px\"><div class=\"table_text\">{{datascale.pointid}}</div></td>\r\n          <td  id=\"attrib\" width=\"180px\" align=center *ngFor=\"let name of vertex_name; let idx=index\"><div sclass=\"table_text\">{{datascale[idx]}}</div></td> \r\n        </tr>\r\n      </table>\r\n    </div>\r\n    <div *ngIf=\"Visible === 'Edges'\">\r\n      <table matSort border=\"1\" cellspacing=\"0\" cellpadding=\"0\"  bordercolor=\"#d0d0d0\" (matSortChange)=\"sortData($event)\">\r\n        <tr>\r\n          <th mat-sort-header=\"label\" align=center width=\"180px\"><div class=\"table_text\">Edge ID<input type=\"checkbox\" style=\"float:right\" id=\"edgeid\" (click)=\"checkbox()\"></div></th>\r\n          <th mat-sort-header={{name}} align=center width=\"180px\" *ngFor=\"let name of edge_name\"><div class=\"table_text\">{{name}}<input type=\"checkbox\" style=\"float:right\" id={{name}} (click)=\"checkbox()\"></div></th> \r\n        </tr>\r\n      <!--</table>\r\n       <table border=\"1\" cellspacing=\"0\" cellpadding=\"0\"  bordercolor=\"#d0d0d0\" *ngFor=\"let datascale of attribute| paginate: { itemsPerPage: 50, currentPage: p3 }\" > -->\r\n        <tr *ngFor=\"let datascale of attribute| paginate: { itemsPerPage: 50, currentPage: p3 }\">\r\n          <td name=\"Number\" align=center  width=\"180px\"><div class=\"table_text\"><button  id=\"numberbutton\">{{datascale.label}}</button></div></td>\r\n          <td  id=\"attrib\" width=\"180px\" align=center *ngFor=\"let name of edge_name; let idx=index\"><div class=\"table_text\">{{datascale[idx]}}</div></td>\r\n        </tr>\r\n      </table>\r\n    </div>\r\n    <div *ngIf=\"Visible === 'Wires'\">\r\n      <table matSort border=\"1\" cellspacing=\"0\" cellpadding=\"0\"  bordercolor=\"#d0d0d0\" (matSortChange)=\"sortData($event)\">\r\n        <tr>\r\n          <th mat-sort-header=\"label\" align=center width=\"180px\"><div class=\"table_text\">Wire ID<input type=\"checkbox\" style=\"float:right\" (click)=\"checkbox()\"></div></th>\r\n          <th mat-sort-header={{name}} align=center width=\"180px\" *ngFor=\"let name of wire_name\"><div class=\"table_text\">{{name}}<input type=\"checkbox\" style=\"float:right\" id={{name}} (click)=\"checkbox()\"></div></th> \r\n        </tr>\r\n      <!-- </table>\r\n      <table border=\"1\" cellspacing=\"0\" cellpadding=\"0\"  bordercolor=\"#d0d0d0\" *ngFor=\"let datascale of attribute| paginate: { itemsPerPage: 50, currentPage: p4 }\" > -->\r\n        <tr *ngFor=\"let datascale of attribute| paginate: { itemsPerPage: 50, currentPage: p4 }\">\r\n          <td name=\"Number\" align=center  width=\"180px\"><div class=\"table_text\"><button  id=\"numberbutton\">{{datascale.label}}</button></div></td>\r\n          <td  id=\"attrib\" width=\"180px\" align=center *ngFor=\"let name of wire_name; let idx=index\"><div class=\"table_text\">{{datascale[idx]}}</div></td>\r\n        </tr>\r\n      </table>\r\n    </div>\r\n    <div *ngIf=\"Visible === 'Faces'\">\r\n      <table matSort border=\"1\" cellspacing=\"0\" cellpadding=\"0\"  bordercolor=\"#d0d0d0\" (matSortChange)=\"sortData($event)\">\r\n        <tr>\r\n          <th mat-sort-header=\"label\" align=center width=\"180px\"><div class=\"table_text\">Face ID<input type=\"checkbox\" style=\"float:right\" id=\"checkface\" [checked]=\"checkface\" (click)=\"checkbox()\"></div></th>\r\n          <th mat-sort-header={{name}} align=center width=\"180px\" *ngFor=\"let name of face_name\"><div class=\"table_text\">{{name}}<input type=\"checkbox\" style=\"float:right\" id={{name}} (click)=\"checkbox()\"></div></th> \r\n        </tr>\r\n      <!-- </table>\r\n      <table border=\"1\" cellspacing=\"0\" cellpadding=\"0\"  bordercolor=\"#d0d0d0\" *ngFor=\"let datascale of attribute| paginate: { itemsPerPage: 50, currentPage: p5 }\" > -->\r\n        <tr *ngFor=\"let datascale of attribute| paginate: { itemsPerPage: 50, currentPage: p5 }\">\r\n          <td name=\"Number\" align=center  width=\"180px\"><div class=\"table_text\"><button  id=\"numberbutton\">{{datascale.label}}</button></div></td>\r\n          <td  id=\"attrib\" width=\"180px\" align=center *ngFor=\"let name of face_name; let idx=index\"><div class=\"table_text\">{{datascale[idx]}}</div></td>\r\n        </tr>\r\n      </table>\r\n    </div>\r\n    <div *ngIf=\"Visible === 'Objs'\">\r\n      <table matSort border=\"1\" cellspacing=\"0\" cellpadding=\"0\"  bordercolor=\"#d0d0d0\" class=\"table_ojbs\" (matSortChange)=\"sortData($event)\">\r\n        <tr>\r\n          <th mat-sort-header=\"label\" name=\"Number\" align=center width=\"180px\"><div class=\"table_text\">Object ID<input type=\"checkbox\" style=\"float:right\" id=\"checkobj\" [checked]=\"checkobj\" (click)=\"checkbox()\"></div></th>\r\n          <th mat-sort-header={{name}} align=center width=\"180px\" *ngFor=\"let name of obj_name\" ><div class=\"table_text\">{{name}}<input type=\"checkbox\" style=\"float:right\" (click)=\"checkbox()\"></div></th>\r\n        </tr>\r\n      <!-- </table>\r\n      <table border=\"1\" cellspacing=\"0\" cellpadding=\"0\"  bordercolor=\"#d0d0d0\" *ngFor=\"let datascale of attribute| paginate: { itemsPerPage: 50, currentPage: p6 } \" class=\"table_ojbs\" > -->\r\n        <tr *ngFor=\"let datascale of attribute| paginate: { itemsPerPage: 50, currentPage: p6 } \">\r\n          <td name=\"Number\" align=center  width=\"180px\"><div class=\"table_text\"><button  id=\"numberbutton\">{{datascale.label}}</button></div></td>\r\n          <td  id=\"attrib\" width=\"180px\" align=center *ngFor=\"let name of obj_name; let idx=index\"><div class=\"table_text\">{{datascale[idx]}}</div></td>\r\n        </tr>\r\n      </table>\r\n    </div>\r\n  </div>\r\n"

/***/ }),

/***/ "./src/app/mViewer/viewers/gs-viewer/toolwindow/toolwindow.component.ts":
/*!******************************************************************************!*\
  !*** ./src/app/mViewer/viewers/gs-viewer/toolwindow/toolwindow.component.ts ***!
  \******************************************************************************/
/*! exports provided: ToolwindowComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ToolwindowComponent", function() { return ToolwindowComponent; });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var gs_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! gs-json */ "./node_modules/gs-json/dist2015/index.js");
/* harmony import */ var gs_json__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(gs_json__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _data_DataSubscriber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../data/DataSubscriber */ "./src/app/mViewer/viewers/gs-viewer/data/DataSubscriber.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




var ToolwindowComponent = /** @class */ (function (_super) {
    __extends(ToolwindowComponent, _super);
    function ToolwindowComponent(injector, myElement) {
        var _this = _super.call(this, injector) || this;
        _this.Visible = "Objs";
        _this.scene = _this.dataService.getScene();
        _this.renderer = _this.dataService.getRenderer();
        _this.camera = _this.dataService.getCamera();
        _this.selectedVisible = false;
        _this.attribute = [];
        _this.selectObj = [];
        _this.checkname = [];
        _this.myElement = myElement;
        return _this;
    }
    ToolwindowComponent.prototype.ngOnInit = function () {
        this.model = this.dataService.getGsModel();
        this.Visible = this.dataService.visible;
        this.updateModel();
    };
    ToolwindowComponent.prototype.notify = function (message) {
        if (message == "model_update" && this.scene) {
            //this.updateModel();
            this.ngOnInit();
        }
        this.selectObj = [];
        for (var i = 0; i < this.dataService.selecting.length; i++) {
            for (var n = 0; n < this.scene.children.length; n++) {
                if (this.scene.children[n].type === "Scene") {
                    if (this.dataService.selecting[i].uuid === this.scene.children[n].children[0].uuid) {
                        this.selectObj.push(this.scene.children[n].children[0].parent);
                    }
                }
            }
        }
        if (this.selectedVisible == true) {
            if (this.Visible === "Objs")
                this.objectcheck();
            if (this.Visible === "Faces")
                this.facecheck();
            if (this.Visible === "Wires")
                this.wirecheck();
            if (this.Visible === "Edges")
                this.edgecheck();
            if (this.Visible === "Vertices")
                this.verticecheck();
            if (this.Visible === "Points")
                this.pointcheck();
        }
    };
    ToolwindowComponent.prototype.updateModel = function () {
        if (this.model !== undefined) {
            try {
                this.scene_and_maps = this.dataService.getscememaps();
                this.object(this.Visible);
                this.getvertices();
            }
            catch (ex) {
                console.error("Error displaying model:", ex);
            }
        }
    };
    ToolwindowComponent.prototype.getpoints = function () {
        var attrubtepoints = [];
        this.point_name = [];
        if (this.scene_and_maps !== undefined) {
            if (this.scene_and_maps.points_map !== null && this.scene_and_maps.points_map.size !== 0 && this.scene_and_maps.points_map !== undefined) {
                var point_attribs = this.model.findAttribs(gs_json__WEBPACK_IMPORTED_MODULE_2__["EGeomType"].points);
                if (point_attribs.length !== 0) {
                    for (var j = 0; j < point_attribs.length; j++) {
                        this.point_name.push(point_attribs[0].getName());
                    }
                }
                for (var i = 0; i < this.scene_and_maps.points_map.size; i++) {
                    var points = this.model.getGeom().getPoint(i);
                    var label = points.getLabel();
                    var verts_xyz = points.getLabelCentroid();
                    var attributepoint = [];
                    if (verts_xyz !== undefined) {
                        attributepoint.id = label;
                        attributepoint.x = verts_xyz[0];
                        attributepoint.y = verts_xyz[1];
                        attributepoint.z = verts_xyz[2];
                        if (point_attribs.length !== 0) {
                            for (var j = 0; j < point_attribs.length; j++) {
                                attributepoint[j] = points.getAttribValue(point_attribs[j]);
                            }
                        }
                        attrubtepoints.push(attributepoint);
                    }
                }
            }
        }
        return attrubtepoints;
    };
    ToolwindowComponent.prototype.getvertices = function () {
        var attributevertix = [];
        var points = this.getpoints();
        this.vertex_name = [];
        if (this.scene_and_maps !== undefined) {
            if (this.scene_and_maps.vertices_map !== null && this.scene_and_maps.vertices_map.size !== 0 && this.scene_and_maps.vertices_map !== undefined) {
                var vertex_attribs = this.model.findAttribs(gs_json__WEBPACK_IMPORTED_MODULE_2__["EGeomType"].vertices);
                if (vertex_attribs.length !== 0) {
                    for (var n = 0; n < vertex_attribs.length; n++) {
                        this.vertex_name.push(vertex_attribs[n].getName());
                    }
                }
                for (var i = 0; i < this.scene_and_maps.vertices_map.size; i++) {
                    var path = this.scene_and_maps.vertices_map.get(i);
                    var vertices = this.model.getGeom().getTopo(path);
                    var attributes = [];
                    var label = vertices.getLabel();
                    var verts_xyz = vertices.getLabelCentroid();
                    var attributes = [];
                    for (var j = 0; j < points.length; j++) {
                        if (points[j].x === verts_xyz[0] && points[j].y === verts_xyz[1] && points[j].z === verts_xyz[2]) {
                            attributes.pointid = points[j].id;
                        }
                    }
                    attributes.vertixlabel = label;
                    attributes.path = path;
                    if (vertex_attribs.length !== 0) {
                        for (var j = 0; j < vertex_attribs.length; j++) {
                            //attributes[j]=vertices.getAttribValue(vertex_attribs[j]);
                        }
                    }
                    attributevertix.push(attributes);
                }
                this.dataService.addattrvertix(attributevertix);
            }
        }
        return attributevertix;
    };
    ToolwindowComponent.prototype.getedges = function () {
        var attributeedge = [];
        this.edge_name = [];
        var edgelable = [];
        if (this.scene_and_maps !== undefined) {
            if (this.scene_and_maps.edges_map !== null && this.scene_and_maps.edges_map.size !== 0 && this.scene_and_maps.edges_map !== undefined) {
                var edge_attribs = this.model.findAttribs(gs_json__WEBPACK_IMPORTED_MODULE_2__["EGeomType"].edges);
                if (edge_attribs.length !== 0) {
                    for (var j = 0; j < edge_attribs.length; j++) {
                        this.edge_name.push(edge_attribs[j].getName());
                    }
                }
                for (var i = 0; i < this.scene_and_maps.edges_map.size; i++) {
                    var path = this.scene_and_maps.edges_map.get(i);
                    var edge = this.model.getGeom().getTopo(path);
                    var attributes = [];
                    var label = edge.getLabel();
                    attributes.label = label;
                    if (edgelable.indexOf(label) === -1) {
                        edgelable.push(label);
                        if (edge_attribs.length !== 0) {
                            for (var j = 0; j < edge_attribs.length; j++) {
                                //attributes[j]=edge.getAttribValue(edge_attribs[j]);
                            }
                        }
                        attributeedge.push(attributes);
                    }
                }
            }
        }
        return attributeedge;
    };
    ToolwindowComponent.prototype.getwires = function () {
        var attributewire = [];
        this.wire_name = [];
        var wirelabel = [];
        if (this.scene_and_maps !== undefined) {
            if (this.scene_and_maps.wires_map !== null && this.scene_and_maps.wires_map.size !== 0 && this.scene_and_maps.wires_map !== undefined) {
                var wire_attribs = this.model.findAttribs(gs_json__WEBPACK_IMPORTED_MODULE_2__["EGeomType"].wires);
                if (wire_attribs.length !== 0) {
                    for (var j = 0; j < wire_attribs.length; j++) {
                        this.wire_name.push(wire_attribs[j].getName());
                    }
                }
                for (var i = 0; i < this.scene_and_maps.wires_map.size; i++) {
                    var path = this.scene_and_maps.wires_map.get(i);
                    var wire = this.model.getGeom().getTopo(path);
                    var attributes = [];
                    var label = wire.getLabel();
                    attributes.label = label;
                    if (wirelabel.indexOf(label) === -1) {
                        wirelabel.push(label);
                        if (wire_attribs.length !== 0) {
                            for (var j = 0; j < wire_attribs.length; j++) {
                                attributes[j] = wire.getAttribValue(wire_attribs[j]);
                            }
                        }
                        attributewire.push(attributes);
                    }
                }
            }
        }
        return attributewire;
    };
    ToolwindowComponent.prototype.getfaces = function () {
        var attributeface = [];
        this.face_name = [];
        var facelabel = [];
        if (this.scene_and_maps !== undefined) {
            if (this.scene_and_maps.faces_map !== null && this.scene_and_maps.faces_map.size !== 0 && this.scene_and_maps.faces_map !== undefined) {
                var face_attribs = this.model.findAttribs(gs_json__WEBPACK_IMPORTED_MODULE_2__["EGeomType"].faces);
                if (face_attribs.length !== 0) {
                    for (var j = 0; j < face_attribs.length; j++) {
                        this.face_name.push(face_attribs[j].getName());
                    }
                }
                for (var i = 0; i < this.scene_and_maps.faces_map.size; i++) {
                    var path = this.scene_and_maps.faces_map.get(i);
                    var face = this.model.getGeom().getTopo(path);
                    var attributes = [];
                    var label = face.getLabel();
                    attributes.label = label;
                    if (facelabel.indexOf(label) === -1) {
                        facelabel.push(label);
                        if (face_attribs.length !== 0) {
                            for (var j = 0; j < face_attribs.length; j++) {
                                attributes[j] = face.getAttribValue(face_attribs[j]);
                            }
                        }
                        attributeface.push(attributes);
                    }
                }
            }
        }
        return attributeface;
    };
    ToolwindowComponent.prototype.getoject = function () {
        var attributeobject = [];
        this.obj_name = [];
        this.attrib_name = [];
        var atrib = [];
        if (this.scene_and_maps !== undefined) {
            if (this.scene_and_maps.faces_map !== null && this.scene_and_maps.faces_map.size !== 0 && this.scene_and_maps.faces_map !== undefined) {
                var obj_attribs = this.model.findAttribs(gs_json__WEBPACK_IMPORTED_MODULE_2__["EGeomType"].objs);
                if (obj_attribs.length !== 0) {
                    for (var j = 0; j < obj_attribs.length; j++) {
                        this.obj_name.push(obj_attribs[j].getName());
                        for (var i = 0; i < this.scene_and_maps.faces_map.size; i++) {
                            var path = this.scene_and_maps.faces_map.get(i);
                            var obj = this.model.getGeom().getObj(path.id);
                            atrib[j] = obj.getAttribValue(obj_attribs[j]);
                            this.attrib_name.push(atrib[j]);
                        }
                    }
                }
                for (var i = 0; i < this.scene_and_maps.faces_map.size; i++) {
                    var path = this.scene_and_maps.faces_map.get(i);
                    if (i === 0 || path.id !== this.scene_and_maps.faces_map.get(i - 1).id) {
                        var attribute = [];
                        var label = "o" + path.id;
                        attribute.label = label;
                        for (var j = 0; j < obj_attribs.length; j++) {
                            var obj = this.model.getGeom().getObj(path.id);
                            attribute[j] = obj.getAttribValue(obj_attribs[j]);
                        }
                        attributeobject.push(attribute);
                    }
                }
            }
        }
        return attributeobject;
    };
    ToolwindowComponent.prototype.getchildren = function () {
        var children;
        for (var i = 0; i < this.scene.children.length; i++) {
            if (this.scene.children[i].name == "Scene") {
                children = this.scene.children[i].children;
                break;
            }
            if (i == this.scene.children.length - 1) {
                return [];
            }
        }
        return children;
    };
    ToolwindowComponent.prototype.getscenechildren = function () {
        var scenechildren = [];
        for (var n = 0; n < this.scene.children.length; n++) {
            if (this.scene.children[n].type === "Scene") {
                for (var i = 0; i < this.scene.children[n].children.length; i++) {
                    scenechildren.push(this.scene.children[n].children[i]);
                }
            }
        }
        return scenechildren;
    };
    ToolwindowComponent.prototype.point = function (Visible) {
        this.Visible = "Points";
        this.attribute = this.getpoints();
        if (this.selectedVisible == true) {
            this.pointcheck();
        }
        if (this.dataService.checkpointid == undefined) {
            this.dataService.checkpointid = false;
        }
        else {
            this.checkpointid = this.dataService.checkpointid;
        }
        if (this.dataService.checkX == undefined) {
            this.dataService.checkX = false;
        }
        else {
            this.checkX = this.dataService.checkX;
        }
        if (this.dataService.checkY == undefined) {
            this.dataService.checkY = false;
        }
        else {
            this.checkY = this.dataService.checkY;
        }
        if (this.dataService.checkZ == undefined) {
            this.dataService.checkZ = false;
        }
        else {
            this.checkZ = this.dataService.checkZ;
        }
        this.dataService.visible = this.Visible;
        //this.clearsprite();
        /*this.sortedData=[];
        for(var i=0;i<this.attribute.length;i++){
          var datas={};
          datas["id"]=this.attribute[i].id;
          datas["x"]=this.attribute[i].x;
          datas["y"]=this.attribute[i].y;
          datas["z"]=this.attribute[i].z;
          this.sortedData[i]=datas;
        }*/
    };
    ToolwindowComponent.prototype.pointcheck = function () {
        this.attribute = [];
        var attributes = this.pointtovertix();
        var points = this.getpoints();
        for (var i = 0; i < points.length; i++) {
            for (var j = 0; j < attributes.length; j++) {
                if (points[i].id === attributes[j].pointid && this.attribute.indexOf(points[i]) === -1) {
                    this.attribute.push(points[i]);
                }
            }
        }
    };
    ToolwindowComponent.prototype.pointtovertix = function () {
        var attributes = [];
        var vertices = this.getvertices();
        var selecting = this.dataService.getselecting();
        var char;
        var labels = [];
        if (selecting.length !== 0) {
            for (var i = 0; i < selecting.length; i++) {
                for (var j = 0; j < vertices.length; j++) {
                    if (selecting[i]["id"] === vertices[j].pointid && attributes.indexOf(vertices[j]) == -1) {
                        attributes.push(vertices[j]);
                    }
                    if (selecting[i]["type"] === "All edges") {
                        var edge = this.model.getGeom().getTopo(selecting[i]["path"]);
                        var verts = edge.getVertices();
                        for (var n = 0; n < verts.length; n++) {
                            var label = verts[n].getLabel();
                            if (label === vertices[j].vertixlabel && attributes.indexOf(vertices[j]) == -1) {
                                attributes.push(vertices[j]);
                            }
                        }
                    }
                    if (selecting[i]["type"] === "All wires") {
                        var wire = this.model.getGeom().getTopo(selecting[i]["path"]);
                        var verts = wire.getVertices();
                        for (var n = 0; n < verts.length; n++) {
                            var label = verts[n].getLabel();
                            if (label === vertices[j].vertixlabel && attributes.indexOf(vertices[j]) == -1) {
                                attributes.push(vertices[j]);
                            }
                        }
                    }
                    if (selecting[i]["type"] === "All faces") {
                        var face = this.model.getGeom().getTopo(selecting[i]["path"]);
                        var verts = face.getVertices();
                        for (var n = 0; n < verts.length; n++) {
                            var label = verts[n].getLabel();
                            if (label === vertices[j].vertixlabel && attributes.indexOf(vertices[j]) == -1) {
                                attributes.push(vertices[j]);
                            }
                        }
                    }
                    if (selecting[i]["type"] === "All objs") {
                        var face = this.model.getGeom().getTopo(selecting[i]["path"]);
                        var faces = face.getObj().getFaces();
                        for (var f = 0; f < faces.length; f++) {
                            var verts = faces[f].getVertices();
                            for (var n = 0; n < verts.length; n++) {
                                var label = verts[n].getLabel();
                                if (label === vertices[j].vertixlabel && this.attribute.indexOf(vertices[j]) == -1) {
                                    attributes.push(vertices[j]);
                                }
                            }
                        }
                    }
                }
            }
        }
        return attributes;
    };
    ToolwindowComponent.prototype.vertice = function (Visible) {
        this.Visible = "Vertices";
        this.attribute = this.getvertices();
        if (this.selectedVisible == true) {
            this.verticecheck();
        }
        if (this.dataService.checkvertixid == undefined) {
            this.dataService.checkvertixid = false;
        }
        else {
            this.vertixid = this.dataService.checkvertixid;
        }
        if (this.dataService.pointid == undefined) {
            this.dataService.pointid = false;
        }
        else {
            this.pointid = this.dataService.pointid;
        }
        this.dataService.visible = this.Visible;
        //this.clearsprite();
    };
    ToolwindowComponent.prototype.verticecheck = function () {
        this.attribute = this.pointtovertix();
    };
    ToolwindowComponent.prototype.edge = function (Visible) {
        this.Visible = "Edges";
        this.attribute = [];
        this.attribute = this.getedges();
        if (this.selectedVisible == true) {
            this.edgecheck();
        }
        this.dataService.visible = this.Visible;
        //this.clearsprite();
    };
    ToolwindowComponent.prototype.edgecheck = function () {
        this.attribute = [];
        var edges = this.getedges();
        var selecting = this.dataService.getselecting();
        if (selecting.length !== 0) {
            for (var i = 0; i < selecting.length; i++) {
                for (var j = 0; j < edges.length; j++) {
                    if (selecting[i].type === "All edges") {
                        if (selecting[i]["id"].indexOf(edges[j].label) > -1) {
                            this.attribute.push(edges[j]);
                        }
                    }
                    if (selecting[i]["type"] === "All faces") {
                        var face = this.model.getGeom().getTopo(selecting[i]["path"]);
                        var verts = face.getEdges();
                        for (var n = 0; n < verts.length; n++) {
                            var label = verts[n].getLabel();
                            if (label === edges[j].label && this.attribute.indexOf(edges[j]) == -1) {
                                this.attribute.push(edges[j]);
                            }
                        }
                    }
                    if (selecting[i]["type"] === "All objs") {
                        var face = this.model.getGeom().getTopo(selecting[i]["path"]);
                        var faces = face.getObj().getFaces();
                        for (var f = 0; f < faces.length; f++) {
                            var verts = faces[f].getEdges();
                            for (var n = 0; n < verts.length; n++) {
                                var label = verts[n].getLabel();
                                if (label === edges[j].label && this.attribute.indexOf(edges[j]) == -1) {
                                    this.attribute.push(edges[j]);
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    ToolwindowComponent.prototype.wire = function (Visible) {
        this.Visible = "Wires";
        this.attribute = [];
        this.attribute = this.getwires();
        if (this.selectedVisible == true) {
            this.wirecheck();
        }
        this.dataService.visible = this.Visible;
    };
    ToolwindowComponent.prototype.wirecheck = function () {
        this.attribute = [];
        var wires = this.getwires();
        var selecting = this.dataService.getselecting();
        if (selecting.length !== 0) {
            for (var i = 0; i < selecting.length; i++) {
                for (var j = 0; j < wires.length; j++) {
                    if (selecting[i]["id"] === wires[j].label) {
                        this.attribute.push(wires[j]);
                    }
                    if (selecting[i]["type"] === "All objs") {
                        var face = this.model.getGeom().getTopo(selecting[i]["path"]);
                        var wireses = face.getObj().getWires();
                        for (var w = 0; w < wireses.length; w++) {
                            var label = wireses[w].getLabel();
                            if (label === wires[j].label && this.attribute.indexOf(wires[j]) == -1) {
                                this.attribute.push(wires[j]);
                            }
                        }
                    }
                }
            }
        }
    };
    ToolwindowComponent.prototype.face = function (Visible) {
        this.Visible = "Faces";
        this.attribute = [];
        this.attribute = this.getfaces();
        if (this.selectedVisible == true) {
            this.facecheck();
        }
        if (this.dataService.checkface == undefined) {
            this.dataService.checkface = false;
        }
        else {
            this.checkface = this.dataService.checkface;
        }
        for (var n = 0; n < this.face_name.length; n++) {
            if (this.dataService.checkname[n] === undefined) {
                this.dataService.checkname[n] = false;
            }
            /*else{
              this.face_name[n]=this.dataService.checkname[n];
            }*/
        }
    };
    ToolwindowComponent.prototype.facecheck = function () {
        this.attribute = [];
        var faces = this.getfaces();
        var selecting = this.dataService.getselecting();
        if (selecting.length !== 0) {
            for (var i = 0; i < selecting.length; i++) {
                for (var j = 0; j < faces.length; j++) {
                    if (selecting[i]["id"] === faces[j].label) {
                        this.attribute.push(faces[j]);
                    }
                    if (selecting[i]["type"] === "All objs") {
                        var face = this.model.getGeom().getTopo(selecting[i]["path"]);
                        var faceses = face.getObj().getFaces();
                        for (var f = 0; f < faceses.length; f++) {
                            var label = faceses[f].getLabel();
                            if (label === faces[j].label && this.attribute.indexOf(faces[j]) == -1) {
                                this.attribute.push(faces[j]);
                            }
                        }
                    }
                }
            }
        }
    };
    ToolwindowComponent.prototype.object = function (Visible) {
        this.Visible = "Objs";
        this.attribute = [];
        this.attribute = this.getoject();
        if (this.selectedVisible == true) {
            this.objectcheck();
        }
        if (this.dataService.checkobj == undefined) {
            this.dataService.checkobj = false;
        }
        else {
            this.checkobj = this.dataService.checkobj;
        }
        this.dataService.visible = this.Visible;
    };
    ToolwindowComponent.prototype.objectcheck = function () {
        this.attribute = [];
        var object = this.getoject();
        var selecting = this.dataService.getselecting();
        if (selecting.length !== 0) {
            for (var i = 0; i < selecting.length; i++) {
                for (var j = 0; j < object.length; j++) {
                    if (selecting[i]["id"] === object[j].label) {
                        this.attribute.push(object[j]);
                    }
                }
            }
        }
    };
    ToolwindowComponent.prototype.changeselected = function () {
        this.selectedVisible = !this.selectedVisible;
        if (this.selectedVisible) {
            if (this.Visible === "Points")
                this.pointcheck();
            if (this.Visible === "Vertices")
                this.verticecheck();
            if (this.Visible === "Edges")
                this.edgecheck();
            if (this.Visible === "Wires")
                this.wirecheck();
            if (this.Visible === "Faces")
                this.facecheck();
            if (this.Visible === "Objs")
                this.objectcheck();
        }
        else {
            if (this.Visible === "Points")
                this.point(this.Visible);
            if (this.Visible === "Vertices")
                this.vertice(this.Visible);
            if (this.Visible === "Edges")
                this.edge(this.Visible);
            if (this.Visible === "Wires")
                this.wire(this.Visible);
            if (this.Visible === "Faces")
                this.face(this.Visible);
            if (this.Visible === "Objs")
                this.object(this.Visible);
        }
    };
    ToolwindowComponent.prototype.Onselect = function (datascale) {
        if (this.Visible === "Points") {
            var point = [];
            point.label = datascale.id;
            point.id = datascale.id;
            point.path = datascale.id;
            point.type = "All points";
            point.label_xyz = [datascale.x, datascale.y, datascale.z];
            var geometry = new three__WEBPACK_IMPORTED_MODULE_0__["Geometry"]();
            geometry.vertices.push(new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](point.label_xyz[0], point.label_xyz[1], point.label_xyz[2]));
            var pointsmaterial = new three__WEBPACK_IMPORTED_MODULE_0__["PointsMaterial"]({ color: 0x00ff00, size: 1 });
            if (this.dataService.pointsize !== undefined) {
                pointsmaterial.size = this.dataService.pointsize;
            }
            var points = new three__WEBPACK_IMPORTED_MODULE_0__["Points"](geometry, pointsmaterial);
            points.userData.id = point.id;
            //points["material"].needsUpdate=true;
            points.name = "selects";
            this.scene.add(points);
            this.renderer.render(this.scene, this.camera);
            this.dataService.addclickshow(point);
        }
        if (this.Visible === "Vertices") {
            var vertice = [];
            var path = datascale.path;
            var vertices = this.model.getGeom().getTopo(path);
            var label = vertices.getLabel();
            var verts_xyz = vertices.getLabelCentroid();
            vertice.label = label;
            vertice.id = datascale.pointid;
            vertice.path = datascale.path;
            vertice.type = "All points";
            vertice.label_xyz = [verts_xyz[0], verts_xyz[1], verts_xyz[2]];
            var geometry = new three__WEBPACK_IMPORTED_MODULE_0__["Geometry"]();
            geometry.vertices.push(new three__WEBPACK_IMPORTED_MODULE_0__["Vector3"](verts_xyz[0], verts_xyz[1], verts_xyz[2]));
            var pointsmaterial = new three__WEBPACK_IMPORTED_MODULE_0__["PointsMaterial"]({ color: 0x00ff00, size: 1 });
            if (this.dataService.pointsize !== undefined) {
                pointsmaterial.size = this.dataService.pointsize;
            }
            var points = new three__WEBPACK_IMPORTED_MODULE_0__["Points"](geometry, pointsmaterial);
            points.userData.id = vertice.id;
            //points["material"].needsUpdate=true;
            points.name = "selects";
            this.scene.add(points);
            this.renderer.render(this.scene, this.camera);
            this.dataService.addclickshow(vertice);
        }
        /*if(this.Visible==="Vertices"){
          var vertice:any=[];
          const path: gs.ITopoPathData=datascale.path;
          const vertices: gs.IVertex = this.model.getGeom().getTopo(path) as gs.IVertex;
          const label: string = vertices.getLabel();
          const verts_xyz: gs.XYZ = vertices.getLabelCentroid();
          vertice.label=label;
          vertice.id=datascale.pointid;
          vertice.path=datascale.path;
          vertice.type="All points";
          vertice.label_xyz=[verts_xyz[0],verts_xyz[1],verts_xyz[2]];
          var geometry=new THREE.Geometry();
          geometry.vertices.push(new THREE.Vector3(verts_xyz[0],verts_xyz[1],verts_xyz[2]));
          var pointsmaterial=new THREE.PointsMaterial( { color:0x00ff00,size:1} );
          if(this.dataService.pointsize!==undefined){
              pointsmaterial.size=this.dataService.pointsize;
          }
          const points = new THREE.Points( geometry, pointsmaterial);
          points.userData.id=vertice.id;
          //points["material"].needsUpdate=true;
          points.name="selects";
          this.scene.add(points);
          this.dataService.addclickshow(vertice);
        }*/
        if (this.Visible === "Edges") {
        }
    };
    ToolwindowComponent.prototype.pointcheckbox = function () {
        var index = [];
        for (var i = 0; i < this.getpoints().length; i++) {
            if (this.dataService.selecting.length !== 0) {
                for (var j = 0; j < this.dataService.selecting.length; j++) {
                    if (this.dataService.selecting[j].type === "All points") {
                        var label = "";
                        if (this.getpoints()[i].id === this.dataService.selecting[j]["id"]) {
                            if (document.getElementById("X")["checked"] === true) {
                                label = label.concat("X:", this.getpoints()[i].x, '\n');
                            }
                            if (document.getElementById("Y")["checked"] === true) {
                                label = label.concat("Y:", this.getpoints()[i].y, '\n');
                            }
                            if (document.getElementById("Z")["checked"] === true) {
                                label = label.concat("Z:", this.getpoints()[i].z, '\n');
                            }
                            for (var n = 0; n < this.point_name.length; n++) {
                                if (document.getElementById(this.point_name[n])["checked"] == true) {
                                    label = label.concat(this.point_name[n], ":", this.getpoints()[i][n]);
                                }
                            }
                            //console.log(label);
                            this.dataService.addlabel(label);
                        }
                    }
                }
            }
        }
    };
    ToolwindowComponent.prototype.checkbox = function () {
        if (this.Visible === "Points") {
            this.dataService.addgetpoints(this.getpoints());
            this.dataService.checkX = document.getElementById("X")["checked"];
            this.dataService.checkY = document.getElementById("Y")["checked"];
            this.dataService.checkZ = document.getElementById("Z")["checked"];
            this.dataService.checkpointid = document.getElementById("id")["checked"];
            for (var n = 0; n < this.point_name.length; n++) {
                this.dataService.checkname[n] = document.getElementById(this.point_name[n])["checked"];
            }
            this.dataService.addpointname(this.point_name);
        }
        if (this.Visible === "Vertices") {
            this.dataService.addgetpoints(this.getvertices());
            this.dataService.checkvertixid = document.getElementById("vertixid")["checked"];
            this.dataService.pointid = document.getElementById("pointid")["checked"];
            for (var n = 0; n < this.vertex_name.length; n++) {
                this.dataService.checkname[n] = document.getElementById(this.vertex_name[n])["checked"];
            }
            this.dataService.addpointname(this.vertex_name);
        }
        if (this.Visible === "Edges") {
            this.dataService.addgetpoints(this.getedges());
            this.dataService.checkedgeid = document.getElementById("edgeid")["checked"];
            for (var n = 0; n < this.edge_name.length; n++) {
                this.dataService.checkname[n] = document.getElementById(this.edge_name[n])["checked"];
            }
            this.dataService.addpointname(this.edge_name);
        }
        if (this.Visible === "Faces") {
            this.dataService.addgetpoints(this.getfaces());
            this.dataService.checkface = document.getElementById("checkface")["checked"];
            for (var n = 0; n < this.face_name.length; n++) {
                this.dataService.checkname[n] = document.getElementById(this.face_name[n])["checked"];
            }
            this.dataService.addpointname(this.face_name);
        }
        if (this.Visible === "Objs") {
            this.dataService.addgetpoints(this.getoject());
            this.dataService.checkobj = document.getElementById("checkobj")["checked"];
            for (var n = 0; n < this.obj_name.length; n++) {
                this.dataService.checkname[n] = document.getElementById(this.obj_name[n])["checked"];
            }
            this.dataService.addpointname(this.obj_name);
        }
    };
    ToolwindowComponent.prototype.sortData = function (sort) {
        var _this = this;
        var data = this.attribute.slice();
        if (!sort.active || sort.direction == '') {
            this.attribute = data;
            return;
        }
        if (this.Visible === "Points") {
            this.attribute = data.sort(function (a, b) {
                var isAsc = sort.direction == 'asc';
                switch (sort.active) {
                    case 'id': return _this.compareid(a.id, b.id, isAsc);
                    case 'x': return _this.compare(+a.x, +b.x, isAsc);
                    case 'y': return _this.compare(+a.y, +b.y, isAsc);
                    case 'z': return _this.compare(+a.z, +b.z, isAsc);
                    default: return 0;
                }
            });
            for (var i = 0; i < this.point_name.length; i++) {
                this.attribute = data.sort(function (a, b) {
                    var isAsc = sort.direction == 'asc';
                    switch (sort.active) {
                        case _this.point_name[i]: return _this.compare(a[i], b[i], isAsc);
                        default: return 0;
                    }
                });
            }
        }
        if (this.Visible === "Vertices") {
            var labelinitial = false;
            this.attribute = data.sort(function (a, b) {
                var isAsc = sort.direction == 'asc';
                switch (sort.active) {
                    case 'vertixlabel':
                        labelinitial = true;
                        return _this.compare(a.vertixlabel, b.vertixlabel, isAsc);
                    case 'pointid':
                        labelinitial = true;
                        return _this.compareid(a.pointid, b.pointid, isAsc);
                    default: return 0;
                }
            });
            if (labelinitial === false) {
                for (var i = 0; i < this.vertex_name.length; i++) {
                    this.attribute = data.sort(function (a, b) {
                        var isAsc = sort.direction == 'asc';
                        switch (sort.active) {
                            case _this.vertex_name[i]: return _this.compare(a[i], b[i], isAsc);
                            default: return 0;
                        }
                    });
                }
            }
        }
        if (this.Visible === "Edges") {
            this.attribute = data.sort(function (a, b) {
                var isAsc = sort.direction == 'asc';
                switch (sort.active) {
                    case 'label': return _this.compare(a.label, b.label, isAsc);
                    default: return 0;
                }
            });
            for (var i = 0; i < this.edge_name.length; i++) {
                this.attribute = data.sort(function (a, b) {
                    var isAsc = sort.direction == 'asc';
                    switch (sort.active) {
                        case _this.edge_name[i]: return _this.compare(a[i], b[i], isAsc);
                        default: return 0;
                    }
                });
            }
        }
        if (this.Visible === "Wires") {
            this.attribute = data.sort(function (a, b) {
                var isAsc = sort.direction == 'asc';
                switch (sort.active) {
                    case 'label': return _this.compare(a.label, b.label, isAsc);
                    default: return 0;
                }
            });
            for (var i = 0; i < this.wire_name.length; i++) {
                this.attribute = data.sort(function (a, b) {
                    var isAsc = sort.direction == 'asc';
                    switch (sort.active) {
                        case _this.wire_name[i]: return _this.compare(a[i], b[i], isAsc);
                        default: return 0;
                    }
                });
            }
        }
        if (this.Visible === "Faces") {
            this.attribute = data.sort(function (a, b) {
                var isAsc = sort.direction == 'asc';
                switch (sort.active) {
                    case 'label': return _this.compare(a.label, b.label, isAsc);
                    default: return 0;
                }
            });
            for (var i = 0; i < this.face_name.length; i++) {
                this.attribute = data.sort(function (a, b) {
                    var isAsc = sort.direction == 'asc';
                    switch (sort.active) {
                        case _this.face_name[i]: return _this.compare(a[i], b[i], isAsc);
                        default: return 0;
                    }
                });
            }
        }
        if (this.Visible === "Objs") {
            var labelinitial = false;
            this.attribute = data.sort(function (a, b) {
                var isAsc = sort.direction == 'asc';
                switch (sort.active) {
                    case 'label':
                        labelinitial = true;
                        return _this.compareid(a.label, b.label, isAsc);
                    default: return 0;
                }
            });
            if (labelinitial === false) {
                for (var i = 0; i < this.obj_name.length; i++) {
                    this.attribute = data.sort(function (a, b) {
                        var isAsc = sort.direction == 'asc';
                        switch (sort.active) {
                            case _this.obj_name[i]: return _this.compare(a[i], b[i], isAsc);
                            default: return 0;
                        }
                    });
                }
            }
        }
    };
    ToolwindowComponent.prototype.compare = function (a, b, isAsc) {
        return (a < b ? -1 : 1) * (isAsc ? 1 : -1);
    };
    ToolwindowComponent.prototype.compareid = function (a, b, isAsc) {
        return (Number(a.substring(1, a.length)) < Number(b.substring(1, b.length)) ? -1 : 1) * (isAsc ? 1 : -1);
    };
    ToolwindowComponent = __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
            selector: 'app-toolwindow',
            template: __webpack_require__(/*! ./toolwindow.component.html */ "./src/app/mViewer/viewers/gs-viewer/toolwindow/toolwindow.component.html"),
            styles: [__webpack_require__(/*! ./toolwindow.component.css */ "./src/app/mViewer/viewers/gs-viewer/toolwindow/toolwindow.component.css")]
        }),
        __metadata("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_1__["Injector"], _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]])
    ], ToolwindowComponent);
    return ToolwindowComponent;
}(_data_DataSubscriber__WEBPACK_IMPORTED_MODULE_3__["DataSubscriber"]));



/***/ }),

/***/ "./src/app/mViewer/viewers/gs-viewer/viewer/viewer.component.css":
/*!***********************************************************************!*\
  !*** ./src/app/mViewer/viewers/gs-viewer/viewer/viewer.component.css ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#container {\r\n  position: relative;\r\n  height:100%;\r\n  width: 100%;\r\n  margin:0px;\r\n  overflow: hidden;\r\n  color: white;\r\n  font-family:sans-serif;\r\n}\r\n#container-top-right-resize { top: 0px; right: 0px; }\r\n#shownumber{\r\n  position: absolute;\r\n  float: right;\r\n  color:black;\r\n  right: 0px;\r\n  width: 115px;\r\n  bottom: 0px;\r\n  color:#395d73;\r\n  font-family:sans-serif;\r\n}\r\n/*#rotating{\r\n  width: 30px;\r\n  height: 25px;\r\n  font-size:15px;\r\n  right:0px; \r\n  text-align:center;\r\n  position: absolute;\r\n  top: 0px;\r\n  background-color:transparent;\r\n  border:0;\r\n}\r\n\r\n#paning{\r\n  width: 30px;\r\n  height: 25px;\r\n  font-size:15px;\r\n  right:0px; \r\n  text-align:center;\r\n  position: absolute;\r\n  top: 25px;\r\n  background-color:transparent;\r\n  border:0;\r\n}\r\n\r\n#zooming{\r\n  width: 30px;\r\n  height: 25px;\r\n  font-size:15px;\r\n  right:0px; \r\n  text-align:center;\r\n  position: absolute;\r\n  margin-top: 50px;\r\n  background-color:transparent;\r\n  border:0;\r\n}*/\r\n/*#imagery{\r\n  width: 30px;\r\n  height: 25px;\r\n  font-size:14px;\r\n  right:0px; \r\n  text-align:center;\r\n  position: absolute;\r\n  margin-top: 10px;\r\n  background-color:transparent;\r\n  border:0;\r\n}*/\r\n#zoomingfit{\r\n  width: 30px;\r\n  height: 25px;\r\n  font-size:14px;\r\n  right:0px; \r\n  text-align:center;\r\n  position: absolute;\r\n  margin-top: 10px;\r\n  background-color:transparent;\r\n  border:0;\r\n}\r\n#selecting{\r\n  width: 30px;\r\n  height: 25px;\r\n  font-size:14px;\r\n  right:0px; \r\n  text-align:center;\r\n  position: absolute;\r\n  margin-top: 35px;\r\n  background-color:transparent;\r\n  border:0;\r\n}\r\n#points{\r\n  width: 30px;\r\n  height: 25px;\r\n  font:14px bolder;\r\n  right:0px; \r\n  text-align:center;\r\n  position: absolute;\r\n  margin-top: 70px;\r\n  background-color:transparent;\r\n  border:0;\r\n  font-family:sans-serif;\r\n}\r\n#vertices{\r\n  width: 30px;\r\n  height: 25px;\r\n  font:14px bolder;\r\n  right:0px; \r\n  text-align:center;\r\n  position: absolute;\r\n  margin-top: 95px;\r\n  background-color:transparent;\r\n  border:0;\r\n  font-family:sans-serif;\r\n}\r\n#edges{\r\n  width: 30px;\r\n  height: 25px;\r\n  font:14px bolder;\r\n  right:0px; \r\n  text-align:center;\r\n  position: absolute;\r\n  margin-top: 120px;\r\n  background-color:transparent;\r\n  border:0;\r\n  font-family:sans-serif;\r\n}\r\n#wires{\r\n  width: 30px;\r\n  height: 25px;\r\n  font:14px bolder;\r\n  right:0px; \r\n  text-align:center;\r\n  position: absolute;\r\n  margin-top: 145px;\r\n  background-color:transparent;\r\n  border:0;\r\n  font-family:sans-serif;\r\n}\r\n#faces{\r\n  width: 30px;\r\n  height: 25px;\r\n  font:14px bolder;\r\n  right:0px; \r\n  text-align:center;\r\n  position: absolute;\r\n  margin-top: 170px;\r\n  background-color:transparent;\r\n  border:0;\r\n  font-family:sans-serif;\r\n}\r\n#objects{\r\n  width: 30px;\r\n  height: 25px;\r\n  font:14px bolder;\r\n  right:0px; \r\n  text-align:center;\r\n  position: absolute;\r\n  margin-top: 195px;\r\n  background-color:transparent;\r\n  border:0;\r\n  font-family:sans-serif;\r\n}\r\n#setting{\r\n  width: 30px;\r\n  height: 25px;\r\n  font-size:14px;\r\n  right:0px; \r\n  text-align:center;\r\n  position: absolute;\r\n  top: 10px;\r\n  background-color:transparent;\r\n  border:0;\r\n}\r\n.selected{\r\n  color: grey;\r\n\r\n}\r\n.visible{\r\n  color: grey;\r\n}\r\n.cursor {\r\n\r\n}\r\n.selectvisible{\r\n  background-color:  white !important;\r\n  color:#395d73;\r\n}"

/***/ }),

/***/ "./src/app/mViewer/viewers/gs-viewer/viewer/viewer.component.html":
/*!************************************************************************!*\
  !*** ./src/app/mViewer/viewers/gs-viewer/viewer/viewer.component.html ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<div id=\"container\"  \r\n    (mousemove)=\"onDocumentMouseMove($event)\" \r\n    (mousedown)=\"mousedown($event)\"\r\n    (mouseup)=\"mouseup($event)\"\r\n    (click)=\"render(this)\"\r\n\t\t(click)=\"onDocumentMouseDown($event)\">\r\n    <div *ngIf=\"_updatemodel === false\" style=\"position:absolute;color:red;margin-top: 50px;left:40%;width: auto;text-align: center;font-family:sans-serif;font-size: 14px;background-color: white;\">Error displaying model:{{text}}</div>\r\n    <div *ngIf=\"_modelshow === false\" style=\"position:absolute;color:red;margin-top: 50px;left:40%;width: auto;text-align: center;font-family:sans-serif;font-size: 14px;background-color: white;\">Model or Scene not defined.</div>\r\n\r\n\r\n    <!-- (mousemove)=\"requestanimate()\" \r\n    (click)=\"requestanimate()\" -->\r\n\r\n    <!-- (window:resize)=\"onResize($event)\" -->\r\n\r\n\t\r\n  \t\t<!-- <button id=\"rotating\" \r\n  \t\t\t[class.visible]=\"Visible === 'rotate'\" \r\n  \t\t\t(click)=\"rotate()\">\r\n  \t\t\t<i class=\"fa fa-refresh\"></i>\r\n  \t\t</button>\r\n\r\n  \t\t<button id=\"paning\"  \r\n  \t\t\t[class.visible]=\"Visible === 'pan'\" \r\n  \t\t\t(click)=\"pan()\">\r\n  \t\t\t<i class=\"fa fa-hand-paper-o\"></i>\r\n  \t\t</button>\r\n\r\n  \t\t<button id=\"zooming\"  \r\n  \t\t\t[class.visible]=\"Visible === 'zoom'\" \r\n  \t\t\t(click)=\"Visible='zoom'\">\r\n  \t\t\t<i class=\"fa fa-search\"></i>\r\n  \t\t</button>-->\r\n  \t\t\r\n  \t\t<button id=\"zoomingfit\"  \r\n  \t\t\t[class.visible]=\"Visible === 'zoomfit'\" \r\n  \t\t\t(click)=\"zoomfit()\">\r\n  \t\t\t<span matTooltip=\"zoom to fit\"><i class=\"fa fa-arrows-alt\"></i></span>\r\n  \t\t</button> \r\n  \t\t\r\n  \t\t<!-- <button id=\"selecting\" [class.visible]=\"Visible === 'select'\" (click)= \"select($event, Visible)\" ><i class=\"fa fa-mouse-pointer\"></i></button> -->\r\n  \t\t\r\n  \t\t<!-- <button id=\"setting\" [class.selected]=\"settingVisible\" (click)= \"setting(settingVisible)\"><i class=\"fa fa-cog\"></i></button> -->\r\n\r\n      <button id=\"selecting\" [class.selected]=\"seVisible\" (click)= \"select(seVisible)\" ><span matTooltip=\"select\"><i class=\"fa fa-mouse-pointer\"></i></span></button>\r\n      <div id=\"shownumber\">\r\n        <tr>\r\n        <td  align=left style=\"width: 60px;\">Triangles&nbsp;&nbsp;</td>\r\n        <td  align=left style=\"width: 10px;\">{{renderer.info.render.faces}}</td>\r\n        </tr>\r\n        <tr>\r\n        <td  align=left style=\"width: 60px;\">Lines</td>\r\n        <td  align=left style=\"width: 10px;\">{{LineNo}}</td>\r\n        </tr>\r\n      </div>\r\n\r\n      <!-- <button id=\"imagery\"  \r\n        [class.selected]=\"imVisible\" (click)=\"leaflet()\">I\r\n      </button> -->\r\n      \t\r\n      \t<!--setting-->\r\n      \t\r\n \t\t<!-- <app-setting *ngIf=\"settingVisible == true\"></app-setting> -->\r\n    <div *ngIf=\"seVisible == true\">\r\n        <button id=\"points\" [class.selectvisible]=\"SelectVisible === 'Points'\" (click)=\"pointselect(SelectVisible)\"><span matTooltip=\"Select Points\">P</span></button>\r\n        <button id=\"vertices\" [class.selectvisible]=\"SelectVisible === 'Vertices'\" (click)=\"verticeselect(SelectVisible)\"><span matTooltip=\"Select Vertices\">V</span></button>\r\n        <button id=\"edges\" [class.selectvisible]=\"SelectVisible === 'Edges'\" (click)=\"edgeselect(SelectVisible)\"><span matTooltip=\"Select Edges\">E</span></button>\r\n        <button id=\"wires\" [class.selectvisible]=\"SelectVisible === 'Wires'\" (click)=\"wireselect(SelectVisible)\"><span matTooltip=\"Select Wires\">W</span></button>\r\n        <button id=\"faces\" [class.selectvisible]=\"SelectVisible === 'Faces'\" (click)=\"faceselect(SelectVisible)\"><span matTooltip=\"Select Faces\">F</span></button>\r\n        <button id=\"objects\" [class.selectvisible]=\"SelectVisible === 'Objs'\" (click)=\"objectselect(SelectVisible)\"><span matTooltip=\"Select Objects\">O</span></button>\r\n      </div>\r\n</div>\r\n\r\n\r\n\t\r\n\r\n\r\n"

/***/ }),

/***/ "./src/app/mViewer/viewers/gs-viewer/viewer/viewer.component.ts":
/*!**********************************************************************!*\
  !*** ./src/app/mViewer/viewers/gs-viewer/viewer/viewer.component.ts ***!
  \**********************************************************************/
/*! exports provided: ViewerComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ViewerComponent", function() { return ViewerComponent; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
/* harmony import */ var _data_DataSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../data/DataSubscriber */ "./src/app/mViewer/viewers/gs-viewer/data/DataSubscriber.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



var ViewerComponent = /** @class */ (function (_super) {
    __extends(ViewerComponent, _super);
    function ViewerComponent(injector, myElement) {
        var _this = _super.call(this, injector) || this;
        _this.textlabels = [];
        _this.starsGeometry = new three__WEBPACK_IMPORTED_MODULE_1__["Geometry"]();
        _this.seVisible = false;
        _this.imVisible = false;
        _this.SelectVisible = 'Objs';
        _this.settingVisible = false;
        _this.LineNo = 0;
        _this._updatemodel = true;
        _this._modelshow = true;
        _this.lastChanged = undefined;
        _this.myElement = myElement;
        return _this;
    }
    ViewerComponent.prototype.ngOnInit = function () {
        var container = this.myElement.nativeElement.children.namedItem("container");
        /// check for container
        if (!container) {
            console.error("No container in Three Viewer");
            return;
        }
        ///
        var width = container.offsetWidth; //container.clientWidth;
        var height = container.offsetHeight; //container.clientHeight;
        var scene = this.dataService.getScene(width, height);
        var renderer = this.dataService.getRenderer();
        var camera = this.dataService.getCamera();
        var controls = this.dataService.getControls();
        container.appendChild(renderer.domElement);
        this.scene = scene;
        this.renderer = renderer;
        this.camera = camera;
        this.controls = controls;
        this.width = width;
        this.height = height;
        this.updateModel();
        // todo: check and refactor what is required?
        this.selecting = this.dataService.getselecting(); // todo: should this be in the data service??
        this.mouse = new three__WEBPACK_IMPORTED_MODULE_1__["Vector2"]();
        this.raycaster = new three__WEBPACK_IMPORTED_MODULE_1__["Raycaster"]();
        this.raycaster.linePrecision = 0.05;
        this.scenechildren = this.dataService.getscenechild();
        this.dataService.SelectVisible = this.SelectVisible;
        var geometry = new three__WEBPACK_IMPORTED_MODULE_1__["SphereGeometry"](1);
        var material = new three__WEBPACK_IMPORTED_MODULE_1__["MeshBasicMaterial"]({ color: 0x00ff00, transparent: true, opacity: 0.5 });
        this.sphere = new three__WEBPACK_IMPORTED_MODULE_1__["Mesh"](geometry, material);
        this.sphere.visible = false;
        this.sphere.name = "sphereInter";
        this.sphere.scale.set(0.1, 0.1, 0.1);
        this.scene.add(this.sphere);
        var self = this;
        controls.addEventListener('change', function () { self.render(self); });
        for (var i = 0; i < this.getchildren().length; i++) {
            this.getchildren()[i]["material"].transparent = false;
        }
        this.dataService.addraycaster(this.raycaster);
        this.addgrid();
        self.renderer.render(self.scene, self.camera);
    };
    //
    //  checks if the data service has a data and calls update function for the viewer
    //
    ViewerComponent.prototype.notify = function (message) {
        if (message == "model_update" && this.scene) {
            this.updateModel();
        }
    };
    ViewerComponent.prototype.animate = function (self) {
        self.raycaster.setFromCamera(self.mouse, self.camera);
        self.scenechildren = self.dataService.getscenechild();
        var intersects = self.raycaster.intersectObjects(self.scenechildren);
        for (var i = 0; i < self.scenechildren.length; i++) {
            var currObj = self.scenechildren[i];
            if (self.dataService.getSelectingIndex(currObj.uuid) < 0) {
                if (intersects[0] != undefined && intersects[0].object.uuid == currObj.uuid) {
                    self.sphere.visible = true;
                    self.sphere.position.copy(intersects[0].point);
                }
                else {
                    self.sphere.visible = false;
                }
            }
        }
        for (var i = 0; i < self.textlabels.length; i++) {
            self.textlabels[i].updatePosition();
        }
        if (self.dataService.clickshow !== undefined && self.clickatt !== self.dataService.clickshow) {
            self.clickatt = self.dataService.clickshow;
            self.clickshow();
        }
        self.renderer.render(self.scene, self.camera);
    };
    ViewerComponent.prototype.render = function (self) {
        for (var i = 0; i < self.textlabels.length; i++) {
            self.textlabels[i].updatePosition();
        }
        if (self.dataService.clickshow !== undefined && self.clickatt !== self.dataService.clickshow) {
            self.clickatt = self.dataService.clickshow;
            self.clickshow();
        }
        //self.onDocumentMouseDown();
        self.renderer.render(self.scene, self.camera);
    };
    /// clears all children from the scene
    ViewerComponent.prototype.clearScene = function () {
        /// remove children from scene
        for (var i = 0; i < this.scene.children.length; i++) {
            if (this.scene.children[i].type === "Scene") {
                this.scene.remove(this.scene.children[i]);
                i = i - 1;
            }
            if (this.scene.children[i].name == "selects") {
                this.scene.remove(this.scene.children[i]);
                i = i - 1;
            }
        }
        for (var i = 0; i < this.scene.children.length; i++) {
            if (this.scene.children[i].name == "selects") {
                this.scene.remove(this.scene.children[i]);
                i = i - 1;
            }
        }
        for (var i = 0; i < this.textlabels.length; i++) {
            this.removeTextLabel(this.textlabels[i]["id"]);
            i = i - 1;
        }
    };
    ViewerComponent.prototype.ngDoCheck = function () {
        var container = this.myElement.nativeElement.children.namedItem("container");
        var width = container.offsetWidth;
        var height = container.offsetHeight;
        // this is when dimensions change
        if (width !== this.width || height !== this.height) {
            // compute time difference from last changed
            var nowTime = Date.now();
            var difference = this.lastChanged - nowTime;
            if (Math.abs(difference) < 400) {
                // do nothing
                // dimensions still changing
                //console.log("Threshold too low: " + Math.abs(difference) + "ms");
            }
            else {
                //console.log("Threshold matched: " + Math.abs(difference) + "ms");
                this.onResize();
            }
            // add dimension change script
            this.lastChanged = Date.now();
        }
    };
    // TODO Refactor
    ViewerComponent.prototype.onResize = function () {
        var container = this.myElement.nativeElement.children.namedItem("container");
        /// check for container
        if (!container) {
            console.error("No container in Three Viewer");
            return;
        }
        ///
        var width = container.offsetWidth;
        var height = container.offsetHeight;
        this.width = width;
        this.height = height;
        this.renderer.setSize(this.width, this.height);
        this.camera.aspect = this.width / this.height;
        this.camera.updateProjectionMatrix();
    };
    //
    // update mode
    // todo: optimize
    // 
    ViewerComponent.prototype.updateModel = function () {
        this._model = this.dataService.getGsModel();
        if (!this._model || !this.scene) {
            console.warn("Model or Scene not defined.");
            this._modelshow = false;
            return;
        }
        try {
            this._updatemodel = true;
            this._modelshow = true;
            this.scene_and_maps = this.dataService.getscememaps();
            var scene_data = this.scene_and_maps.scene;
            this.clearScene();
            var loader = new three__WEBPACK_IMPORTED_MODULE_1__["ObjectLoader"]();
            // loading data
            var objectData = loader.parse(scene_data);
            this.seVisible = false;
            this.imVisible = false;
            this.LineNo = 0;
            // preprocessing
            if (objectData.children !== undefined) {
                var radius = 0;
                for (var i = 0; i < objectData.children.length; i++) {
                    var chd = objectData.children[i];
                    //chd["material"].needsUpdate=true;
                    chd["material"].transparent = true;
                    chd["material"].blending = 1;
                    if (chd.name === "All faces" || chd.name === "All wires" || chd.name === "All edges" || chd.name === "All vertices" ||
                        chd.name === "Other lines" || chd.name === "All points") {
                        chd["material"].transparent = false;
                        chd["geometry"].computeVertexNormals();
                        chd["geometry"].computeBoundingBox();
                        chd["geometry"].computeBoundingSphere();
                        if (chd.name === "All points") {
                            this.center = chd["geometry"].boundingSphere.center;
                        }
                        if (chd.name === "All edges") {
                            this.basicMat = chd["material"].color;
                        }
                        else if (chd.name === "Other lines") {
                            this.basicMat = chd["material"].color;
                        }
                        if (chd.type === "LineSegments" && chd["geometry"].index.count !== undefined) {
                            this.LineNo = this.LineNo + chd["geometry"].index.count;
                        }
                    }
                    if (chd["geometry"] != undefined && chd["geometry"].boundingSphere.radius !== null) {
                        if (chd["geometry"].boundingSphere.radius > radius) {
                            radius = chd["geometry"].boundingSphere.radius;
                            this.center = chd["geometry"].boundingSphere.center;
                        }
                    }
                }
            }
            // setting controls
            this.controls.target.set(this.center.x, this.center.y, this.center.z);
            this.controls.update();
            // adding the object to the scene
            this.scene.add(objectData);
            this.render(this);
            this.dataService.getpoints = [];
        }
        catch (ex) {
            console.error("Error displaying model:", ex);
            this._updatemodel = false;
            this.text = ex;
        }
    };
    ViewerComponent.prototype.getMaterial = function (name) {
        var canvas = document.createElement('canvas');
        canvas.width = 256;
        canvas.height = 256;
        var context = canvas.getContext('2d');
        context.textAlign = "center";
        context.fillText(name, canvas.width / 2, canvas.height / 2);
        context.font = "Bold  100px sans-serif";
        var texture = new three__WEBPACK_IMPORTED_MODULE_1__["Texture"](canvas);
        //texture.needsUpdate = true;
        var spriteMaterial = new three__WEBPACK_IMPORTED_MODULE_1__["SpriteMaterial"]({ map: texture, color: 0xffffff });
        return spriteMaterial;
    };
    ViewerComponent.prototype.getchildren = function () {
        var children;
        for (var i = 0; i < this.scene.children.length; i++) {
            if (this.scene.children[i].name == "Scene") {
                children = this.scene.children[i].children;
                break;
            }
            if (i == this.scene.children.length - 1) {
                return [];
            }
        }
        return children;
    };
    ViewerComponent.prototype.clickshow = function () {
        var label = this.clickatt["label"];
        var id = this.clickatt["id"];
        var label_xyz = this.clickatt["label_xyz"];
        var path = this.clickatt["path"];
        this.addTextLabel(label, label_xyz, id, path, "All points");
    };
    ViewerComponent.prototype.select = function (seVisible) {
        event.stopPropagation();
        this.seVisible = !this.seVisible;
        if (this.seVisible) {
            if (this.SelectVisible === "Objs")
                this.objectselect(this.SelectVisible);
            if (this.SelectVisible === "Faces")
                this.faceselect(this.SelectVisible);
            if (this.SelectVisible === "Edges")
                this.edgeselect(this.SelectVisible);
            if (this.SelectVisible === "Vertices")
                this.verticeselect(this.SelectVisible);
            if (this.SelectVisible === "Points")
                this.pointselect(this.SelectVisible);
            for (var i = 0; i < this.getchildren().length; i++) {
                this.getchildren()[i]["material"].transparent = true;
            }
        }
        else {
            for (var i = 0; i < this.getchildren().length; i++) {
                this.getchildren()[i]["material"].transparent = false;
                if (this.getchildren()[i].name == "All edges") {
                    this.getchildren()[i]["material"].color = this.basicMat;
                }
                else if (this.getchildren()[i].name == "Other lines") {
                    this.getchildren()[i]["material"].color = this.basicMat;
                }
            }
        }
    };
    ViewerComponent.prototype.objectselect = function (SelectVisible) {
        event.stopPropagation();
        this.SelectVisible = "Objs";
        this.dataService.visible = "Objs";
        document.getElementById("gsv-object").style.color = null;
        document.getElementById("gsv-face").style.color = null;
        document.getElementById("gsv-wire").style.color = null;
        document.getElementById("gsv-edge").style.color = null;
        document.getElementById("gsv-vertice").style.color = null;
        var scenechildren = [];
        var children = this.getchildren();
        var objsvisibel = true;
        for (var i = 0; i < children.length; i++) {
            if (children[i].name === "All objs" || children[i].name === "All faces") {
                if (children[i]["geometry"].attributes.position.array.length !== 0) {
                    children[i]["material"].opacity = 0.3;
                    children[i].name = "All objs";
                    scenechildren.push(children[i]);
                }
                else {
                    objsvisibel = false;
                }
            }
            if (children[i].name === "All wires") {
                if (objsvisibel === true) {
                    children[i]["material"].opacity = 0;
                }
                else {
                    children[i]["material"].opacity = 0.6;
                    scenechildren.push(children[i]);
                }
            }
            if (children[i].name === "All edges" || children[i].name === "Other lines") {
                children[i]["material"].opacity = 0.1;
                children[i]["material"].color = this.basicMat;
            }
            if (children[i].name === "All vertices")
                children[i]["material"].opacity = 0;
        }
        this.dataService.addscenechild(scenechildren);
        this.dataService.SelectVisible = this.SelectVisible;
    };
    ViewerComponent.prototype.faceselect = function (SelectVisible) {
        event.stopPropagation();
        this.SelectVisible = "Faces";
        this.dataService.visible = "Faces";
        document.getElementById("gsv-object").style.color = "grey";
        document.getElementById("gsv-face").style.color = null;
        document.getElementById("gsv-wire").style.color = null;
        document.getElementById("gsv-edge").style.color = null;
        document.getElementById("gsv-vertice").style.color = null;
        var scenechildren = [];
        var children = this.getchildren();
        for (var i = 0; i < children.length; i++) {
            if (children[i].name === "All wires")
                children[i]["material"].opacity = 0.1;
            if (children[i].name === "All edges" || children[i].name === "Other lines") {
                children[i]["material"].opacity = 0.1;
                children[i]["material"].color = this.basicMat;
            }
            if (children[i].name === "All vertices")
                children[i]["material"].opacity = 0.1;
            if (children[i].name === "All objs" || children[i].name === "All faces") {
                children[i]["material"].opacity = 0.3;
                children[i].name = "All faces";
                scenechildren.push(children[i]);
            }
        }
        this.dataService.addscenechild(scenechildren);
        this.dataService.SelectVisible = this.SelectVisible;
    };
    ViewerComponent.prototype.wireselect = function (SelectVisible) {
        event.stopPropagation();
        this.SelectVisible = "Wires";
        var lineprecision = this.raycaster.linePrecision;
        for (var i = 0; i < this.scene.children.length; i++) {
            if (this.scene.children[i].name === "sphereInter") {
                var geometry = new three__WEBPACK_IMPORTED_MODULE_1__["SphereGeometry"](lineprecision * 2);
                this.scene.children[i]["geometry"] = geometry;
                this.renderer.render(this.scene, this.camera);
            }
        }
        document.getElementById("gsv-object").style.color = "grey";
        document.getElementById("gsv-face").style.color = "grey";
        document.getElementById("gsv-wire").style.color = null;
        document.getElementById("gsv-edge").style.color = null;
        document.getElementById("gsv-vertice").style.color = null;
        var scenechildren = [];
        var children = this.getchildren();
        for (var i = 0; i < children.length; i++) {
            if (children[i].name === "All objs" || children[i].name === "All faces")
                children[i]["material"].opacity = 0.1;
            if (children[i].name === "All edges" || children[i].name === "Other lines") {
                children[i]["material"].opacity = 0.1;
                children[i]["material"].color = this.basicMat;
            }
            if (children[i].name === "All vertices")
                children[i]["material"].opacity = 0.1;
            if (children[i].name === "All wires") {
                children[i]["material"].opacity = 0.6;
                scenechildren.push(children[i]);
            }
        }
        this.dataService.addscenechild(scenechildren);
        this.dataService.SelectVisible = this.SelectVisible;
    };
    ViewerComponent.prototype.edgeselect = function (SelectVisible) {
        event.stopPropagation();
        this.SelectVisible = "Edges";
        var lineprecision = this.raycaster.linePrecision;
        for (var i = 0; i < this.scene.children.length; i++) {
            if (this.scene.children[i].name === "sphereInter") {
                var geometry = new three__WEBPACK_IMPORTED_MODULE_1__["SphereGeometry"](lineprecision * 15);
                this.scene.children[i]["geometry"] = geometry;
                this.renderer.render(this.scene, this.camera);
            }
        }
        document.getElementById("gsv-object").style.color = "grey";
        document.getElementById("gsv-face").style.color = "grey";
        document.getElementById("gsv-wire").style.color = "grey";
        document.getElementById("gsv-edge").style.color = null;
        document.getElementById("gsv-vertice").style.color = null;
        var scenechildren = [];
        var children = this.getchildren();
        var edgevisible = true;
        for (var i = 0; i < children.length; i++) {
            children[i]["material"].transparent = true;
            if (children[i].name === "All edges" || children[i].name === "Other lines") {
                if (children[i].name === "All edges") {
                    if (children[i]["geometry"].attributes.position.array.length !== 0) {
                        children[i]["material"].opacity = 0.3;
                        children[i]["material"].color = new three__WEBPACK_IMPORTED_MODULE_1__["Color"](255, 255, 0);
                        scenechildren.push(children[i]);
                    }
                    else {
                        edgevisible = false;
                    }
                }
                else {
                    if (children[i]["geometry"].attributes.position.array.length !== 0) {
                        children[i]["material"].opacity = 0.3;
                        children[i]["material"].color = new three__WEBPACK_IMPORTED_MODULE_1__["Color"](255, 255, 0);
                        scenechildren.push(children[i]);
                    }
                }
            }
            if (children[i].name === "All objs" || children[i].name === "All faces")
                children[i]["material"].opacity = 0.1;
            if (children[i].name === "All wires")
                children[i]["material"].opacity = 0.1;
            if (children[i].name === "All vertices")
                children[i]["material"].opacity = 0.1;
        }
        this.dataService.addscenechild(scenechildren);
        this.dataService.SelectVisible = this.SelectVisible;
    };
    ViewerComponent.prototype.verticeselect = function (SelectVisible) {
        event.stopPropagation();
        this.SelectVisible = "Vertices";
        var pointradius = this.dataService.pointradius;
        ;
        for (var i = 0; i < this.scene.children.length; i++) {
            if (this.scene.children[i].name === "sphereInter") {
                var geometry = new three__WEBPACK_IMPORTED_MODULE_1__["SphereGeometry"](pointradius * 10);
                this.scene.children[i]["geometry"] = geometry;
                this.renderer.render(this.scene, this.camera);
            }
        }
        document.getElementById("gsv-object").style.color = "grey";
        document.getElementById("gsv-face").style.color = "grey";
        document.getElementById("gsv-wire").style.color = "grey";
        document.getElementById("gsv-edge").style.color = "grey";
        document.getElementById("gsv-vertice").style.color = null;
        var scenechildren = [];
        var children = this.getchildren();
        for (var i = 0; i < children.length; i++) {
            if (children[i].name === "All objs" || children[i].name === "All faces")
                children[i]["material"].opacity = 0.1;
            if (children[i].name === "All wires")
                children[i]["material"].opacity = 0.1;
            if (children[i].name === "All edges" || children[i].name === "Other lines") {
                children[i]["material"].opacity = 0.1;
                children[i]["material"].color = this.basicMat;
            }
            /*if(children[i].name==="All vertices"){
              scenechildren.push(children[i]);
            }*/
            if (children[i].name === "All points") {
                scenechildren.push(children[i]);
                children[i]["material"].opacity = 1;
            }
        }
        this.dataService.addscenechild(scenechildren);
        this.dataService.SelectVisible = this.SelectVisible;
    };
    ViewerComponent.prototype.pointselect = function (SelectVisible) {
        /*event.stopPropagation();
        this.verticeselect("Vertices");
        this.SelectVisible="Points";
        this.dataService.SelectVisible=this.SelectVisible;*/
        event.stopPropagation();
        this.SelectVisible = "Points";
        var pointradius = this.dataService.pointradius;
        ;
        for (var i = 0; i < this.scene.children.length; i++) {
            if (this.scene.children[i].name === "sphereInter") {
                var geometry = new three__WEBPACK_IMPORTED_MODULE_1__["SphereGeometry"](pointradius * 10);
                this.scene.children[i]["geometry"] = geometry;
                this.renderer.render(this.scene, this.camera);
            }
        }
        document.getElementById("gsv-object").style.color = "grey";
        document.getElementById("gsv-face").style.color = "grey";
        document.getElementById("gsv-wire").style.color = "grey";
        document.getElementById("gsv-edge").style.color = "grey";
        document.getElementById("gsv-vertice").style.color = null;
        var scenechildren = [];
        var children = this.getchildren();
        for (var i = 0; i < children.length; i++) {
            if (children[i].name === "All objs" || children[i].name === "All faces")
                children[i]["material"].opacity = 0.1;
            if (children[i].name === "All wires")
                children[i]["material"].opacity = 0.1;
            if (children[i].name === "All edges" || children[i].name === "Other lines") {
                children[i]["material"].opacity = 0.1;
                children[i]["material"].color = this.basicMat;
            }
            if (children[i].name === "All vertices") {
                children[i]["material"].opacity = 1;
            }
            if (children[i].name === "All points") {
                scenechildren.push(children[i]);
            }
        }
        this.dataService.addscenechild(scenechildren);
        this.dataService.SelectVisible = this.SelectVisible;
    };
    //
    //  events
    //
    ViewerComponent.prototype.mousedown = function ($event) {
        this.animate(this);
        this.mDownTime = (new Date()).getTime();
    };
    ViewerComponent.prototype.mouseup = function ($event) {
        this.mUpTime = (new Date()).getTime();
    };
    ViewerComponent.prototype.onDocumentMouseMove = function (event) {
        //this.onResize();
        if (this.seVisible === true) {
            this.animate(this);
            this.mouse.x = (event.offsetX / this.width) * 2 - 1;
            this.mouse.y = -(event.offsetY / this.height) * 2 + 1;
        }
        else {
            this.render(this);
        }
    };
    ViewerComponent.prototype.addgrid = function () {
        for (var i = 0; i < this.scene.children.length; i++) {
            if (this.scene.children[i].name === "GridHelper") {
                this.scene.remove(this.scene.children[i]);
                i = i - 1;
            }
        }
        // todo: change grid -> grid_value
        if (this.dataService.grid) {
            var gridhelper = new three__WEBPACK_IMPORTED_MODULE_1__["GridHelper"](100, 10);
            gridhelper.name = "GridHelper";
            var vector = new three__WEBPACK_IMPORTED_MODULE_1__["Vector3"](0, 1, 0);
            gridhelper.lookAt(vector);
            gridhelper.position.set(0, 0, 0);
            this.scene.add(gridhelper);
            this.dataService.centerx = 0;
            this.dataService.centery = 0;
            this.dataService.centerz = 0;
        }
    };
    /// selects object from three.js scene
    ViewerComponent.prototype.onDocumentMouseDown = function (event) {
        var threshold;
        if (this.seVisible === true) {
            threshold = 100;
        }
        else {
            threshold = 0.1;
        }
        if (Math.abs(this.mDownTime - this.mUpTime) > threshold) {
            this.mDownTime = 0;
            this.mUpTime = 0;
            return;
        }
        var selectedObj, intersects;
        var select = false;
        this.scenechildren = this.dataService.getscenechild();
        this.raycaster.setFromCamera(this.mouse, this.camera);
        intersects = this.raycaster.intersectObjects(this.scenechildren);
        if (intersects.length > 0) {
            selectedObj = intersects[0].object;
            if (this.scenechildren[0].name === "All objs") {
                var index_1 = Math.floor(intersects[0].faceIndex);
                var path_1 = this.scene_and_maps.faces_map.get(index_1);
                var face = this._model.getGeom().getTopo(path_1);
                var label = "";
                var id_1 = "o" + path_1.id;
                var getpoints;
                var getpoints = this.dataService.getpoints;
                var pointname = this.dataService.pointname;
                if (getpoints !== undefined && getpoints.length !== 0) {
                    for (var i = 0; i < getpoints.length; i++) {
                        if (id_1 === getpoints[i].label) {
                            if (this.dataService.checkobj === true)
                                label = id_1;
                            for (var n = 0; n < pointname.length; n++) {
                                if (this.dataService.checkname[n] === true) {
                                    label = label.concat('<br/>', pointname[n], ":", getpoints[i][n]);
                                }
                            }
                        }
                    }
                }
                var label_xyz = face.getLabelCentroid();
                var faces = face.getObj().getFaces();
                if (this.textlabels.length === 0) {
                    for (var n = 0; n < faces.length; n++) {
                        var verts = faces[n].getVertices();
                        var verts_xyz = verts.map(function (v) { return v.getPoint().getPosition(); });
                        var geometry = new three__WEBPACK_IMPORTED_MODULE_1__["Geometry"]();
                        for (var i = 0; i < verts_xyz.length; i++) {
                            geometry.vertices.push(new three__WEBPACK_IMPORTED_MODULE_1__["Vector3"](verts_xyz[i][0], verts_xyz[i][1], verts_xyz[i][2]));
                        }
                        /*if(verts.length===4){
                          geometry.faces.push(new THREE.Face3(0,2,1));
                          geometry.faces.push(new THREE.Face3(0,3,2));
                        }else if(verts.length===3){
                          geometry.faces.push(new THREE.Face3(0,2,1));
                        }
                        var mesh=new THREE.Mesh( geometry, new THREE.MeshPhongMaterial( { color:0x00ff00,side:THREE.DoubleSide} ));
                        mesh["geometry"].computeVertexNormals();
                        mesh.userData.id=label;
                        mesh.name="selects";
                        this.scene.add(mesh);*/
                        var material = new three__WEBPACK_IMPORTED_MODULE_1__["LineBasicMaterial"]({ color: 0x00ff00, side: three__WEBPACK_IMPORTED_MODULE_1__["DoubleSide"] });
                        var line = new three__WEBPACK_IMPORTED_MODULE_1__["Line"](geometry, material);
                        line.userData.id = id_1;
                        //line["material"].needsUpdate=true;
                        line.name = "selects";
                        this.scene.add(line);
                    }
                    this.addTextLabel(label, label_xyz, label, path_1, "All objs");
                }
                else {
                    for (var j = 0; j < this.scene.children.length; j++) {
                        if (id_1 === this.scene.children[j].userData.id) {
                            select = true;
                            this.scene.remove(this.scene.children[j]);
                            j = j - 1;
                        }
                    }
                    for (var j = 0; j < this.textlabels.length; j++) {
                        if (id_1 === this.textlabels[j]["id"]) {
                            select = true;
                            this.removeTextLabel(this.textlabels[j]["id"]);
                            j = j - 1;
                        }
                    }
                    if (select == false) {
                        for (var n = 0; n < faces.length; n++) {
                            var verts = faces[n].getVertices();
                            var verts_xyz = verts.map(function (v) { return v.getPoint().getPosition(); });
                            var geometry = new three__WEBPACK_IMPORTED_MODULE_1__["Geometry"]();
                            for (var i = 0; i < verts_xyz.length; i++) {
                                geometry.vertices.push(new three__WEBPACK_IMPORTED_MODULE_1__["Vector3"](verts_xyz[i][0], verts_xyz[i][1], verts_xyz[i][2]));
                            }
                            var material = new three__WEBPACK_IMPORTED_MODULE_1__["LineBasicMaterial"]({ color: 0x00ff00, side: three__WEBPACK_IMPORTED_MODULE_1__["DoubleSide"] });
                            var line = new three__WEBPACK_IMPORTED_MODULE_1__["Line"](geometry, material);
                            line.userData.id = id_1;
                            //line["material"].needsUpdate=true;
                            line.name = "selects";
                            this.scene.add(line);
                        }
                        this.addTextLabel(label, label_xyz, id_1, path_1, "All objs");
                    }
                }
            }
            if (this.scenechildren[0].name === "All faces") {
                var index_2 = Math.floor(intersects[0].faceIndex);
                var path_2 = this.scene_and_maps.faces_map.get(index_2);
                var face = this._model.getGeom().getTopo(path_2);
                var label = "";
                var getpoints;
                var getpoints = this.dataService.getpoints;
                var pointname = this.dataService.pointname;
                if (getpoints !== undefined && getpoints.length !== 0) {
                    for (var i = 0; i < getpoints.length; i++) {
                        if (face.getLabel() === getpoints[i].label) {
                            for (var n = 0; n < pointname.length; n++) {
                                if (this.dataService.checkface === true)
                                    label = face.getLabel();
                                if (this.dataService.checkname[n] === true) {
                                    label = label.concat('<br/>', pointname[n], ":", getpoints[i][n]);
                                }
                            }
                        }
                    }
                }
                var label_xyz = face.getLabelCentroid();
                var verts_1 = face.getVertices();
                var verts_xyz_1 = verts_1.map(function (v) { return v.getPoint().getPosition(); });
                if (this.textlabels.length === 0) {
                    var geometry = new three__WEBPACK_IMPORTED_MODULE_1__["Geometry"]();
                    for (var i = 0; i < verts_xyz_1.length; i++) {
                        geometry.vertices.push(new three__WEBPACK_IMPORTED_MODULE_1__["Vector3"](verts_xyz_1[i][0], verts_xyz_1[i][1], verts_xyz_1[i][2]));
                    }
                    var material = new three__WEBPACK_IMPORTED_MODULE_1__["LineBasicMaterial"]({ color: 0x00ff00, side: three__WEBPACK_IMPORTED_MODULE_1__["DoubleSide"] });
                    var line = new three__WEBPACK_IMPORTED_MODULE_1__["Line"](geometry, material);
                    line.userData.id = face.getLabel();
                    //line["material"].needsUpdate=true;
                    line.name = "selects";
                    this.scene.add(line);
                    this.addTextLabel(label, label_xyz, face.getLabel(), path_2, "All faces");
                }
                else {
                    for (var j = 0; j < this.scene.children.length; j++) {
                        if (face.getLabel() === this.scene.children[j].userData.id) {
                            select = true;
                            this.scene.remove(this.scene.children[j]);
                        }
                    }
                    for (var j = 0; j < this.textlabels.length; j++) {
                        if (face.getLabel() === this.textlabels[j]["id"]) {
                            select = true;
                            this.removeTextLabel(this.textlabels[j]["id"]);
                        }
                    }
                    if (select == false) {
                        var geometry = new three__WEBPACK_IMPORTED_MODULE_1__["Geometry"]();
                        for (var i = 0; i < verts_xyz_1.length; i++) {
                            geometry.vertices.push(new three__WEBPACK_IMPORTED_MODULE_1__["Vector3"](verts_xyz_1[i][0], verts_xyz_1[i][1], verts_xyz_1[i][2]));
                        }
                        var material = new three__WEBPACK_IMPORTED_MODULE_1__["LineBasicMaterial"]({ color: 0x00ff00, side: three__WEBPACK_IMPORTED_MODULE_1__["DoubleSide"] });
                        var line = new three__WEBPACK_IMPORTED_MODULE_1__["Line"](geometry, material);
                        line.userData.id = face.getLabel();
                        //line["material"].needsUpdate=true;
                        line.name = "selects";
                        this.scene.add(line);
                        this.addTextLabel(label, label_xyz, face.getLabel(), path_2, "All faces");
                    }
                }
            }
            if (this.scenechildren[0].name == "All wires") {
                var index_3 = Math.floor(intersects[0].index / 2);
                var path_3 = this.scene_and_maps.wires_map.get(index_3);
                var wire = this._model.getGeom().getTopo(path_3);
                var label_1 = wire.getLabel();
                var label_xyz = wire.getLabelCentroid();
                var verts_2 = wire.getVertices();
                var verts_xyz_2 = verts_2.map(function (v) { return v.getPoint().getPosition(); });
                if (wire.isClosed()) {
                    verts_xyz_2.push(verts_xyz_2[0]);
                }
                if (this.textlabels.length === 0) {
                    var geometry = new three__WEBPACK_IMPORTED_MODULE_1__["Geometry"]();
                    for (var i = 0; i < verts_xyz_2.length; i++) {
                        geometry.vertices.push(new three__WEBPACK_IMPORTED_MODULE_1__["Vector3"](verts_xyz_2[i][0], verts_xyz_2[i][1], verts_xyz_2[i][2]));
                    }
                    var material = new three__WEBPACK_IMPORTED_MODULE_1__["LineBasicMaterial"]({ color: 0x00ff00, side: three__WEBPACK_IMPORTED_MODULE_1__["DoubleSide"] });
                    var line = new three__WEBPACK_IMPORTED_MODULE_1__["Line"](geometry, material);
                    line.userData.id = label_1;
                    //line["material"].needsUpdate=true;
                    line.name = "selects";
                    this.scene.add(line);
                    this.addTextLabel(label_1, label_xyz, label_1, path_3, "All wires");
                }
                else {
                    for (var j = 0; j < this.scene.children.length; j++) {
                        if (label_1 === this.scene.children[j].userData.id) {
                            select = true;
                            this.scene.remove(this.scene.children[j]);
                        }
                    }
                    for (var j = 0; j < this.textlabels.length; j++) {
                        if (label_1 === this.textlabels[j]["id"]) {
                            select = true;
                            this.removeTextLabel(this.textlabels[j]["id"]);
                        }
                    }
                    if (select == false) {
                        var geometry = new three__WEBPACK_IMPORTED_MODULE_1__["Geometry"]();
                        for (var i = 0; i < verts_xyz_2.length; i++) {
                            geometry.vertices.push(new three__WEBPACK_IMPORTED_MODULE_1__["Vector3"](verts_xyz_2[i][0], verts_xyz_2[i][1], verts_xyz_2[i][2]));
                        }
                        var material = new three__WEBPACK_IMPORTED_MODULE_1__["LineBasicMaterial"]({ color: 0x00ff00, side: three__WEBPACK_IMPORTED_MODULE_1__["DoubleSide"] });
                        var line = new three__WEBPACK_IMPORTED_MODULE_1__["Line"](geometry, material);
                        line.userData.id = label_1;
                        //line["material"].needsUpdate=true;
                        line.name = "selects";
                        this.scene.add(line);
                        this.addTextLabel(label_1, label_xyz, label_1, path_3, "All wires");
                    }
                }
            }
            if (this.scenechildren[0].name == "All edges") {
                var label = "";
                var index = Math.floor(intersects[0].index / 2);
                if (this.scene_and_maps.edges_map !== null && (index < this.scene_and_maps.edges_map.size || index === this.scene_and_maps.edges_map.size)) {
                    var path = this.scene_and_maps.edges_map.get(index);
                    var edge = this._model.getGeom().getTopo(path);
                    var id = edge.getLabel();
                    var label_show = id;
                    for (var i = 1; i < intersects.length; i++) {
                        if (intersects[0].distance === intersects[i].distance) {
                            index = Math.floor(intersects[i].index / 2);
                            path = this.scene_and_maps.edges_map.get(index);
                            edge = this._model.getGeom().getTopo(path);
                            id = edge.getLabel();
                            if (label_show !== id)
                                label_show = label_show + "<br/>" + id;
                        }
                    }
                    var getpoints;
                    var getpoints = this.dataService.getpoints;
                    var pointname = this.dataService.pointname;
                    if (getpoints !== undefined && getpoints.length !== 0) {
                        for (var i = 0; i < getpoints.length; i++) {
                            if (edge.getLabel() === getpoints[i].label) {
                                if (this.dataService.checkedgeid === true) {
                                    label = label_show;
                                }
                                for (var n = 0; n < pointname.length; n++) {
                                    if (this.dataService.checkname[n] === true) {
                                        label = label.concat('<br/>', pointname[n], ":", getpoints[i][n]);
                                    }
                                }
                            }
                        }
                    }
                    var label_xyz = edge.getLabelCentroid();
                    var verts_3 = edge.getVertices();
                    var verts_xyz_3 = verts_3.map(function (v) { return v.getPoint().getPosition(); });
                    if (this.textlabels.length === 0) {
                        var geometry = new three__WEBPACK_IMPORTED_MODULE_1__["Geometry"]();
                        for (var i = 0; i < verts_xyz_3.length; i++) {
                            geometry.vertices.push(new three__WEBPACK_IMPORTED_MODULE_1__["Vector3"](verts_xyz_3[i][0], verts_xyz_3[i][1], verts_xyz_3[i][2]));
                        }
                        var material = new three__WEBPACK_IMPORTED_MODULE_1__["LineBasicMaterial"]({ color: 0x00ff00, side: three__WEBPACK_IMPORTED_MODULE_1__["DoubleSide"] });
                        var line = new three__WEBPACK_IMPORTED_MODULE_1__["Line"](geometry, material);
                        line.userData.id = edge.getLabel();
                        //line["material"].needsUpdate=true;
                        line.name = "selects";
                        this.scene.add(line);
                        this.addTextLabel(label, label_xyz, edge.getLabel(), path, "All edges");
                    }
                    else {
                        for (var j = 0; j < this.scene.children.length; j++) {
                            if (edge.getLabel() === this.scene.children[j].userData.id) {
                                select = true;
                                this.scene.remove(this.scene.children[j]);
                            }
                        }
                        for (var j = 0; j < this.textlabels.length; j++) {
                            if (edge.getLabel() === this.textlabels[j]["id"]) {
                                select = true;
                                this.removeTextLabel(this.textlabels[j]["id"]);
                            }
                        }
                        if (select == false) {
                            var geometry = new three__WEBPACK_IMPORTED_MODULE_1__["Geometry"]();
                            for (var i = 0; i < verts_xyz_3.length; i++) {
                                geometry.vertices.push(new three__WEBPACK_IMPORTED_MODULE_1__["Vector3"](verts_xyz_3[i][0], verts_xyz_3[i][1], verts_xyz_3[i][2]));
                            }
                            var material = new three__WEBPACK_IMPORTED_MODULE_1__["LineBasicMaterial"]({ color: 0x00ff00, side: three__WEBPACK_IMPORTED_MODULE_1__["DoubleSide"] });
                            var line = new three__WEBPACK_IMPORTED_MODULE_1__["Line"](geometry, material);
                            line.userData.id = edge.getLabel();
                            line.name = "selects";
                            this.scene.add(line);
                            this.addTextLabel(label, label_xyz, edge.getLabel(), path, "All edges");
                        }
                    }
                }
            }
            else if (this.scenechildren[0].name == "Other lines") {
                var label = "";
                var index = Math.floor(intersects[0].index / 2);
                if (this.scene_and_maps.edges_map !== null && (index < this.scene_and_maps.edges_map.size || index === this.scene_and_maps.edges_map.size)) {
                    var path = this.scene_and_maps.edges_map.get(index);
                    var edge = this._model.getGeom().getTopo(path);
                    var id = edge.getLabel();
                    label = id;
                    for (var i = 1; i < intersects.length; i++) {
                        if (intersects[0].distance === intersects[i].distance) {
                            index = Math.floor(intersects[i].index / 2);
                            path = this.scene_and_maps.edges_map.get(index);
                            edge = this._model.getGeom().getTopo(path);
                            id = edge.getLabel();
                            if (label !== id)
                                label = label + "<br/>" + id;
                        }
                    }
                    var label_xyz = edge.getLabelCentroid();
                    var verts_4 = edge.getVertices();
                    var verts_xyz_4 = verts_4.map(function (v) { return v.getPoint().getPosition(); });
                    if (this.textlabels.length === 0) {
                        var geometry = new three__WEBPACK_IMPORTED_MODULE_1__["Geometry"]();
                        for (var i = 0; i < verts_xyz_4.length; i++) {
                            geometry.vertices.push(new three__WEBPACK_IMPORTED_MODULE_1__["Vector3"](verts_xyz_4[i][0], verts_xyz_4[i][1], verts_xyz_4[i][2]));
                        }
                        var material = new three__WEBPACK_IMPORTED_MODULE_1__["LineBasicMaterial"]({ color: 0x00ff00, side: three__WEBPACK_IMPORTED_MODULE_1__["DoubleSide"] });
                        var line = new three__WEBPACK_IMPORTED_MODULE_1__["Line"](geometry, material);
                        line.userData.id = label;
                        //line["material"].needsUpdate=true;
                        line.name = "selects";
                        this.scene.add(line);
                        this.addTextLabel(label, label_xyz, label, path, "Other lines");
                    }
                    else {
                        for (var j = 0; j < this.scene.children.length; j++) {
                            if (label === this.scene.children[j].userData.id) {
                                select = true;
                                this.scene.remove(this.scene.children[j]);
                            }
                        }
                        for (var j = 0; j < this.textlabels.length; j++) {
                            if (label === this.textlabels[j]["id"]) {
                                select = true;
                                this.removeTextLabel(this.textlabels[j]["id"]);
                            }
                        }
                        if (select == false) {
                            var geometry = new three__WEBPACK_IMPORTED_MODULE_1__["Geometry"]();
                            for (var i = 0; i < verts_xyz_4.length; i++) {
                                geometry.vertices.push(new three__WEBPACK_IMPORTED_MODULE_1__["Vector3"](verts_xyz_4[i][0], verts_xyz_4[i][1], verts_xyz_4[i][2]));
                            }
                            var material = new three__WEBPACK_IMPORTED_MODULE_1__["LineBasicMaterial"]({ color: 0x00ff00, side: three__WEBPACK_IMPORTED_MODULE_1__["DoubleSide"] });
                            var line = new three__WEBPACK_IMPORTED_MODULE_1__["Line"](geometry, material);
                            line.userData.id = label;
                            line.name = "selects";
                            this.scene.add(line);
                            this.addTextLabel(label, label_xyz, label, path, "Other lines");
                        }
                    }
                }
            }
            if (this.scenechildren[0].name === "All points") {
                var distance = intersects[0].distanceToRay;
                var index = intersects[0].index;
                for (var i = 1; i < intersects.length; i++) {
                    if (distance > intersects[i].distanceToRay) {
                        distance = intersects[i].distanceToRay;
                        index = intersects[i].index;
                    }
                }
                var attributevertix = this.dataService.getattrvertix();
                var id = this._model.getGeom().getAllPoints()[index].getLabel();
                var label = "";
                var getpoints;
                var getpoints = this.dataService.getpoints;
                var pointname = this.dataService.pointname;
                if (this.SelectVisible === "Points") {
                    if (getpoints !== undefined && getpoints.length !== 0) {
                        for (var i = 0; i < getpoints.length; i++) {
                            if (id === getpoints[i].id) {
                                if (this.dataService.checkpointid === true) {
                                    label = id;
                                    for (var j = 1; j < intersects.length; j++) {
                                        if (intersects[0].distance === intersects[j].distance) {
                                            var index = intersects[j].index;
                                            var id = this._model.getGeom().getAllPoints()[index].getLabel();
                                            if (label !== id)
                                                label = label + "<br/>" + id;
                                        }
                                    }
                                }
                                if (this.dataService.checkX === true)
                                    label = label.concat('<br/>', "X:", getpoints[i].x);
                                if (this.dataService.checkY === true)
                                    label = label.concat('<br/>', "Y:", getpoints[i].y);
                                if (this.dataService.checkZ === true)
                                    label = label.concat('<br/>', "Z:", getpoints[i].z);
                                for (var n = 0; n < pointname.length; n++) {
                                    if (this.dataService.checkname[n] === true) {
                                        label = label.concat('<br/>', pointname[n], ":", getpoints[i][n]);
                                    }
                                }
                            }
                        }
                    }
                }
                if (this.SelectVisible === "Vertices") {
                    var pointid = "";
                    if (getpoints !== undefined && getpoints.length !== 0) {
                        for (var i = 0; i < attributevertix.length; i++) {
                            if (id === attributevertix[i].pointid) {
                                pointid = id;
                                if (this.dataService.checkvertixid === true) {
                                    if (label === "")
                                        label = attributevertix[i].vertixlabel;
                                    else {
                                        label = label + "<br/>" + attributevertix[i].vertixlabel;
                                    }
                                }
                            }
                        }
                        if (this.dataService.pointid === true) {
                            if (pointid !== "") {
                                if (label === "")
                                    label = id;
                                else {
                                    label = label + "<br/>" + id;
                                }
                            }
                        }
                    }
                }
                var verts_xyz_5 = this._model.getGeom().getAllPoints()[index].getPosition(); //vertices.getPoint().getPosition();
                if (this.textlabels.length === 0) {
                    var geometry = new three__WEBPACK_IMPORTED_MODULE_1__["Geometry"]();
                    geometry.vertices.push(new three__WEBPACK_IMPORTED_MODULE_1__["Vector3"](verts_xyz_5[0], verts_xyz_5[1], verts_xyz_5[2]));
                    var pointsmaterial = new three__WEBPACK_IMPORTED_MODULE_1__["PointsMaterial"]({ color: 0x00ff00, size: 1 });
                    //pointsmaterial.sizeAttenuation=false;
                    if (this.dataService.pointsize !== undefined) {
                        pointsmaterial.size = this.dataService.pointsize;
                    }
                    var points = new three__WEBPACK_IMPORTED_MODULE_1__["Points"](geometry, pointsmaterial);
                    points.userData.id = id;
                    //points["material"].needsUpdate=true;
                    points.name = "selects";
                    this.scene.add(points);
                    this.addTextLabel(label, verts_xyz_5, id, id, "All points");
                }
                else {
                    for (var j = 0; j < this.scene.children.length; j++) {
                        if (id === this.scene.children[j].userData.id) {
                            select = true;
                            this.scene.remove(this.scene.children[j]);
                        }
                    }
                    for (var j = 0; j < this.textlabels.length; j++) {
                        if (id === this.textlabels[j]["id"]) {
                            select = true;
                            this.removeTextLabel(this.textlabels[j]["id"]);
                        }
                    }
                    if (select == false) {
                        var geometry = new three__WEBPACK_IMPORTED_MODULE_1__["Geometry"]();
                        geometry.vertices.push(new three__WEBPACK_IMPORTED_MODULE_1__["Vector3"](verts_xyz_5[0], verts_xyz_5[1], verts_xyz_5[2]));
                        var pointsmaterial = new three__WEBPACK_IMPORTED_MODULE_1__["PointsMaterial"]({ color: 0x00ff00, size: 1 });
                        if (this.dataService.pointsize !== undefined) {
                            pointsmaterial.size = this.dataService.pointsize;
                        }
                        var points = new three__WEBPACK_IMPORTED_MODULE_1__["Points"](geometry, pointsmaterial);
                        points.userData.id = id;
                        //points["material"].needsUpdate=true;
                        points.name = "selects";
                        this.scene.add(points);
                        this.addTextLabel(label, verts_xyz_5, id, id, "All points");
                    }
                }
            }
            /*if(this.scenechildren[0].name === "All vertices"){
              var distance:number=intersects[ 0 ].distanceToRay;
              var index:number=intersects[ 0 ].index;
              for(var i=1;i<intersects.length;i++){
                if(distance>intersects[ i ].distanceToRay){
                  distance=intersects[ i ].distanceToRay;
                  index=intersects[ i ].index;
                }
              }
              var id:string=this._model.getGeom().getAllPoints()[index].getLabel();
              var label:string="";
              var getpoints:Array<any>;
              var getpoints=this.dataService.getpoints;
              var pointname=this.dataService.pointname;
      
              /*var path: gs.ITopoPathData = this.scene_and_maps.vertices_map.get(index);
              var vertices: gs.IVertex = this._model.getGeom().getTopo(path) as gs.IVertex;
              var id: string = "";
              var attributevertix=this.dataService.getattrvertix();*/
            //var vertices: gs.IVertex= this._model.getGeom().getTopo(path) as gs.IVertex;
            //var id:string=this._model.getGeom().getAllPoints()[index].getLabel();
            //console.log(vertices.getPoint().getPosition());
            /*var label:string="";
            var attributevertix=this.dataService.getattrvertix();
            console.log(attributevertix);
            for(var i=0;i<attributevertix.length;i++){
              if(vertices.getLabel()===attributevertix[i].vertixlabel){
                id=attributevertix[i].pointid;
                label=vertices.getLabel();
                break;
              }
            }
            console.log(id);
            if(id!==""){
              for(var i=0;i<attributevertix.length;i++){
                if(id===attributevertix[i].pointid){
                  var str=attributevertix[i].vertixlabel;
                  if(label!==str) label=label+"<br/>"+str;
                }
              }
            }*/
            /*const verts_xyz: gs.XYZ = vertices.getPoint().getPosition();//this._model.getGeom().getAllPoints()[index].getPosition();//vertices.getPoint().getPosition();
            console.log(verts_xyz);
            if(this.textlabels.length===0) {
              var geometry=new THREE.Geometry();
              geometry.vertices.push(new THREE.Vector3(verts_xyz[0],verts_xyz[1],verts_xyz[2]));
              var pointsmaterial=new THREE.PointsMaterial( { color:0x00ff00,size:1} );
              //pointsmaterial.sizeAttenuation=false;
              if(this.dataService.pointsize!==undefined){
                pointsmaterial.size=this.dataService.pointsize;
              }
              const points = new THREE.Points( geometry, pointsmaterial);
              points.userData.id=id;
              //points["material"].needsUpdate=true;
              points.name="selects";
              this.scene.add(points);
              this.addTextLabel(label,verts_xyz, id,id,"All points");
            }else{
              for(var j=0;j<this.scene.children.length;j++){
                if(id===this.scene.children[j].userData.id){
                  select=true;
                  this.scene.remove(this.scene.children[j]);
                }
              }
              for(var j=0;j<this.textlabels.length;j++){
                  if(id===this.textlabels[j]["id"]){
                    select=true;
                    this.removeTextLabel(this.textlabels[j]["id"]);
                  }
              }
              if(select==false){
                var geometry=new THREE.Geometry();
                geometry.vertices.push(new THREE.Vector3(verts_xyz[0],verts_xyz[1],verts_xyz[2]));
                var pointsmaterial=new THREE.PointsMaterial( { color:0x00ff00,size:1} );
                if(this.dataService.pointsize!==undefined){
                  pointsmaterial.size=this.dataService.pointsize;
                }
                const points = new THREE.Points( geometry, pointsmaterial);
                points.userData.id=id;
                //points["material"].needsUpdate=true;
                points.name="selects";
                this.scene.add(points);
                this.addTextLabel(label,verts_xyz, id,id,"All points");
              }
            }
          }*/
        }
        else {
            /*for(var i=0;i<this.dataService.sprite.length;i++){
              this.dataService.sprite[i].visible=false;
            }*/
            for (var i = 0; i < this.scene.children.length; i++) {
                if (this.scene.children[i].name == "selects") {
                    this.scene.remove(this.scene.children[i]);
                    i = i - 1;
                }
            }
            for (var i = 0; i < this.textlabels.length; i++) {
                this.removeTextLabel(this.textlabels[i]["id"]);
                i = i - 1;
            }
        }
    };
    //To add text labels just provide label text, label position[x,y,z] and its id
    ViewerComponent.prototype.addTextLabel = function (label, label_xyz, id, path, type) {
        var container = this.myElement.nativeElement.children.namedItem("container");
        var star = this.creatStarGeometry(label_xyz);
        var textLabel = this.createTextLabel(label, star, id, path, type);
        this.starsGeometry.vertices.push(star);
        this.textlabels.push(textLabel);
        this.dataService.pushselecting(textLabel);
        container.appendChild(textLabel.element);
    };
    //To remove text labels just provide its id
    ViewerComponent.prototype.removeTextLabel = function (id) {
        var i = 0;
        for (i = 0; i < this.textlabels.length; i++) {
            if (this.textlabels[i].id == id) {
                var container = this.myElement.nativeElement.children.namedItem("container");
                container.removeChild(this.textlabels[i].element);
                var index = this.starsGeometry.vertices.indexOf(this.textlabels[i].parent);
                if (index !== -1) {
                    this.starsGeometry.vertices.splice(index, 1);
                }
                break;
            }
        }
        if (i < this.textlabels.length) {
            this.textlabels.splice(i, 1);
            this.dataService.spliceselecting(i, 1);
        }
    };
    ViewerComponent.prototype.creatStarGeometry = function (label_xyz) {
        var star = new three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();
        star.x = label_xyz[0];
        star.y = label_xyz[1];
        star.z = label_xyz[2];
        return star;
    };
    ViewerComponent.prototype.createTextLabel = function (label, star, id, path, type) {
        var div = this.createLabelDiv();
        var self = this;
        var textLabel = {
            id: id,
            path: path,
            element: div,
            parent: false,
            type: type,
            position: new three__WEBPACK_IMPORTED_MODULE_1__["Vector3"](0, 0, 0),
            setHTML: function (html) {
                this.element.innerHTML = html;
            },
            setParent: function (threejsobj) {
                this.parent = threejsobj;
            },
            updatePosition: function () {
                if (parent) {
                    //this.position.copy(this.parent);
                    this.position.copy(this.parent);
                }
                var coords2d = this.get2DCoords(this.position, self.camera);
                this.element.style.left = coords2d.x + 'px';
                this.element.style.top = coords2d.y + 'px';
            },
            get2DCoords: function (position, camera) {
                var vector = position.project(camera);
                vector.x = (vector.x + 1) / 2 * self.width;
                vector.y = -(vector.y - 1) / 2 * self.height;
                return vector;
            }
        };
        textLabel.setHTML(label);
        textLabel.setParent(star);
        return textLabel;
    };
    ViewerComponent.prototype.createLabelDiv = function () {
        var div = document.createElement("div");
        div.style.color = '#00f';
        div.style.fontFamily = '"Fira Mono", Monaco, "Andale Mono", "Lucida Console", "Bitstream Vera Sans Mono", "Courier New", Courier, monospace';
        div.style.margin = '-5px 0 0 15px';
        div.style.pointerEvents = 'none';
        div.style.position = 'absolute';
        div.style.width = '100';
        div.style.height = '100';
        div.style.top = '-1000';
        div.style.left = '-1000';
        div.style.textShadow = "0px 0px 3px white";
        div.style.color = "black";
        return div;
    };
    ViewerComponent.prototype.zoomfit = function () {
        event.stopPropagation();
        if (this.dataService.selecting.length === 0) {
            var obj = new three__WEBPACK_IMPORTED_MODULE_1__["Object3D"]();
            for (var i = 0; i < this.getchildren().length; i++) {
                obj.children.push(this.getchildren()[i]);
            }
            var boxHelper = new three__WEBPACK_IMPORTED_MODULE_1__["BoxHelper"](obj);
            boxHelper["geometry"].computeBoundingBox();
            boxHelper["geometry"].computeBoundingSphere();
            var boundingSphere = boxHelper["geometry"].boundingSphere;
            var center = boundingSphere.center;
            var radius = boundingSphere.radius;
            var fov = this.camera.fov * (Math.PI / 180);
            var vec_centre_to_pos = new three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();
            vec_centre_to_pos.subVectors(this.camera.position, center);
            var tmp_vec = new three__WEBPACK_IMPORTED_MODULE_1__["Vector3"](Math.abs(radius / Math.sin(fov / 2) / 2), Math.abs(radius / Math.sin(fov / 2) / 2), Math.abs(radius / Math.sin(fov / 2) / 2));
            vec_centre_to_pos.setLength(tmp_vec.length());
            var perspectiveNewPos = new three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();
            perspectiveNewPos.addVectors(center, vec_centre_to_pos);
            var newLookAt = new three__WEBPACK_IMPORTED_MODULE_1__["Vector3"](center.x, center.y, center.z);
            this.camera.position.copy(perspectiveNewPos);
            this.camera.lookAt(newLookAt);
            this.camera.updateProjectionMatrix();
            this.controls.target.set(newLookAt.x, newLookAt.y, newLookAt.z);
            this.controls.update();
        }
        else {
            var box = this.selectbox();
            var center = new three__WEBPACK_IMPORTED_MODULE_1__["Vector3"](box["geometry"].boundingSphere.center.x, box["geometry"].boundingSphere.center.y, box["geometry"].boundingSphere.center.z);
            var radius = box["geometry"].boundingSphere.radius;
            if (radius === 0)
                radius = 1;
            var fov = this.camera.fov * (Math.PI / 180);
            var vec_centre_to_pos = new three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();
            vec_centre_to_pos.subVectors(this.camera.position, center);
            var tmp_vec = new three__WEBPACK_IMPORTED_MODULE_1__["Vector3"](Math.abs(radius / Math.sin(fov / 2)), Math.abs(radius / Math.sin(fov / 2)), Math.abs(radius / Math.sin(fov / 2)));
            vec_centre_to_pos.setLength(tmp_vec.length());
            var perspectiveNewPos = new three__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();
            perspectiveNewPos.addVectors(center, vec_centre_to_pos);
            var newLookAt = new three__WEBPACK_IMPORTED_MODULE_1__["Vector3"](center.x, center.y, center.z);
            this.camera.position.copy(perspectiveNewPos);
            this.camera.lookAt(newLookAt);
            this.camera.updateProjectionMatrix();
            this.controls.target.set(newLookAt.x, newLookAt.y, newLookAt.z);
            this.controls.update();
        }
    };
    ViewerComponent.prototype.selectbox = function () {
        if (this.dataService.selecting.length !== 0) {
            var select = new three__WEBPACK_IMPORTED_MODULE_1__["Object3D"]();
            for (var i = 0; i < this.scene.children.length; i++) {
                if (this.scene.children[i].name === "selects") {
                    select.children.push(this.scene.children[i]);
                }
            }
            var box = new three__WEBPACK_IMPORTED_MODULE_1__["BoxHelper"](select);
            box["geometry"].computeBoundingBox();
            box["geometry"].computeBoundingSphere();
            return box;
        }
    };
    ViewerComponent.prototype.setting = function (settingVisible) {
        event.stopPropagation();
        this.settingVisible = !this.settingVisible;
    };
    ViewerComponent.prototype.leaflet = function () {
        event.stopPropagation();
        this.imVisible = !this.imVisible;
        this.dataService.imVisible = this.imVisible;
        //console.log(this.dataService.imVisible);
        /*for(var i=0;i<this.scene.children.length;i++){
          if(this.scene.children[i].type!=="DirectionalLight"&&this.scene.children[i].type!=="HemisphereLight"){
            this.scene.remove(this.scene.children[i]);
          }
        }*/
        /*var mymap = L.map('map').setView([51.505, -0.09], 13);
        L.tileLayer('https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token={accessToken}', {
        attribution: 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery © <a href="http://mapbox.com">Mapbox</a>',
        maxZoom: 18,
        id: 'mapbox.streets',
        accessToken: 'your.mapbox.access.token'
        }).addTo(mymap);*/
        /*let map = L.map("map").setView([38, -77], 13);
        console.log(map);
        L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(map);*/
    };
    ViewerComponent = __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"])({
            selector: 'app-viewer',
            template: __webpack_require__(/*! ./viewer.component.html */ "./src/app/mViewer/viewers/gs-viewer/viewer/viewer.component.html"),
            styles: [__webpack_require__(/*! ./viewer.component.css */ "./src/app/mViewer/viewers/gs-viewer/viewer/viewer.component.css")]
        }),
        __metadata("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_0__["Injector"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"]])
    ], ViewerComponent);
    return ViewerComponent;
}(_data_DataSubscriber__WEBPACK_IMPORTED_MODULE_2__["DataSubscriber"]));



/***/ }),

/***/ "./src/app/mViewer/viewers/index.ts":
/*!******************************************!*\
  !*** ./src/app/mViewer/viewers/index.ts ***!
  \******************************************/
/*! exports provided: ConsoleViewerComponent, TextViewerComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _viewer_text_component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./viewer-text.component */ "./src/app/mViewer/viewers/viewer-text.component.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TextViewerComponent", function() { return _viewer_text_component__WEBPACK_IMPORTED_MODULE_0__["TextViewerComponent"]; });

/* harmony import */ var _console_viewer_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./console-viewer.component */ "./src/app/mViewer/viewers/console-viewer.component.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ConsoleViewerComponent", function() { return _console_viewer_component__WEBPACK_IMPORTED_MODULE_1__["ConsoleViewerComponent"]; });



//export * from './template.component';


/***/ }),

/***/ "./src/app/mViewer/viewers/mobius-cesium/data/DataSubscriber.ts":
/*!**********************************************************************!*\
  !*** ./src/app/mViewer/viewers/mobius-cesium/data/DataSubscriber.ts ***!
  \**********************************************************************/
/*! exports provided: DataSubscriber */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataSubscriber", function() { return DataSubscriber; });
/* harmony import */ var _data_service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./data.service */ "./src/app/mViewer/viewers/mobius-cesium/data/data.service.ts");

var DataSubscriber = /** @class */ (function () {
    function DataSubscriber(injector) {
        var _this = this;
        this.dataService = injector.get(_data_service__WEBPACK_IMPORTED_MODULE_0__["DataService"]);
        this._subscription = this.dataService.getMessage().subscribe(function (message) {
            _this._message = message;
            _this.notify(message.text);
        });
    }
    DataSubscriber.prototype.notify = function (message) {
        console.warn("Notify function not Implemented");
    };
    return DataSubscriber;
}());



/***/ }),

/***/ "./src/app/mViewer/viewers/mobius-cesium/data/data.service.ts":
/*!********************************************************************!*\
  !*** ./src/app/mViewer/viewers/mobius-cesium/data/data.service.ts ***!
  \********************************************************************/
/*! exports provided: DataService */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataService", function() { return DataService; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var rxjs_Subject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rxjs/Subject */ "./node_modules/rxjs-compat/_esm5/Subject.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __values = (undefined && undefined.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};


var DataService = /** @class */ (function () {
    function DataService() {
        this.subject = new rxjs_Subject__WEBPACK_IMPORTED_MODULE_1__["Subject"]();
    }
    DataService.prototype.sendMessage = function (message) {
        this.subject.next({ text: message });
    };
    DataService.prototype.clearMessage = function () {
        this.subject.next();
    };
    DataService.prototype.getMessage = function () {
        return this.subject.asObservable();
    };
    //get geojson
    DataService.prototype.getGsModel = function () {
        return this._jsonModel;
    };
    //set mode 
    DataService.prototype.setMode = function (mode) {
        this.mode = mode;
    };
    //set new json file
    DataService.prototype.setGsModel = function (model) {
        delete this._jsonModel;
        var json = this._jsonModel;
        this._jsonModel = model;
        if (this._jsonModel !== undefined) {
            this.clearAll();
        }
        this.sendMessage("model_update");
    };
    //before loading geojson, clear all for last geojson
    DataService.prototype.clearAll = function () {
        delete this.hideElementArr;
        delete this._HideNum;
        delete this._ViData;
        delete this._PuData;
        delete this._index;
        delete this._Filter;
    };
    //get viewer
    DataService.prototype.getViewer = function () {
        return this.viewer;
    };
    //set viewer
    DataService.prototype.setViewer = function (_viewer) {
        this.viewer = _viewer;
    };
    //get selected entity
    DataService.prototype.get_SelectedEntity = function () {
        return this._SelectedEntity;
    };
    //set selected entity
    DataService.prototype.set_SelectedEntity = function (_SelectedEntity) {
        this._SelectedEntity = _SelectedEntity;
    };
    //get promise
    DataService.prototype.getcesiumpromise = function () {
        return this.cesiumpromise;
    };
    //set promise
    DataService.prototype.setcesiumpromise = function (cesiumpromise) {
        delete this.cesiumpromise;
        this.cesiumpromise = cesiumpromise;
    };
    // get filter array
    DataService.prototype.gethideElementArr = function () {
        return this.hideElementArr;
    };
    //get filter number
    DataService.prototype.get_HideNum = function () {
        return this._HideNum;
    };
    //get mode
    DataService.prototype.getmode = function () {
        return this.mode;
    };
    //get index after changing select, data, display, publish
    DataService.prototype.get_index = function () {
        return this._index;
    };
    //set index after changing select, data, display, publish
    DataService.prototype.set_index = function (_index) {
        this._index = _index;
    };
    //set sun true/false in Display
    DataService.prototype.set_Sun = function (_Sun) {
        this._Sun = _Sun;
    };
    //get sun true/false in Display
    DataService.prototype.get_Sun = function () {
        return this._Sun;
    };
    //set shadow true/false in Display
    DataService.prototype.set_Shadow = function (_Shadow) {
        this._Shadow = _Shadow;
    };
    //get shadow true/false in Display
    DataService.prototype.get_Shadow = function () {
        return this._Shadow;
    };
    //set date in Display
    DataService.prototype.set_Date = function (_Date) {
        this._Date = _Date;
    };
    //get date in Display
    DataService.prototype.get_Date = function () {
        return this._Date;
    };
    //set UTC in Display
    DataService.prototype.set_UTC = function (_UTC) {
        this._UTC = _UTC;
    };
    //get UTC in Display
    DataService.prototype.get_UTC = function () {
        return this._UTC;
    };
    //set imagery in Display
    DataService.prototype.set_Imagery = function (_Imagery) {
        this._Imagery = _Imagery;
    };
    //get imagery in Display
    DataService.prototype.get_Imagery = function () {
        return this._Imagery;
    };
    //convert json to ViData(editor version) to store every thing in setting
    DataService.prototype.getValue = function (model) {
        var e_1, _a;
        if (model !== undefined) {
            var propertyName = Object.keys(model["features"][0].properties);
            var feature_instance_1 = model["features"][0];
            var _HeightKeys = propertyName.filter(function (prop_name) {
                var value = feature_instance_1.properties[prop_name];
                return (typeof (value) === "number");
            });
            if (model["features"].length > 1) {
                for (var i = 1; i < model["features"].length; i++) {
                    try {
                        for (var _b = __values(Object.keys(model["features"][i].properties)), _c = _b.next(); !_c.done; _c = _b.next()) {
                            var properties = _c.value;
                            if (propertyName.indexOf(String(properties)) < 0) {
                                propertyName.push(properties);
                                if (typeof (model["features"][i].properties[properties]) === "number") {
                                    _HeightKeys.push(properties);
                                }
                            }
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                }
            }
            propertyName.sort();
            propertyName.unshift("None");
            var propertyNames = propertyName.filter(function (value) {
                return value != 'TYPE' && value != 'COLOR' && value != 'HEIGHT' && value != 'EXTRUDEDHEIGHT';
            });
            var _ColorValue_1 = propertyNames[0];
            var _HeightKey = _HeightKeys.filter(function (value) {
                return value != 'TYPE' && value != 'COLOR' && value != 'HEIGHT' && value != 'EXTRUDEDHEIGHT';
            });
            _HeightKey.sort();
            _HeightKey.unshift("None");
            var _HeightValue_1 = _HeightKey[0];
            var promise = this.cesiumpromise;
            var _Heighttexts_1 = [];
            var _Colortexts_1 = [];
            var _indexArr_1 = [];
            var self_1 = this;
            promise.then(function (dataSource) {
                var e_2, _a;
                var entities = dataSource.entities.values;
                try {
                    for (var entities_1 = __values(entities), entities_1_1 = entities_1.next(); !entities_1_1.done; entities_1_1 = entities_1.next()) {
                        var entity = entities_1_1.value;
                        if (entity.properties["TYPE"] === undefined || entity.properties["TYPE"]._value !== "STATIC") {
                            if (entity.properties[_HeightValue_1] !== undefined) {
                                if (entity.properties[_HeightValue_1]._value !== " ") {
                                    if (_Heighttexts_1.length === 0) {
                                        _Heighttexts_1[0] = entity.properties[_HeightValue_1]._value;
                                    }
                                    else {
                                        if (_Heighttexts_1.indexOf(entity.properties[_HeightValue_1]._value) === -1) {
                                            _Heighttexts_1.push(entity.properties[_HeightValue_1]._value);
                                        }
                                    }
                                }
                            }
                            if (entity.properties[_ColorValue_1] !== undefined) {
                                if (entity.properties[_ColorValue_1]._value !== " ") {
                                    if (_Colortexts_1.length === 0) {
                                        _Colortexts_1[0] = entity.properties[_ColorValue_1]._value;
                                    }
                                    else {
                                        if (_Colortexts_1.indexOf(entity.properties[_ColorValue_1]._value) === -1) {
                                            _Colortexts_1.push(entity.properties[_ColorValue_1]._value);
                                        }
                                    }
                                }
                            }
                            _indexArr_1.push(entities.indexOf(entity));
                        }
                        else {
                            entity.polygon.height = entity.properties["HEIGHT"];
                            entity.polygon.extrudedHeight = entity.properties["EXTRUDEDHEIGHT"];
                            var ColorValue = entity.properties["COLOR"]._value;
                            entity.polygon.material = Cesium.Color.fromBytes(ColorValue[0], ColorValue[1], ColorValue[2], ColorValue[3]);
                        }
                        if (entity.polygon !== undefined) {
                            entity.polygon.outlineColor = Cesium.Color.Black;
                        }
                        if (entity.billboard !== undefined) {
                            entity.billboard = undefined;
                            entity.point = new Cesium.PointGraphics({
                                color: Cesium.Color.BLUE,
                                pixelSize: 10,
                            });
                        }
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (entities_1_1 && !entities_1_1.done && (_a = entities_1.return)) _a.call(entities_1);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            });
            var _MinColor = Math.min.apply(Math, _Colortexts_1);
            var _MaxColor = Math.max.apply(Math, _Colortexts_1);
            var _MinHeight = Math.min.apply(Math, _Heighttexts_1);
            var _MaxHeight = Math.max.apply(Math, _Heighttexts_1);
            var _Filter = [];
            var _HideNum = [];
            this.getViData(propertyNames, _Colortexts_1.sort(), _ColorValue_1, _MinColor, _MaxColor, false, _HeightKey, _Heighttexts_1.sort(), _HeightValue_1, _MinHeight, _MaxHeight, 1, false, false, _Filter, _HideNum, _indexArr_1);
        }
    };
    //get ViData(editor version)
    DataService.prototype.get_ViData = function () {
        return this._ViData;
    };
    //convert geojson to PuData(publish version)
    DataService.prototype.LoadJSONData = function () {
        var e_3, _a, e_4, _b, e_5, _c;
        if (this._jsonModel !== undefined && this._jsonModel["cesium"] !== undefined) {
            var cesiumData = this._jsonModel["cesium"];
            var _ColorDescr = void 0;
            var _ColorValue_2;
            var _MinColor = void 0;
            var _MaxColor = void 0;
            var _ColorInvert = void 0;
            var _HeightDescr = void 0;
            var _HeightKey = [];
            var _HeightValue_2;
            var _MinHeight = void 0;
            var _MaxHeight = void 0;
            var _HeightInvert = void 0;
            var _HeightScale = void 0;
            var _HeightLine = void 0;
            var _filters = void 0;
            var _ceisumData = [];
            var _propertyNames = [];
            var _HideNum = [];
            var _indexArr_2 = [];
            if (cesiumData["colour"] !== undefined) {
                if (cesiumData["colour"]["descr"] !== undefined) {
                    _ColorDescr = cesiumData["colour"]["descr"];
                }
                if (cesiumData["colour"]["attribs"] !== undefined) {
                    try {
                        for (var _d = __values(cesiumData["colour"]["attribs"]), _e = _d.next(); !_e.done; _e = _d.next()) {
                            var data = _e.value;
                            _propertyNames.push(data["name"]);
                        }
                    }
                    catch (e_3_1) { e_3 = { error: e_3_1 }; }
                    finally {
                        try {
                            if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
                        }
                        finally { if (e_3) throw e_3.error; }
                    }
                    _ColorValue_2 = _propertyNames[0];
                    _MinColor = cesiumData["colour"]["attribs"][0]["min"];
                    _MaxColor = cesiumData["colour"]["attribs"][0]["max"];
                    if (cesiumData["colour"]["attribs"][0]["invert"] === true) {
                        _ColorInvert = true;
                    }
                    else {
                        _ColorInvert = false;
                    }
                }
            }
            if (cesiumData["extrude"] !== undefined) {
                if (cesiumData["extrude"]["descr"] !== undefined) {
                    _HeightDescr = cesiumData["extrude"]["descr"];
                }
                if (cesiumData["extrude"]["attribs"] !== undefined) {
                    try {
                        for (var _f = __values(cesiumData["extrude"]["attribs"]), _g = _f.next(); !_g.done; _g = _f.next()) {
                            var data = _g.value;
                            _HeightKey.push(data["name"]);
                        }
                    }
                    catch (e_4_1) { e_4 = { error: e_4_1 }; }
                    finally {
                        try {
                            if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
                        }
                        finally { if (e_4) throw e_4.error; }
                    }
                    _HeightValue_2 = _HeightKey[0];
                    _MinHeight = cesiumData["extrude"]["attribs"][0]["min"];
                    _MaxHeight = cesiumData["extrude"]["attribs"][0]["max"];
                    if (cesiumData["extrude"]["attribs"][0]["invert"] === true) {
                        _HeightInvert = true;
                    }
                    else {
                        _HeightInvert = false;
                    }
                    if (cesiumData["extrude"]["attribs"][0]["line"] === true) {
                        _HeightLine = true;
                    }
                    else {
                        _HeightLine = false;
                    }
                    if (cesiumData["extrude"]["attribs"][0]["scale"] !== undefined) {
                        _HeightScale = cesiumData["extrude"]["attribs"][0]["scale"];
                    }
                    else {
                        _HeightScale = 1;
                    }
                }
            }
            var promise = this.cesiumpromise;
            var _Heighttexts_2 = [];
            var _Colortexts_2 = [];
            var self_2 = this;
            promise.then(function (dataSource) {
                var e_6, _a;
                var entities = dataSource.entities.values;
                try {
                    for (var entities_2 = __values(entities), entities_2_1 = entities_2.next(); !entities_2_1.done; entities_2_1 = entities_2.next()) {
                        var entity = entities_2_1.value;
                        if (entity.properties[_HeightValue_2] !== undefined) {
                            if (entity.properties[_HeightValue_2]._value !== " ") {
                                if (_Heighttexts_2.length === 0) {
                                    _Heighttexts_2[0] = entity.properties[_HeightValue_2]._value;
                                }
                                else {
                                    if (_Heighttexts_2.indexOf(entity.properties[_HeightValue_2]._value) === -1) {
                                        _Heighttexts_2.push(entity.properties[_HeightValue_2]._value);
                                    }
                                }
                            }
                        }
                        if (entity.properties[_ColorValue_2] !== undefined) {
                            if (entity.properties[_ColorValue_2]._value !== " ") {
                                if (_Colortexts_2.length === 0) {
                                    _Colortexts_2[0] = entity.properties[_ColorValue_2]._value;
                                }
                                else {
                                    if (_Colortexts_2.indexOf(entity.properties[_ColorValue_2]._value) === -1) {
                                        _Colortexts_2.push(entity.properties[_ColorValue_2]._value);
                                    }
                                }
                            }
                        }
                        if (entity.polygon !== undefined) {
                            entity.polygon.outlineColor = Cesium.Color.Black;
                        }
                        if (entity.billboard !== undefined) {
                            entity.billboard = undefined;
                            entity.point = new Cesium.PointGraphics({
                                color: Cesium.Color.BLUE,
                                pixelSize: 10,
                            });
                        }
                        _indexArr_2.push(entities.indexOf(entity));
                    }
                }
                catch (e_6_1) { e_6 = { error: e_6_1 }; }
                finally {
                    try {
                        if (entities_2_1 && !entities_2_1.done && (_a = entities_2.return)) _a.call(entities_2);
                    }
                    finally { if (e_6) throw e_6.error; }
                }
            });
            if (cesiumData["filters"] !== undefined) {
                _filters = cesiumData["filters"];
                var lastnumber = void 0;
                this._Filter = [];
                this._HideNum = [];
                if (_filters !== undefined && _filters.length !== 0) {
                    try {
                        for (var _filters_1 = __values(_filters), _filters_1_1 = _filters_1.next(); !_filters_1_1.done; _filters_1_1 = _filters_1.next()) {
                            var _filter = _filters_1_1.value;
                            if (this._HideNum.length === 0) {
                                this._HideNum[0] = "0";
                                lastnumber = this._HideNum[0];
                            }
                            else {
                                for (var j = 0; j < this._HideNum.length + 1; j++) {
                                    if (this._HideNum.indexOf(String(j)) === -1) {
                                        this._HideNum.push(String(j));
                                        lastnumber = String(j);
                                        break;
                                    }
                                }
                            }
                            if (_filter["name"] !== undefined) {
                                var _propertyname = _filter["name"];
                                var _relation = Number(_filter["relation"]);
                                var _text = _filter["value"];
                                var _descr = _filter["descr"];
                                var _HideType = void 0;
                                var _texts = void 0;
                                if (typeof (_text) === "number") {
                                    _HideType = "number";
                                    _texts = this.Initial(_propertyname);
                                }
                                else if (typeof (_text) === "string") {
                                    _HideType = "category";
                                    _texts = this.Initial(_propertyname);
                                    _texts = ["None"].concat(_texts);
                                }
                                this._Filter.push({ divid: String("addHide".concat(String(lastnumber))), id: lastnumber,
                                    HeightHide: _propertyname, type: _HideType, Category: _texts,
                                    CategaryHide: _text, descr: _descr, RelaHide: _relation,
                                    textHide: _text, HideMax: Math.ceil(Math.max.apply(Math, _texts)),
                                    HideMin: Math.floor(Math.min.apply(Math, _texts) * 100) / 100, Disabletext: null });
                            }
                        }
                    }
                    catch (e_5_1) { e_5 = { error: e_5_1 }; }
                    finally {
                        try {
                            if (_filters_1_1 && !_filters_1_1.done && (_c = _filters_1.return)) _c.call(_filters_1);
                        }
                        finally { if (e_5) throw e_5.error; }
                    }
                }
            }
            else {
                this._Filter = [];
                this._HideNum = [];
            }
            this.getPuData(_ColorDescr, _propertyNames, _Colortexts_2.sort(), _ColorValue_2, _MinColor, _MaxColor, _ColorInvert, _HeightDescr, _HeightKey, _Heighttexts_2.sort(), _HeightValue_2, _MinHeight, _MaxHeight, _HeightScale, _HeightInvert, _HeightLine, this._Filter, this._HideNum, _indexArr_2);
        }
    };
    //get text for the certain property
    DataService.prototype.Initial = function (_HideValue) {
        var texts = [];
        var promise = this.getcesiumpromise();
        var self = this;
        promise.then(function (dataSource) {
            var e_7, _a;
            var entities = dataSource.entities.values;
            try {
                for (var entities_3 = __values(entities), entities_3_1 = entities_3.next(); !entities_3_1.done; entities_3_1 = entities_3.next()) {
                    var entity = entities_3_1.value;
                    if (entity.properties[_HideValue] !== undefined) {
                        if (entity.properties[_HideValue]._value !== " ") {
                            if (texts.length === 0) {
                                texts[0] = entity.properties[_HideValue]._value;
                            }
                            else {
                                if (texts.indexOf(entity.properties[_HideValue]._value) === -1) {
                                    texts.push(entity.properties[_HideValue]._value);
                                }
                            }
                        }
                    }
                }
            }
            catch (e_7_1) { e_7 = { error: e_7_1 }; }
            finally {
                try {
                    if (entities_3_1 && !entities_3_1.done && (_a = entities_3.return)) _a.call(entities_3);
                }
                finally { if (e_7) throw e_7.error; }
            }
        });
        return texts;
    };
    //get PuData
    DataService.prototype.get_PuData = function () {
        return this._PuData;
    };
    //// ------------------- Settings
    /*
     * to set visualize settings
     *
     */
    /*
     *  _PuData : Object with properties .... <todo>
     */
    DataService.prototype.set_PuData = function (_PuData) {
        this._PuData = _PuData;
    };
    /*
     *  _ViData : Object with properties .... <todo>
     */
    DataService.prototype.set_ViData = function (_ViData) {
        this._ViData = _ViData;
    };
    /*
    _ColorProperty: collect all property names,
    _ColorText: collect all values under _ColorKey,
    _ColorKey: Select color property name in Data tab,
    _ColorMin: minimum value of Color property in Data tab,
    _ColorMax: maximum value of Color property in Data tab,
    _ColorInvert: color invert is true or false,
    _ExtrudeProperty: collect all property names that whose values are number,
    _ExtrudeText: collect all values under _ExturdeValue,
    _ExturdeValue: Select Extrude property name in Data tab,
    _ExtrudeMin: minimum value of Extrude property in Data tab,
    _ExtrudeMax: maximum value of Extrude property in Data tab,
    _Scale: extrude height scale,
    _Invert: extrude height invert is true or false,
    _HeightChart: it will show height chart or not,
    _Filter: collect filters,
    _HideNum: collect filter id numbers,
    _indexArr: collect entity number whose "TYPE" is not static
    */
    DataService.prototype.getViData = function (_ColorProperty, _ColorText, _ColorKey, _ColorMin, _ColorMax, _ColorInvert, _ExtrudeProperty, _ExtrudeText, _ExturdeValue, _ExtrudeMin, _ExtrudeMax, _Scale, _Invert, _HeightChart, _Filter, _HideNum, _indexArr) {
        this._ViData = { ColorProperty: _ColorProperty, ColorText: _ColorText, ColorKey: _ColorKey,
            ColorMin: _ColorMin, ColorMax: _ColorMax, ColorInvert: _ColorInvert,
            ExtrudeProperty: _ExtrudeProperty, ExtrudeText: _ExtrudeText, ExtrudeKey: _ExturdeValue,
            ExtrudeMin: _ExtrudeMin, ExtrudeMax: _ExtrudeMax, Scale: _Scale, Invert: _Invert,
            HeightChart: _HeightChart, Filter: _Filter, HideNum: _HideNum, indexArr: _indexArr };
    };
    /*
    _ColorDescr: description of Color property,
    _ColorProperty: collect all property names,
    _ColorText: collect all values under _ColorKey,
    _ColorKey: Select color property name in Data tab,
    _ColorMin: minimum value of Color property in Data tab,
    _ColorMax: maximum value of Color property in Data tab,
    _ColorInvert: color invert is true or false,
    _ExtrudeDescr: description of extrude height property,
    _ExtrudeProperty: collect all property names that whose values are number,
    _ExtrudeText: collect all values under _ExturdeValue,
    _ExturdeValue: Select Extrude property name in Data tab,
    _ExtrudeMin: minimum value of Extrude property in Data tab,
    _ExtrudeMax: maximum value of Extrude property in Data tab,
    _Scale: extrude height scale,
    _Invert: extrude height invert is true or false,
    _HeightChart: it will show height chart or not,
    _Filter: collect filters,
    _HideNum: collect filter id numbers,
    _indexArr: collect entity number whose "TYPE" is not static
     */
    DataService.prototype.getPuData = function (_ColorDescr, _ColorProperty, _ColorText, _ColorKey, _ColorMin, _ColorMax, _ColorInvert, _ExtrudeDescr, _ExtrudeProperty, _ExtrudeText, _ExturdeValue, _ExtrudeMin, _ExtrudeMax, _Scale, _Invert, _HeightChart, _Filter, _HideNum, _indexArr) {
        this._PuData = { ColorDescr: _ColorDescr, ColorProperty: _ColorProperty, ColorText: _ColorText,
            ColorKey: _ColorKey, ColorMin: _ColorMin, ColorMax: _ColorMax, ColorInvert: _ColorInvert,
            ExtrudeDescr: _ExtrudeDescr, ExtrudeProperty: _ExtrudeProperty, ExtrudeText: _ExtrudeText,
            ExtrudeKey: _ExturdeValue, ExtrudeMin: _ExtrudeMin, ExtrudeMax: _ExtrudeMax,
            Scale: _Scale, Invert: _Invert, HeightChart: _HeightChart, Filter: _Filter, HideNum: _HideNum, indexArr: _indexArr };
    };
    DataService = __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Injectable"])()
    ], DataService);
    return DataService;
}());



/***/ }),

/***/ "./src/app/mViewer/viewers/mobius-cesium/mobius-cesium.component.html":
/*!****************************************************************************!*\
  !*** ./src/app/mViewer/viewers/mobius-cesium/mobius-cesium.component.html ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<div id=\"mobiuscesium\" style=\"height: 100%\">\r\n\t<cesium-viewer></cesium-viewer>\r\n\t<div id=\"Toggle\" (click)=\"toggleSlider()\" ><span style=\"vertical-align: middle;\">▹</span></div>\r\n\t<div id=\"slide-nav\"  [@slide_in_out]=\"slider_state\" style=\"position: absolute;z-index: 101;top:0px;height: 100%\">\r\n  \t\t<app-setting-cesium ></app-setting-cesium>\r\n\t</div>\r\n\r\n</div>\r\n"

/***/ }),

/***/ "./src/app/mViewer/viewers/mobius-cesium/mobius-cesium.component.scss":
/*!****************************************************************************!*\
  !*** ./src/app/mViewer/viewers/mobius-cesium/mobius-cesium.component.scss ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "@import url(\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css\");\n@font-face {\n  font-family: \"FontAwesome\"; }\n.font-awesome-hand {\n  font-family: FontAwesome; }\n.font-awesome-hand::after {\n  font-family: FontAwesome; }\n#mobiuscesium {\n  height: 101%;\n  font-family: sans-serif !important;\n  margin: 0px !important;\n  padding: 0px !important;\n  font-size: 14px; }\n#button {\n  position: absolute;\n  z-index: 99; }\n#Toggle {\n  position: absolute;\n  top: calc(50% - 30px);\n  z-index: 200;\n  width: 30px;\n  height: 70px;\n  border-top: 1px solid gray;\n  border-right: 1px solid gray;\n  border-bottom: 1px solid gray;\n  background-color: rgba(20, 20, 20, 0.5);\n  color: #ddd;\n  text-align: center;\n  font-size: 32px;\n  line-height: 70px;\n  cursor: pointer; }\n"

/***/ }),

/***/ "./src/app/mViewer/viewers/mobius-cesium/mobius-cesium.component.ts":
/*!**************************************************************************!*\
  !*** ./src/app/mViewer/viewers/mobius-cesium/mobius-cesium.component.ts ***!
  \**************************************************************************/
/*! exports provided: MobiuscesiumComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MobiuscesiumComponent", function() { return MobiuscesiumComponent; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var _data_data_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data/data.service */ "./src/app/mViewer/viewers/mobius-cesium/data/data.service.ts");
/* harmony import */ var _angular_animations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/animations */ "./node_modules/@angular/animations/fesm5/animations.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



var defaultText = "{\n  \"type\": \"FeatureCollection\",\n  \"name\": \"default\",\n  \"crs\": { \"type\": \"name\", \"properties\": { \"name\": \"0\" } },\n  \"features\": [\n  { \"type\": \"Feature\", \"properties\": { \"OBJECTID\": 1, \"OID_1\": 0, \"INC_CRC\": \"593E775CE158CC1F\", \"FMEL_UPD_D\": \"2014/06/23\", \"X_ADDR\": 26044.8109, \"Y_ADDR\": 48171.43, \"SHAPE_Leng\": 298.85929234299999, \"SHAPE_Area\": 1070.8993405900001 }, \"geometry\": { \"type\": \"MultiPolygon\", \"coordinates\": [] } }\n  ]\n  }";
var MobiuscesiumComponent = /** @class */ (function () {
    function MobiuscesiumComponent(dataService) {
        this.dataService = dataService;
        //create slider to switch setting
        this.slider_state = "slide_out";
    }
    ;
    //pass data to dataService
    MobiuscesiumComponent.prototype.setModel = function (data) {
        try {
            this.dataService.setGsModel(data);
        }
        catch (ex) {
            this.text = '';
            this.data = undefined;
        }
    };
    //pass data to dataService
    MobiuscesiumComponent.prototype.ngOnInit = function () {
        this.text = this.node.output.value;
        this.data = JSON.parse(this.text || defaultText);
        this.setModel(this.data);
        this.dataService.setMode(this.mode);
        // console.log(this.data);
    };
    MobiuscesiumComponent.prototype.ngDoCheck = function () {
        if (this.text !== this.node.output.value) {
            this.text = this.node.output.value;
            this.data = JSON.parse(this.text || defaultText);
            this.setModel(this.data);
            // console.log("data changed");
            // console.log("mode:", this.mode);
        }
    };
    MobiuscesiumComponent.prototype.toggleSlider = function () {
        // do something to change the animation_state variable
        this.slider_state = this.slider_state === "slide_out" ? "slide_in" : "slide_out";
        var toggle = document.getElementById("Toggle");
        if (this.slider_state === "slide_out") {
            toggle.style.left = "0px";
            toggle.innerHTML = "▹";
        }
        else if (this.slider_state === "slide_in") {
            toggle.style.left = "280px";
            toggle.innerHTML = "◃";
        }
    };
    __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(),
        __metadata("design:type", Object)
    ], MobiuscesiumComponent.prototype, "node", void 0);
    __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(),
        __metadata("design:type", String)
    ], MobiuscesiumComponent.prototype, "mode", void 0);
    MobiuscesiumComponent = __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"])({
            selector: "mobius-cesium",
            template: __webpack_require__(/*! ./mobius-cesium.component.html */ "./src/app/mViewer/viewers/mobius-cesium/mobius-cesium.component.html"),
            styles: [__webpack_require__(/*! ./mobius-cesium.component.scss */ "./src/app/mViewer/viewers/mobius-cesium/mobius-cesium.component.scss")],
            animations: [
                Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["trigger"])("slide_in_out", [
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["state"])("slide_in", Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["style"])({
                        width: "280px",
                    })),
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["state"])("slide_out", Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["style"])({
                        width: "0px"
                        // css styles when the element is in slide_out
                    })),
                    // animation effect when transitioning from one state to another
                    Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["transition"])("slide_in <=> slide_out", Object(_angular_animations__WEBPACK_IMPORTED_MODULE_2__["animate"])(300))
                ]),
            ],
        }),
        __metadata("design:paramtypes", [_data_data_service__WEBPACK_IMPORTED_MODULE_1__["DataService"]])
    ], MobiuscesiumComponent);
    return MobiuscesiumComponent;
}());



/***/ }),

/***/ "./src/app/mViewer/viewers/mobius-cesium/mobius-cesium.module.ts":
/*!***********************************************************************!*\
  !*** ./src/app/mViewer/viewers/mobius-cesium/mobius-cesium.module.ts ***!
  \***********************************************************************/
/*! exports provided: MobiusCesium */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MobiusCesium", function() { return MobiusCesium; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm5/common.js");
/* harmony import */ var _mobius_cesium_component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mobius-cesium.component */ "./src/app/mViewer/viewers/mobius-cesium/mobius-cesium.component.ts");
/* harmony import */ var _viewer_viewer_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./viewer/viewer.component */ "./src/app/mViewer/viewers/mobius-cesium/viewer/viewer.component.ts");
/* harmony import */ var _data_data_service__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./data/data.service */ "./src/app/mViewer/viewers/mobius-cesium/data/data.service.ts");
/* harmony import */ var angular_split__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! angular-split */ "./node_modules/angular-split/fesm5/angular-split.js");
/* harmony import */ var _angular_material_tabs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/material/tabs */ "./node_modules/@angular/material/esm5/tabs.es5.js");
/* harmony import */ var _angular_material_tooltip__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/material/tooltip */ "./node_modules/@angular/material/esm5/tooltip.es5.js");
/* harmony import */ var _angular_material_slider__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @angular/material/slider */ "./node_modules/@angular/material/esm5/slider.es5.js");
/* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @angular/forms */ "./node_modules/@angular/forms/fesm5/forms.js");
/* harmony import */ var _setting_setting_component__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./setting/setting.component */ "./src/app/mViewer/viewers/mobius-cesium/setting/setting.component.ts");
/* harmony import */ var _setting_visualise_component__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./setting/visualise.component */ "./src/app/mViewer/viewers/mobius-cesium/setting/visualise.component.ts");
/* harmony import */ var _setting_attributes_copmponent__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./setting/attributes.copmponent */ "./src/app/mViewer/viewers/mobius-cesium/setting/attributes.copmponent.ts");
/* harmony import */ var _setting_publish_component__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./setting/publish.component */ "./src/app/mViewer/viewers/mobius-cesium/setting/publish.component.ts");
/* harmony import */ var _setting_display_copmponent__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./setting/display.copmponent */ "./src/app/mViewer/viewers/mobius-cesium/setting/display.copmponent.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};















var MobiusCesium = /** @class */ (function () {
    function MobiusCesium() {
    }
    MobiusCesium_1 = MobiusCesium;
    MobiusCesium.forRoot = function () {
        return {
            ngModule: MobiusCesium_1,
            providers: [
                _data_data_service__WEBPACK_IMPORTED_MODULE_4__["DataService"],
            ],
        };
    };
    var MobiusCesium_1;
    MobiusCesium = MobiusCesium_1 = __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"])({
            imports: [_angular_common__WEBPACK_IMPORTED_MODULE_1__["CommonModule"],
                angular_split__WEBPACK_IMPORTED_MODULE_5__["AngularSplitModule"],
                _angular_material_tabs__WEBPACK_IMPORTED_MODULE_6__["MatTabsModule"],
                _angular_material_tooltip__WEBPACK_IMPORTED_MODULE_7__["MatTooltipModule"],
                _angular_material_slider__WEBPACK_IMPORTED_MODULE_8__["MatSliderModule"],
                _angular_forms__WEBPACK_IMPORTED_MODULE_9__["FormsModule"]
            ],
            exports: [_mobius_cesium_component__WEBPACK_IMPORTED_MODULE_2__["MobiuscesiumComponent"]],
            declarations: [_mobius_cesium_component__WEBPACK_IMPORTED_MODULE_2__["MobiuscesiumComponent"],
                _viewer_viewer_component__WEBPACK_IMPORTED_MODULE_3__["ViewerComponent"],
                _setting_setting_component__WEBPACK_IMPORTED_MODULE_10__["SettingComponent"],
                _setting_visualise_component__WEBPACK_IMPORTED_MODULE_11__["DataComponent"],
                _setting_attributes_copmponent__WEBPACK_IMPORTED_MODULE_12__["SelectComponent"],
                _setting_publish_component__WEBPACK_IMPORTED_MODULE_13__["PublishComponent"],
                _setting_display_copmponent__WEBPACK_IMPORTED_MODULE_14__["DisplayComponent"]],
            providers: [_data_data_service__WEBPACK_IMPORTED_MODULE_4__["DataService"]],
        })
    ], MobiusCesium);
    return MobiusCesium;
}());



/***/ }),

/***/ "./src/app/mViewer/viewers/mobius-cesium/setting/attributes.component.css":
/*!********************************************************************************!*\
  !*** ./src/app/mViewer/viewers/mobius-cesium/setting/attributes.component.css ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "/deep/.mat-tab-label, /deep/.mat-tab-label-active{\r\n  min-width: 60px!important;\r\n  padding: 3px!important;\r\n  margin: 3px!important;\r\n  color:#D3D3D3 !important;\r\n  background-color: transparent !important;\r\n}\r\n/deep/.mat-tab-label{\r\n  height: 30px !important;\r\n  width: 60px !important;\r\n  background-color: transparent !important;\r\n}\r\n/deep/.mat-tab-labels{\r\n  background-color: rgba(20,20,20,0.9) !important;\r\n}\r\n/deep/.mat-tab-header{\r\n  width: 700px !important;\r\n}\r\n/deep/.mat-tab-header-pagination-controls-enabled{\r\n  display: none !important;\r\n}\r\n/deep/.mat-ink-bar{\r\n  background-color: #395d73 !important;\r\n}\r\n/deep/.mat-tab{\r\n  min-width: 30px !important;\r\n}\r\n/deep/.mat-tab-body-content{\r\n  overflow: hidden !important;\r\n}\r\n/deep/.mat-header{\r\n  flex-direction: row;\r\n  font-family: Roboto,\"Helvetica Neue\",sans-serif;\r\n  margin-left: 0px;\r\n  color:#395d73;\r\n  border: 0;\r\n  height: 20px;\r\n  background-color: rgba(20,20,20,0.9) !important;\r\n}\r\n/deep/.mat-tab-body-wrapper{\r\n  height:100% !important;\r\n\r\n}\r\n/deep/split-gutter{\r\n  background-color:rgb(138, 168, 192) !important;\r\n}\r\n/deep/.mat-accent .mat-slider-thumb {\r\n    background-color: #8AA8C0 !important;\r\n    cursor: -webkit-grab;\r\n}\r\n/deep/.mat-slider-thumb{\r\n  width: 5px !important;\r\n  right: -5px !important;\r\n}\r\n/deep/.mat-slider-track-fill{\r\n  background-color: #F0BFA0 !important;\r\n}\r\n/deep/.mat-slider-thumb-label-text {\r\n    color: #395d73 !important;\r\n    font-size: 12px !important;\r\n}\r\n/deep/.mat-slider-thumb-label{\r\n    height: 15px !important;\r\n    width: 15px !important;\r\n    top: -20px !important;\r\n    right: -7px !important;\r\n    background-color: white !important;\r\n    border: 1px solid #395d73 !important;\r\n}\r\n/deep/.mat-slider-track-background{\r\n  background-color: #D3D3D3 !important;\r\n}\r\n.mat-slider{\r\n    width: 150px !important;\r\n}\r\n.cesium-button {\r\n  display: inline-block;\r\n  position: relative;\r\n  border: 1px solid #8AA8C0;\r\n  color: #D3D3D3;\r\n  fill: #8AA8C0;\r\n  border-radius: 0px;\r\n  padding: 3px 0px;\r\n  margin: 0px 0px;\r\n  cursor: pointer;\r\n  overflow: hidden;\r\n  -moz-user-select: none;\r\n  -webkit-user-select: none;\r\n  -ms-user-select: none;\r\n  user-select: none;\r\n  width: 80px;\r\n  font-family:sans-serif !important;\r\n  background: transparent;\r\n}\r\n.cesium-button-select{\r\n  display: inline-block;\r\n  position: relative;\r\n  border: 1px solid #8AA8C0;\r\n  fill: #8AA8C0;\r\n  border-radius: 0px;\r\n  padding: 3px 0px;\r\n  margin: 0px 0px;\r\n  cursor: pointer;\r\n  overflow: hidden;\r\n  -moz-user-select: none;\r\n  -webkit-user-select: none;\r\n  -ms-user-select: none;\r\n  user-select: none;\r\n  width: 80px;\r\n  font-family:sans-serif !important;\r\n  color: #D3D3D3;\r\n  background: transparent;\r\n}\r\n.cesium-option{\r\n  background-color: #F1F1F1;\r\n  /*opacity: 0.8;*/\r\n  color: #8AA8C0;\r\n  border: 1px solid #8AA8C0;\r\n}\r\nhr {\r\n  display: block;\r\n  height: 1px;\r\n  border: 0;\r\n  border-top: 1px solid #D3D3D3 !important;\r\n  padding: 0; \r\n  color:#D3D3D3 !important;\r\n  width: 100%;\r\n  background-color: #D3D3D3 !important;\r\n}\r\n\r\n"

/***/ }),

/***/ "./src/app/mViewer/viewers/mobius-cesium/setting/attributes.component.html":
/*!*********************************************************************************!*\
  !*** ./src/app/mViewer/viewers/mobius-cesium/setting/attributes.component.html ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<div id=\"AttribsView\"  style=\"background-color: rgba(20,20,20,0.9);height: 100%;overflow-y:overlay;\"  >\r\n\t<table border=\"1\" cellspacing=\"0\" cellpadding=\"0\" bordercolor=\"#d0d0d0\">\r\n\t  <tr >\r\n\t    <th style=\"font-size: 10px;font-weight: normal;width: 135px;\"><div style=\"width: 135px;height:16px;background: #395D73;color:white;white-space: nowrap;display:block;overflow: hidden !important;text-overflow: ellipsis !important;cursor:pointer;\">ID</div></th>\r\n\t    <th style=\"font-size: 10px;font-weight: normal;width: 135px\"><div matTooltip={{ID}} style=\"width: 135px;height:16px;background: #395D73;color:white;white-space: nowrap;display:block;overflow: hidden !important;text-overflow: ellipsis !important;cursor:pointer;\">{{ID}}</div></th>\r\n\t  </tr>\r\n\t</table>\r\n\t<table border=\"1\" cellspacing=\"0\" cellpadding=\"0\" bordercolor=\"#d0d0d0\">\r\n\t  <tr *ngFor=\"let Property of _Properties\">\r\n\t    <th style=\"font-size: 10px;font-weight: normal;color:#D3D3D3 ;width: 135px;height: 14px\"><div matTooltip={{Property.Name}} style=\"width: 135px;height:14px;text-align: left;white-space: nowrap;display:block;overflow: hidden !important;text-overflow: ellipsis !important;cursor:pointer;\">{{Property.Name}}</div></th>\r\n\t    <th style=\"font-size: 10px;font-weight: normal;color:#D3D3D3 ;width: 135px;height: 14px\"><div matTooltip={{Property.Value}} style=\"width: 135px;height:14px;text-align: left;white-space: nowrap;display:block;overflow: hidden !important;text-overflow: ellipsis !important;cursor:pointer;\">{{Property.Value}}</div></th>\r\n\t  </tr>\r\n\t</table>\r\n</div>\r\n  "

/***/ }),

/***/ "./src/app/mViewer/viewers/mobius-cesium/setting/attributes.copmponent.ts":
/*!********************************************************************************!*\
  !*** ./src/app/mViewer/viewers/mobius-cesium/setting/attributes.copmponent.ts ***!
  \********************************************************************************/
/*! exports provided: SelectComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SelectComponent", function() { return SelectComponent; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var _data_DataSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../data/DataSubscriber */ "./src/app/mViewer/viewers/mobius-cesium/data/DataSubscriber.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __values = (undefined && undefined.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};


var SelectComponent = /** @class */ (function (_super) {
    __extends(SelectComponent, _super);
    function SelectComponent(injector, myElement) {
        return _super.call(this, injector) || this;
    }
    SelectComponent.prototype.ngOnInit = function () {
        this.data = this.dataService.getGsModel();
        this.mode = this.dataService.getmode();
        this.viewer = this.dataService.getViewer();
        this.dataArr = this.dataService.get_ViData();
    };
    SelectComponent.prototype.notify = function (message) {
        if (message === "model_update") {
            this.data = this.dataService.getGsModel();
            this.mode = this.dataService.getmode();
            this.dataArr = this.dataService.get_ViData();
        }
    };
    //check whether ID is changed or not and show in  Select tab
    SelectComponent.prototype.ngDoCheck = function () {
        var e_1, _a;
        if (this.viewer !== undefined && this.dataService.get_SelectedEntity() !== undefined && this.mode === "editor") {
            if (this.ID !== this.dataService.get_SelectedEntity()._id) {
                var _Property = void 0;
                this.ID = this.dataService.get_SelectedEntity()._id;
                this._Properties = [];
                try {
                    for (var _b = __values(this.dataArr["ColorProperty"]), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var _ColorPro = _c.value;
                        if (_ColorPro !== "None") {
                            _Property = [];
                            _Property.Name = _ColorPro;
                            if (this.dataService.get_SelectedEntity().properties[_Property.Name] !== undefined) {
                                _Property.Value = this.dataService.get_SelectedEntity().properties[_Property.Name]._value;
                            }
                            else {
                                _Property.Value = ' ';
                            }
                            this._Properties.push(_Property);
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
        }
    };
    SelectComponent = __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"])({
            selector: "app-select",
            template: __webpack_require__(/*! ./attributes.component.html */ "./src/app/mViewer/viewers/mobius-cesium/setting/attributes.component.html"),
            styles: [__webpack_require__(/*! ./attributes.component.css */ "./src/app/mViewer/viewers/mobius-cesium/setting/attributes.component.css")],
        }),
        __metadata("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_0__["Injector"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"]])
    ], SelectComponent);
    return SelectComponent;
}(_data_DataSubscriber__WEBPACK_IMPORTED_MODULE_1__["DataSubscriber"]));



/***/ }),

/***/ "./src/app/mViewer/viewers/mobius-cesium/setting/display.copmponent.css":
/*!******************************************************************************!*\
  !*** ./src/app/mViewer/viewers/mobius-cesium/setting/display.copmponent.css ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "/*/deep/.mat-tab-label, /deep/.mat-tab-label-active{\r\n  min-width: 60px!important;\r\n  padding: 3px!important;\r\n  margin: 3px!important;\r\n  color:#D3D3D3 !important;\r\n  background-color: transparent !important;\r\n}\r\n/deep/.mat-tab-label{\r\n  height: 30px !important;\r\n  width: 60px !important;\r\n  background-color: transparent !important;\r\n}\r\n/deep/.mat-tab-labels{\r\n  background-color: rgba(20,20,20,0.9) !important;\r\n}\r\n/deep/.mat-tab-header{\r\n  width: 700px !important;\r\n}\r\n/deep/.mat-tab-header-pagination-controls-enabled{\r\n  display: none !important;\r\n}\r\n\r\n/deep/.mat-ink-bar{\r\n  background-color: #395d73 !important;\r\n}\r\n\r\n/deep/.mat-tab{\r\n  min-width: 30px !important;\r\n}\r\n/deep/.mat-tab-body-content{\r\n  overflow: hidden !important;\r\n}\r\n\r\n/deep/.mat-header{\r\n  flex-direction: row;\r\n  font-family: Roboto,\"Helvetica Neue\",sans-serif;\r\n  margin-left: 0px;\r\n  color:#395d73;\r\n  border: 0;\r\n  height: 20px;\r\n  background-color: rgba(20,20,20,0.9) !important;\r\n}\r\n/deep/.mat-tab-body-wrapper{\r\n  height:100% !important;\r\n\r\n}\r\n\r\n\r\n/deep/split-gutter{\r\n  background-color:rgb(138, 168, 192) !important;\r\n}\r\n\r\n/deep/.mat-accent .mat-slider-thumb {\r\n    background-color: #8AA8C0 !important;\r\n    cursor: -webkit-grab;\r\n}\r\n/deep/.mat-slider-thumb{\r\n  width: 5px !important;\r\n  right: -5px !important;\r\n}\r\n\r\n/deep/.mat-slider-track-fill{\r\n  background-color: #F0BFA0 !important;\r\n}\r\n\r\n/deep/.mat-slider-thumb-label-text {\r\n    color: #395d73 !important;\r\n    font-size: 12px !important;\r\n}\r\n/deep/.mat-slider-thumb-label{\r\n    height: 15px !important;\r\n    width: 15px !important;\r\n    top: -20px !important;\r\n    right: -7px !important;\r\n    background-color: white !important;\r\n    border: 1px solid #395d73 !important;\r\n}\r\n/deep/.mat-slider-track-background{\r\n  background-color: #D3D3D3 !important;\r\n}\r\n.mat-slider{\r\n    width: 150px !important;\r\n}*/\r\n\r\n.cesium-button {\r\n  display: inline-block;\r\n  position: relative;\r\n  border: 1px solid #8AA8C0;\r\n  color: #D3D3D3;\r\n  fill: #8AA8C0;\r\n  border-radius: 0px;\r\n  padding: 3px 0px;\r\n  margin: 0px 0px;\r\n  cursor: pointer;\r\n  overflow: hidden;\r\n  -moz-user-select: none;\r\n  -webkit-user-select: none;\r\n  -ms-user-select: none;\r\n  user-select: none;\r\n  width: 80px;\r\n  font-family:sans-serif !important;\r\n  background: transparent;\r\n}\r\n\r\n.cesium-button-select{\r\n  display: inline-block;\r\n  position: relative;\r\n  border: 1px solid #8AA8C0;\r\n  fill: #8AA8C0;\r\n  border-radius: 0px;\r\n  padding: 3px 0px;\r\n  margin: 0px 0px;\r\n  cursor: pointer;\r\n  overflow: hidden;\r\n  -moz-user-select: none;\r\n  -webkit-user-select: none;\r\n  -ms-user-select: none;\r\n  user-select: none;\r\n  width: 80px;\r\n  font-family:sans-serif !important;\r\n  color: #D3D3D3;\r\n  background: transparent;\r\n}\r\n\r\n.cesium-option{\r\n  background-color: #F1F1F1;\r\n  /*opacity: 0.8;*/\r\n  color: #8AA8C0;\r\n  border: 1px solid #8AA8C0;\r\n}\r\n\r\nhr {\r\n  display: block;\r\n  height: 1px;\r\n  border: 0;\r\n  border-top: 1px solid #D3D3D3 !important;\r\n  padding: 0; \r\n  color:#D3D3D3 !important;\r\n  width: 100%;\r\n  background-color: #D3D3D3 !important;\r\n}\r\n\r\n"

/***/ }),

/***/ "./src/app/mViewer/viewers/mobius-cesium/setting/display.copmponent.html":
/*!*******************************************************************************!*\
  !*** ./src/app/mViewer/viewers/mobius-cesium/setting/display.copmponent.html ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<div id=\"DisplayView\"  style=\"background-color: rgba(20,20,20,0.9);height: 100%;overflow-y:overlay;\"  >\r\n\t<table>\r\n      <tr>\r\n      <th class=\"colorkey\" style=\"width: 80px\"><div class=\"Hide\" style=\"width: 80px;color:#D3D3D3 !important;border:0;text-align: left;font-weight: normal;\">Imagery</div></th>\r\n      <th><div>\r\n        <select class=\"cesium-button\" (change)=\"onChangeImagery($event.target.value)\" [ngModel]=\"_Imagery\">\r\n          <option class=\"cesium-option\"  *ngFor=\"let Imagery of _ImageryList\" value={{Imagery}}>{{Imagery}}</option>\r\n        </select>\r\n      </div></th>\r\n      </tr>\r\n    </table>\r\n    <hr>\r\n    <table>\r\n      <tr ><th style=\"width:80px;height: 25px;\"><div style=\"width: 80px;color:#D3D3D3 !important;font-weight: normal;text-align: left;border:0;\">Sun</div></th>\r\n      <th style=\"width:80px;height: 25px;\"><div style=\"width:80px;color:#D3D3D3 !important;font-weight: normal;text-align: left;border:0;\"><input type=\"checkbox\" [checked]=\"_Sun\" (click)=\"changeSun()\"></div></th></tr>\r\n    </table>\r\n    <table>\r\n      <tr ><th style=\"width:80px;height: 25px;\"><div style=\"width: 80px;color:#D3D3D3 !important;font-weight: normal;text-align: left;border:0;\">Shadows</div></th>\r\n      <th style=\"width:80px;height: 25px;\"><div style=\"width:80px;color:#D3D3D3 !important;font-weight: normal;text-align: left;border:0;\"><input type=\"checkbox\" [checked]=\"_Shadow\" (click)=\"changeShadow()\"></div></th></tr>\r\n    </table>\r\n    <table>\r\n      <tr ><th style=\"width:80px;height: 25px;\"><div style=\"width: 80px;color:#D3D3D3 !important;font-weight: normal;text-align: left;border:0;\">Date</div></th>\r\n      <th style=\"width:80px;height: 18px;\"><input type=\"text\"  value={{_Date}} style=\"width:80px;height: 18px;background:transparent;color:#D3D3D3;border:1px solid #8AA8C0;font-weight: normal;text-align: left\" (change)=\"changeDate($event.target.value,_UTC)\"></th></tr>  \r\n    </table>\r\n    <table>\r\n      <tr ><th style=\"width:80px;height: 25px;\"><div style=\"width: 80px;color:#D3D3D3 !important;font-weight: normal;text-align: left;border:0;\">UTC</div></th>\r\n      <th style=\"width:80px;height: 18px;\"><input type=\"text\"  value={{_UTC}} style=\"width:80px;height: 18px;background:transparent;color:#D3D3D3;border:1px solid #8AA8C0;font-weight: normal;text-align: left\" (change)=\"changeDate(_Date,$event.target.value)\"></th></tr>  \r\n    </table>\r\n    \r\n</div>\r\n  "

/***/ }),

/***/ "./src/app/mViewer/viewers/mobius-cesium/setting/display.copmponent.ts":
/*!*****************************************************************************!*\
  !*** ./src/app/mViewer/viewers/mobius-cesium/setting/display.copmponent.ts ***!
  \*****************************************************************************/
/*! exports provided: DisplayComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DisplayComponent", function() { return DisplayComponent; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var _data_DataSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../data/DataSubscriber */ "./src/app/mViewer/viewers/mobius-cesium/data/DataSubscriber.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __values = (undefined && undefined.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};


var DisplayComponent = /** @class */ (function (_super) {
    __extends(DisplayComponent, _super);
    function DisplayComponent(injector, myElement) {
        return _super.call(this, injector) || this;
    }
    DisplayComponent.prototype.ngOnInit = function () {
        this.data = this.dataService.getGsModel();
        this._ImageryList = ["Disable", "Stamen Toner", "Stamen Toner(Lite)", "Terrain(Standard)", "Terrain(Background)",
            "OpenStreetMap", "Earth at Night", "Natural Earth\u00a0II", "Blue Marble"];
        if (this._Imagery === undefined) {
            this._Imagery = this._ImageryList[3];
            this.onChangeImagery(this._Imagery);
        }
        else {
            this._Imagery = this.dataService.get_Imagery();
        }
        if (this._Sun === undefined) {
            this._Sun = false;
            this.dataService.set_Sun(this._Sun);
        }
        else {
            this._Sun = this.dataService.get_Sun();
        }
        if (this._Shadow === undefined) {
            this._Shadow = false;
            this.dataService.set_Shadow(this._Shadow);
        }
        else {
            this._Shadow = this.dataService.get_Shadow();
        }
        this._UTC = +8;
        this.dataService.set_UTC(this._UTC);
        if (this._Date === undefined) {
            var today = new Date();
            var year = today.getFullYear();
            var month = String(today.getMonth() + 1).padStart(2, "0");
            var day = String(today.getDate()).padStart(2, "0");
            this._Date = year + "-" + month + "-" + day;
        }
        else {
            this._Date = this.dataService.get_Date();
            this.changeDate(this._Date, this._UTC);
        }
        this.dataService.set_Date(this._Date);
    };
    DisplayComponent.prototype.notify = function (message) {
    };
    //chanage imagery in Display tab
    DisplayComponent.prototype.onChangeImagery = function (_Imagery) {
        this._Imagery = _Imagery;
        this.dataService.set_Imagery(_Imagery);
        var layers = this.dataService.getViewer().scene.imageryLayers;
        if (_Imagery === this._ImageryList[0]) {
            layers.removeAll();
            this.dataService.getViewer().scene.globe.baseColor = Cesium.Color.GRAY;
        }
        else if (_Imagery === this._ImageryList[1]) {
            layers.removeAll();
            var blackMarble = layers.addImageryProvider(Cesium.createOpenStreetMapImageryProvider({
                url: "https://stamen-tiles.a.ssl.fastly.net/toner/"
            }));
        }
        else if (_Imagery === this._ImageryList[2]) {
            layers.removeAll();
            var blackMarble = layers.addImageryProvider(Cesium.createOpenStreetMapImageryProvider({
                url: "https://stamen-tiles.a.ssl.fastly.net/toner-lite/"
            }));
        }
        else if (_Imagery === this._ImageryList[3]) {
            layers.removeAll();
            var blackMarble = layers.addImageryProvider(Cesium.createOpenStreetMapImageryProvider({
                url: "https://stamen-tiles.a.ssl.fastly.net/terrain/"
            }));
        }
        else if (_Imagery === this._ImageryList[4]) {
            layers.removeAll();
            var blackMarble = layers.addImageryProvider(Cesium.createOpenStreetMapImageryProvider({
                url: "https://stamen-tiles.a.ssl.fastly.net/terrain-background/"
            }));
        }
        else if (_Imagery === this._ImageryList[5]) {
            layers.removeAll();
            var blackMarble = layers.addImageryProvider(Cesium.createOpenStreetMapImageryProvider({
                url: "https://a.tile.openstreetmap.org/"
            }));
        }
        else if (_Imagery === this._ImageryList[6]) {
            layers.removeAll();
            var blackMarble = layers.addImageryProvider(new Cesium.IonImageryProvider({ assetId: 3812 }));
        }
        else if (_Imagery === this._ImageryList[7]) {
            layers.removeAll();
            var blackMarble = layers.addImageryProvider(Cesium.createTileMapServiceImageryProvider({
                url: Cesium.buildModuleUrl("Assets/Textures/NaturalEarthII"),
            }));
        }
        else if (_Imagery === this._ImageryList[8]) {
            layers.removeAll();
            var blackMarble = layers.addImageryProvider(new Cesium.IonImageryProvider({ assetId: 3845 }));
        }
    };
    //change sun
    DisplayComponent.prototype.changeSun = function () {
        var viewer = this.dataService.getViewer();
        this._Sun = !this._Sun;
        if (this._Sun === true) {
            viewer.terrainShadows = Cesium.ShadowMode.ENABLED;
            viewer.scene.globe.enableLighting = true;
            viewer.scene.sun.show = true;
        }
        else {
            viewer.terrainShadows = undefined;
            viewer.scene.globe.enableLighting = false;
            viewer.scene.sun.show = false;
        }
        this.dataService.set_Sun(this._Sun);
    };
    //change shadow
    DisplayComponent.prototype.changeShadow = function () {
        this._Shadow = !this._Shadow;
        var promise = this.dataService.getcesiumpromise();
        if (this._Shadow === true) {
            promise.then(function (dataSource) {
                var e_1, _a;
                var entities = dataSource.entities.values;
                try {
                    for (var entities_1 = __values(entities), entities_1_1 = entities_1.next(); !entities_1_1.done; entities_1_1 = entities_1.next()) {
                        var entity = entities_1_1.value;
                        entity.polygon.shadows = Cesium.ShadowMode.ENABLED;
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (entities_1_1 && !entities_1_1.done && (_a = entities_1.return)) _a.call(entities_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            });
        }
        else {
            promise.then(function (dataSource) {
                var e_2, _a;
                var entities = dataSource.entities.values;
                try {
                    for (var entities_2 = __values(entities), entities_2_1 = entities_2.next(); !entities_2_1.done; entities_2_1 = entities_2.next()) {
                        var entity = entities_2_1.value;
                        entity.polygon.shadows = undefined;
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (entities_2_1 && !entities_2_1.done && (_a = entities_2.return)) _a.call(entities_2);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            });
        }
        this.dataService.set_Shadow(this._Shadow);
    };
    //change date
    DisplayComponent.prototype.changeDate = function (_Date, _UTC) {
        this._Date = _Date;
        this._UTC = _UTC;
        var viewer = this.dataService.getViewer();
        var now = new Cesium.JulianDate.fromIso8601(this._Date);
        var tomorrow = now.clone();
        tomorrow.dayNumber = tomorrow.dayNumber + 1;
        viewer.clock.currentTime = Cesium.JulianDate.addHours(now, this._UTC, now);
        viewer.clock.startTime = now.clone();
        viewer.clock.stopTime = tomorrow.clone();
        viewer.timeline.zoomTo(viewer.clock.startTime, viewer.clock.stopTime);
        this.dataService.set_Date(this._Date);
        this.dataService.set_UTC(this._UTC);
        viewer.timeline.updateFromClock();
    };
    DisplayComponent = __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"])({
            selector: "app-display",
            template: __webpack_require__(/*! ./display.copmponent.html */ "./src/app/mViewer/viewers/mobius-cesium/setting/display.copmponent.html"),
            styles: [__webpack_require__(/*! ./display.copmponent.css */ "./src/app/mViewer/viewers/mobius-cesium/setting/display.copmponent.css")],
        }),
        __metadata("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_0__["Injector"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"]])
    ], DisplayComponent);
    return DisplayComponent;
}(_data_DataSubscriber__WEBPACK_IMPORTED_MODULE_1__["DataSubscriber"]));



/***/ }),

/***/ "./src/app/mViewer/viewers/mobius-cesium/setting/publish.component.css":
/*!*****************************************************************************!*\
  !*** ./src/app/mViewer/viewers/mobius-cesium/setting/publish.component.css ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#publishwindow{\r\n  position: relative;\r\n  height: 100%;\r\n  width: 100%;\r\n  color:#D3D3D3 !important;\r\n  font-family: Roboto,\"Helvetica Neue\",sans-serif;\r\n  font-size: 14px !important;\r\n  line-height: 16px;\r\n  overflow-x: hidden !important;\r\n}\r\n\r\n/deep/split-gutter{\r\n  background-color:rgb(138, 168, 192) !important;\r\n}\r\n\r\n/deep/.mat-accent .mat-slider-thumb {\r\n    background-color: #8AA8C0 !important;\r\n    cursor: -webkit-grab;\r\n    padding: 0px;\r\n    height: 24px;\r\n    /*min-width: 50px;*/\r\n    flex-grow: 1;\r\n    touch-action: none;\r\n    -webkit-user-select: none;\r\n       -moz-user-select: none;\r\n        -ms-user-select: none;\r\n            user-select: none;\r\n    -webkit-user-drag: none;\r\n    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\r\n}\r\n\r\n/deep/.mat-slider-thumb{\r\n  width: 5px !important;\r\n  right: -5px !important;\r\n}\r\n\r\n/deep/.mat-slider-track-fill{\r\n  background-color: #F0BFA0 !important;\r\n}\r\n\r\n/deep/.mat-slider-thumb-label-text {\r\n    color: #395d73 !important;\r\n    font-size: 12px !important;\r\n}\r\n\r\n/deep/.mat-slider-thumb-label{\r\n    height: 15px !important;\r\n    width: 15px !important;\r\n    top: -20px !important;\r\n    right: -7px !important;\r\n    background-color: white !important;\r\n    border: 1px solid #395d73 !important;\r\n}\r\n\r\n/deep/.mat-slider-track-background{\r\n  background-color: #D3D3D3 !important;\r\n}\r\n\r\n.mat-slider{\r\n    width: 100%;\r\n    display: inline-block;\r\n    position: relative;\r\n    box-sizing: border-box;\r\n    outline: 0;\r\n    vertical-align: middle;\r\n}\r\n\r\n.cesium-button {\r\n  display: inline-block;\r\n  position: relative;\r\n  border: 1px solid #8AA8C0;\r\n  color: #D3D3D3;\r\n  fill: #8AA8C0;\r\n  border-radius: 0px;\r\n  padding: 3px 0px;\r\n  margin: 0px 0px;\r\n  cursor: pointer;\r\n  overflow: hidden;\r\n  -moz-user-select: none;\r\n  -webkit-user-select: none;\r\n  -ms-user-select: none;\r\n  user-select: none;\r\n  width: 80px;\r\n  font-family:sans-serif !important;\r\n  background: transparent;\r\n}\r\n\r\n.cesium-button-select{\r\n  display: inline-block;\r\n  position: relative;\r\n  border: 1px solid #8AA8C0;\r\n  fill: #8AA8C0;\r\n  border-radius: 0px;\r\n  padding: 3px 0px;\r\n  margin: 0px 0px;\r\n  cursor: pointer;\r\n  overflow: hidden;\r\n  -moz-user-select: none;\r\n  -webkit-user-select: none;\r\n  -ms-user-select: none;\r\n  user-select: none;\r\n  width: 80px;\r\n  font-family:sans-serif !important;\r\n  color: #D3D3D3;\r\n  background: transparent;\r\n}\r\n\r\n.cesium-option{\r\n  background-color: #F1F1F1;\r\n  /*opacity: 0.8;*/\r\n  color: #8AA8C0;\r\n  border: 1px solid #8AA8C0;\r\n}\r\n\r\nhr {\r\n  display: block;\r\n  height: 1px;\r\n  border: 0;\r\n  border-top: 1px solid #D3D3D3 !important;\r\n  padding: 0; \r\n  color:#D3D3D3 !important;\r\n  width: 100%;\r\n  background-color: #D3D3D3 !important;\r\n}\r\n"

/***/ }),

/***/ "./src/app/mViewer/viewers/mobius-cesium/setting/publish.component.html":
/*!******************************************************************************!*\
  !*** ./src/app/mViewer/viewers/mobius-cesium/setting/publish.component.html ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<div id=\"publish\" style=\"background-color: rgba(20,20,20,0.9);height: 100%;overflow-y:overlay;\"  >\r\n\r\n<div id=\"publishwindow\" *ngIf=\"dataArr!==undefined\">\r\n        <div *ngIf=\"_ColorKey!==undefined\">\r\n        <table >\r\n          <tr>\r\n          <th class=\"colorkey\" style=\"width: 280px\" *ngIf=\"_ColorDescr!==undefined\"><div style=\"color:#D3D3D3 !important;border:0;text-align: left;font-weight: normal;font-size:14px;line-height:16px;\">{{_ColorDescr}}</div></th></tr>\r\n        </table>\r\n        <table>\r\n          <tr>\r\n            <th class=\"colorkey\" style=\"width: 80px\"><div class=\"Hide\" style=\"width: 80px;color:#D3D3D3 !important;border:0;text-align: left;font-weight: normal;\">Color&nbsp;&nbsp;:</div></th>\r\n          <th><div>\r\n            <select class=\"cesium-button\" (change)=\"onChangeColor($event.target.value)\" [ngModel]=\"_ColorKey\">\r\n              <option class=\"cesium-option\"  *ngFor=\"let ColorName of _ColorProperty\" value={{ColorName}}>{{ColorName}}</option>\r\n            </select>\r\n          </div></th>\r\n          </tr>\r\n          </table>\r\n    </div>\r\n    <div *ngIf=\"_ExtrudeKey!==undefined\">\r\n        <hr>\r\n          <table >\r\n          <tr>\r\n          <th class=\"colorkey\" style=\"width: 280px\" *ngIf=\"_ExtrudeDescr!==undefined\"><div style=\"color:#D3D3D3 !important;border:0;text-align: left;font-weight: normal;font-size:14px;line-height:16px;\">{{_ExtrudeDescr}}</div></th></tr>\r\n        </table>\r\n        <table>\r\n          <tr>\r\n            <th class=\"colorkey\" style=\"width: 80px\"><div class=\"Hide\" style=\"width: 80px;color:#D3D3D3 !important;border:0;text-align: left;font-weight: normal;\">Extrude&nbsp;&nbsp;:</div></th>\r\n          <th><div>\r\n            <select class=\"cesium-button\" (change)=\"onChangeHeight($event.target.value)\" [ngModel]=\"_ExtrudeKey\">\r\n               <option class=\"cesium-option\"  *ngFor=\"let Height of _ExtrudeProperty\" value={{Height}}>{{Height}}</option>\r\n            </select>\r\n          </div></th>\r\n          </tr>\r\n        </table>\r\n        <table>\r\n          <tr ><th style=\"width:40px;height: 25px;\"><div style=\"width: 40px;color:#D3D3D3 !important;font-weight: normal;text-align: left;border:0;\">Min&nbsp;&nbsp;:</div></th>\r\n          <th style=\"width:40px;\"><div style=\"width: 40px;color:#D3D3D3 !important;font-weight: normal;text-align: left;border:0;\" *ngIf=\"_ExtrudeMin!==undefined\">{{_ExtrudeMin}}</div></th></tr>\r\n\r\n          <tr><th style=\"width:40px;\"><div style=\"width: 40px;color:#D3D3D3 !important;font-weight: normal;text-align: left;border:0;\">Max&nbsp;&nbsp;:</div></th>\r\n          <th style=\"width:60px;\"><div style=\"width: 60px;color:#D3D3D3 !important;font-weight: normal;text-align: left;border:0;\" *ngIf=\"_ExtrudeMax!==undefined\">{{_ExtrudeMax}}</div></th></tr>\r\n      </table>\r\n    </div>\r\n    <div *ngIf=\"_Filter!==undefined\">\r\n      <hr>\r\n      <div class=\"hide-container\" style=\"margin-top:5px;\">\r\n        <div *ngFor=\"let item of _Filter;\" id={{item.divid}}>\r\n      <table>\r\n        <tr >\r\n          <th style=\"width:280px;height: 25px;\"><div style=\"color:#D3D3D3 !important;text-align: left;vertical-align: middle;font-weight: normal;font-size:14px;line-height:16px;\">{{item.descr}}</div></th></tr>\r\n        </table>\r\n        <table>\r\n          <tr>\r\n            <th style=\"max-width: 80px;height: 25px;\"><div matTooltip={{item.HeightHide}} style=\"max-width: 80px;color:#D3D3D3 !important;text-align: left;vertical-align: middle;font-weight: normal;white-space: nowrap;display:block;overflow: hidden !important;text-overflow: ellipsis !important;cursor:pointer;\">{{item.HeightHide}}</div></th>\r\n        <th *ngIf=\"item.type === 'number'\" style=\"width:20px;height: 25px;\">\r\n          <div style=\"width:20px;height: 25px;color:#D3D3D3 !important;vertical-align: middle;font-weight: normal;margin-top: 10px;\" *ngIf=\"item.RelaHide === 0\">></div>\r\n          <div style=\"width:20px;height: 25px;color:#D3D3D3 !important;vertical-align: middle;font-weight: normal;margin-top: 10px;\" *ngIf=\"item.RelaHide === 1\"><</div>\r\n          <div style=\"width:20px;height: 25px;color:#D3D3D3 !important;vertical-align: middle;font-weight: normal;margin-top: 10px;\" *ngIf=\"item.RelaHide === 2\">=</div></th>\r\n          <th *ngIf=\"item.type === 'category'\" style=\"width:30px;height: 25px;\">\r\n          <div style=\"width:20px;height: 25px;color:#D3D3D3 !important;vertical-align: middle;font-weight: normal;margin-top: 10px;\" *ngIf=\"item.RelaHide === 0\">none</div>\r\n          <div style=\"width:20px;height: 25px;color:#D3D3D3 !important;vertical-align: middle;font-weight: normal;margin-top: 10px;\" *ngIf=\"item.RelaHide === 1\">=</div>\r\n          <div style=\"width:20px;height: 25px;color:#D3D3D3 !important;vertical-align: middle;font-weight: normal;margin-top: 10px;\" *ngIf=\"item.RelaHide === 2\">!=</div></th>\r\n          <th *ngIf=\"item.type === 'number'\" style=\"width:80px;color:#395D73 !important;\"><input type=\"text\" id={{item.id}} value={{item.textHide}} (change)=\"Changetext($event.target.value,item.id)\" style=\"width:80px;background:transparent;color:#D3D3D3;border:1px solid #8AA8C0;\"></th>\r\n          <th *ngIf=\"item.type === 'category'\" style=\"width:73px;height: 25px;\"><div style=\"width:73px;height: 25px;\">\r\n          <select class=\"cesium-button-select\" [ngModel]=\"item.CategaryHide\" (change)=\"ChangeCategory($event.target.value,item.id,1)\" style=\"width:73px;height: 25px;\">\r\n            <option class=\"cesium-option\" *ngFor=\"let caty of item.Category\" value={{caty}}>{{caty}}</option>\r\n          </select></div></th>\r\n        <th style=\"width:20px;height: 22px;\" id={{item.id}}><input type=\"checkbox\" id={{item.id}} checked=\"checked\" (click)=\"Disable(item.id)\" style=\"width:20px;height: 22px;cursor:pointer;\"></th></tr>\r\n      </table>\r\n      <table>\r\n        <tr>\r\n        <th *ngIf=\"item.type === 'number'\" style=\"max-width: 30px;height: 25px;vertical-align: top;padding-top: 10px;\"><div style=\"font-weight: normal;display: inline-block;color:#D3D3D3 !important;text-align: left;max-width: 30px;\">{{item.HideMin}}</div></th>\r\n        <th *ngIf=\"item.type === 'number'\" style=\"width:200px;height: 25px;\"><div style=\"font-weight: normal;display: inline-block;width:200px;\"><mat-slider class=\"slider\" name=\"range\" id=\"0\" min={{item.HideMin}} max={{item.HideMax}} step=0.01 thumbLabel=true value={{item.textHide}} #textscale (change)=\"Changetext(textscale.value.toPrecision(2),item.id)\" >\r\n        </mat-slider></div></th>\r\n        <th *ngIf=\"item.type === 'number'\" style=\"max-width: 30px;height: 25px;vertical-align: top;padding-top: 10px;\"><div style=\"font-weight: normal;display: inline-block;color:#D3D3D3 !important;max-width: 30px;text-align: left;\">{{item.HideMax}}</div></th></tr>\r\n      </table><hr>\r\n        </div>\r\n      </div>\r\n      <div>\r\n      <button style=\"color:#D3D3D3;border:2px solid #8AA8C0;background-color: transparent;cursor:pointer;\" (click)=\"reset()\">Reset</button></div>\r\n      </div>\r\n</div>\r\n\r\n  "

/***/ }),

/***/ "./src/app/mViewer/viewers/mobius-cesium/setting/publish.component.ts":
/*!****************************************************************************!*\
  !*** ./src/app/mViewer/viewers/mobius-cesium/setting/publish.component.ts ***!
  \****************************************************************************/
/*! exports provided: PublishComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PublishComponent", function() { return PublishComponent; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var _data_DataSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../data/DataSubscriber */ "./src/app/mViewer/viewers/mobius-cesium/data/DataSubscriber.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __values = (undefined && undefined.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};


var PublishComponent = /** @class */ (function (_super) {
    __extends(PublishComponent, _super);
    function PublishComponent(injector, myElement) {
        var _this = _super.call(this, injector) || this;
        _this._CheckDisable = false;
        return _this;
    }
    PublishComponent.prototype.ngOnInit = function () {
        this.mode = this.dataService.getmode();
        this.dataArr = this.dataService.get_PuData();
        if (this.dataArr !== undefined) {
            this.LoadData();
        }
    };
    PublishComponent.prototype.notify = function (message) {
        if (message === "model_update") {
            try {
                this.dataArr = this.dataService.get_PuData();
                if (this.dataArr !== undefined) {
                    this.LoadData();
                }
            }
            catch (ex) {
                console.log(ex);
            }
        }
    };
    //load data in publish version
    PublishComponent.prototype.LoadData = function () {
        this._ColorDescr = this.dataArr["ColorDescr"];
        this._ColorProperty = this.dataArr["ColorProperty"];
        this._ColorKey = this.dataArr["ColorKey"];
        this._ColorMax = this.dataArr["ColorMax"];
        this._ColorMin = this.dataArr["ColorMin"];
        this._ColorInvert = this.dataArr["ColorInvert"];
        this._ExtrudeDescr = this.dataArr["ExtrudeDescr"];
        this._ExtrudeProperty = this.dataArr["ExtrudeProperty"];
        this._ExtrudeKey = this.dataArr["ExtrudeKey"];
        this._ExtrudeMax = this.dataArr["ExtrudeMax"];
        this._ExtrudeMin = this.dataArr["ExtrudeMin"];
        this._HeightChart = this.dataArr["HeightChart"];
        this._Invert = this.dataArr["Invert"];
        this._Scale = this.dataArr["Scale"];
        this._HideNum = this.dataArr["HideNum"];
        this._Filter = this.dataArr["Filter"];
    };
    //disable button in publish version
    PublishComponent.prototype.Disable = function (event) {
        var index = this._HideNum.indexOf(event);
        var divid = String("addHide".concat(String(event)));
        var addHide = document.getElementById(divid);
        if (this._Filter[index].Disabletext === null) {
            this._CheckDisable = false;
        }
        else {
            this._CheckDisable = true;
        }
        if (this._CheckDisable === false) {
            if (this._Filter[index].type === "number") {
                var textHide = this._Filter[index].textHide;
                this._Filter[index].Disabletext = Number(textHide);
                if (this._Filter[index].RelaHide === "0" || this._Filter[index].RelaHide === 0) {
                    this._Filter[index].textHide = this._Filter[index].HideMin;
                }
                if (this._Filter[index].RelaHide === "1" || this._Filter[index].RelaHide === 1) {
                    this._Filter[index].textHide = this._Filter[index].HideMax;
                }
            }
            else if (this._Filter[index].type === "category") {
                var textHide = this._Filter[index].RelaHide;
                this._Filter[index].Disabletext = Number(textHide);
                this._Filter[index].RelaHide = 0;
            }
        }
        else {
            if (this._Filter[index].type === "number") {
                this._Filter[index].textHide = this._Filter[index].Disabletext;
                this._Filter[index].Disabletext = null;
            }
            else if (this._Filter[index].type === "category") {
                this._Filter[index].RelaHide = this._Filter[index].Disabletext;
                this._Filter[index].Disabletext = null;
            }
        }
        this.dataArr["Filter"] = this._Filter;
        this.dataArr["HideNum"] = this._HideNum;
        this.dataService.set_PuData(this.dataArr);
    };
    //change category in filter
    PublishComponent.prototype.ChangeCategory = function (categary, id, type) {
        var _index = this._HideNum.indexOf(id);
        if (type === 1) {
            this._Filter[_index].CategaryHide = categary;
        }
        if (type === 0) {
            this._Filter[_index].RelaHide = Number(categary);
        }
    };
    //change text in filter
    PublishComponent.prototype.Changetext = function (value, id) {
        var _index = this._HideNum.indexOf(id);
        this._Filter[_index].textHide = value;
    };
    //change color property in publish version
    PublishComponent.prototype.onChangeColor = function (value) {
        var e_1, _a;
        var data = this.dataService.getGsModel()["cesium"]["colour"]["attribs"];
        this.dataArr["ColorKey"] = value;
        try {
            for (var data_1 = __values(data), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
                var _data = data_1_1.value;
                if (_data["name"] === value) {
                    this.dataArr["ColorMin"] = _data["min"];
                    this.dataArr["ColorMax"] = _data["max"];
                    this.dataArr["ColorInvert"] = _data["invert"];
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (data_1_1 && !data_1_1.done && (_a = data_1.return)) _a.call(data_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        var promise = this.dataService.getcesiumpromise();
        var _Colortexts = [];
        var self = this;
        promise.then(function (dataSource) {
            var e_2, _a;
            var entities = dataSource.entities.values;
            try {
                for (var entities_1 = __values(entities), entities_1_1 = entities_1.next(); !entities_1_1.done; entities_1_1 = entities_1.next()) {
                    var entity = entities_1_1.value;
                    if (entity.properties[value] !== undefined) {
                        if (entity.properties[value]._value !== " ") {
                            if (_Colortexts.length === 0) {
                                _Colortexts[0] = entity.properties[value]._value;
                            }
                            else {
                                if (_Colortexts.indexOf(entity.properties[value]._value) === -1) {
                                    _Colortexts.push(entity.properties[value]._value);
                                }
                            }
                        }
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (entities_1_1 && !entities_1_1.done && (_a = entities_1.return)) _a.call(entities_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
        this.dataArr["ColorText"] = _Colortexts.sort();
        this.dataService.set_PuData(this.dataArr);
        this.LoadData();
    };
    //change extrudeheight property in publish version
    PublishComponent.prototype.onChangeHeight = function (value) {
        var e_3, _a;
        var data = this.dataService.getGsModel()["cesium"]["extrude"]["attribs"];
        this.dataArr["ExtrudeKey"] = value;
        try {
            for (var data_2 = __values(data), data_2_1 = data_2.next(); !data_2_1.done; data_2_1 = data_2.next()) {
                var _data = data_2_1.value;
                if (_data["name"] === value) {
                    this.dataArr["ExtrudeMin"] = _data["min"];
                    this.dataArr["ExtrudeMax"] = _data["max"];
                    this.dataArr["HeightChart"] = _data["line"];
                    this.dataArr["Invert"] = _data["invert"];
                    this.dataArr["Scale"] = _data["scale"];
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (data_2_1 && !data_2_1.done && (_a = data_2.return)) _a.call(data_2);
            }
            finally { if (e_3) throw e_3.error; }
        }
        var promise = this.dataService.getcesiumpromise();
        var _Heighttexts = [];
        var self = this;
        promise.then(function (dataSource) {
            var e_4, _a;
            var entities = dataSource.entities.values;
            try {
                for (var entities_2 = __values(entities), entities_2_1 = entities_2.next(); !entities_2_1.done; entities_2_1 = entities_2.next()) {
                    var entity = entities_2_1.value;
                    if (entity.properties[value] !== undefined) {
                        if (entity.properties[value]._value !== " ") {
                            if (_Heighttexts.length === 0) {
                                _Heighttexts[0] = entity.properties[value]._value;
                            }
                            else {
                                if (_Heighttexts.indexOf(entity.properties[value]._value) === -1) {
                                    _Heighttexts.push(entity.properties[value]._value);
                                }
                            }
                        }
                    }
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (entities_2_1 && !entities_2_1.done && (_a = entities_2.return)) _a.call(entities_2);
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
        this.dataArr["ExtrudeText"] = _Heighttexts.sort();
        this.dataService.set_PuData(this.dataArr);
        this.LoadData();
    };
    //reset button to load again
    PublishComponent.prototype.reset = function () {
        this.dataService.LoadJSONData();
        this.dataArr = this.dataService.get_PuData();
        if (this.dataArr !== undefined) {
            this.LoadData();
        }
    };
    PublishComponent = __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"])({
            selector: "app-publish",
            template: __webpack_require__(/*! ./publish.component.html */ "./src/app/mViewer/viewers/mobius-cesium/setting/publish.component.html"),
            styles: [__webpack_require__(/*! ./publish.component.css */ "./src/app/mViewer/viewers/mobius-cesium/setting/publish.component.css")],
        }),
        __metadata("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_0__["Injector"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"]])
    ], PublishComponent);
    return PublishComponent;
}(_data_DataSubscriber__WEBPACK_IMPORTED_MODULE_1__["DataSubscriber"]));



/***/ }),

/***/ "./src/app/mViewer/viewers/mobius-cesium/setting/setting.component.css":
/*!*****************************************************************************!*\
  !*** ./src/app/mViewer/viewers/mobius-cesium/setting/setting.component.css ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#setting{\r\n  position: relative;\r\n  height: 100%;\r\n  width: 100%;\r\n  color:#D3D3D3 !important;\r\n  font-family: Roboto,\"Helvetica Neue\",sans-serif;\r\n  font-size: 14px !important;\r\n  line-height: 14px;\r\n  overflow-x: hidden !important;\r\n  border-right: 1px solid gray;\r\n}\r\n\r\n/deep/.mat-tab-label, /deep/.mat-tab-label-active{\r\n  min-width: 60px!important;\r\n  padding: 3px!important;\r\n  margin: 3px!important;\r\n  color:#D3D3D3 !important;\r\n  background-color: transparent !important;\r\n}\r\n\r\n/deep/.mat-tab-label{\r\n  height: 30px !important;\r\n  width: 60px !important;\r\n  background-color: transparent !important;\r\n}\r\n\r\n/deep/.mat-tab-labels{\r\n  background-color: rgba(20,20,20,0.9) !important;\r\n}\r\n\r\n/deep/.mat-tab-header{\r\n  width: 700px !important;\r\n}\r\n\r\n/deep/.mat-tab-header-pagination-controls-enabled{\r\n  display: none !important;\r\n}\r\n\r\n/deep/.mat-ink-bar{\r\n  background-color: #395d73 !important;\r\n}\r\n\r\n/deep/.mat-tab{\r\n  min-width: 30px !important;\r\n}\r\n\r\n/deep/.mat-tab-body-content{\r\n  overflow: hidden !important;\r\n}\r\n\r\n/deep/.mat-header{\r\n  flex-direction: row;\r\n  font-family: Roboto,\"Helvetica Neue\",sans-serif;\r\n  margin-left: 0px;\r\n  color:#395d73;\r\n  border: 0;\r\n  height: 20px;\r\n  background-color: rgba(20,20,20,0.9) !important;\r\n}\r\n\r\n/deep/.mat-tab-body-wrapper{\r\n  height:100% !important;\r\n\r\n}\r\n\r\n/deep/split-gutter{\r\n  background-color:rgb(138, 168, 192) !important;\r\n}\r\n\r\n/deep/.mat-accent .mat-slider-thumb {\r\n    background-color: #8AA8C0 !important;\r\n    cursor: -webkit-grab;\r\n}\r\n\r\n/deep/.mat-slider-thumb{\r\n  width: 5px !important;\r\n  right: -5px !important;\r\n}\r\n\r\n/deep/.mat-slider-track-fill{\r\n  background-color: #F0BFA0 !important;\r\n}\r\n\r\n/deep/.mat-slider-thumb-label-text {\r\n    color: #395d73 !important;\r\n    font-size: 12px !important;\r\n}\r\n\r\n/deep/.mat-slider-thumb-label{\r\n    height: 15px !important;\r\n    width: 15px !important;\r\n    top: -20px !important;\r\n    right: -7px !important;\r\n    background-color: white !important;\r\n    border: 1px solid #395d73 !important;\r\n}\r\n\r\n/deep/.mat-slider-track-background{\r\n  background-color: #D3D3D3 !important;\r\n}\r\n\r\n.mat-slider{\r\n    width: 150px !important;\r\n}\r\n"

/***/ }),

/***/ "./src/app/mViewer/viewers/mobius-cesium/setting/setting.component.html":
/*!******************************************************************************!*\
  !*** ./src/app/mViewer/viewers/mobius-cesium/setting/setting.component.html ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<div id=\"setting\" >\r\n  <mat-tab-group class=\"mat-tab-group\" style=\"height: 100%;\" (selectedTabChange)=\"changedata($event.index)\" *ngIf=\"mode==='editor'\" >\r\n    <mat-tab label=\"&nbsp;Select&nbsp;\">\r\n      <app-select></app-select>\r\n    </mat-tab>\r\n    <mat-tab label=\"&nbsp;Data&nbsp;\" >\r\n      <app-data (change)=\"LoadViewer()\" (click)=\"LoadViewer()\"></app-data>\r\n    </mat-tab>\r\n    <mat-tab label=\"&nbsp;Display&nbsp;\" >\r\n      <app-display></app-display>\r\n    </mat-tab>\r\n    <mat-tab label=\"&nbsp;Publish&nbsp;\" >\r\n      <app-publish  (change)=\"LoadViewer()\" (click)=\"Reset();LoadViewer();\"></app-publish>\r\n    </mat-tab>\r\n  </mat-tab-group>\r\n    <app-publish *ngIf=\"mode==='viewer'\" (change)=\"LoadViewer()\" (click)=\"Reset();LoadViewer();\"></app-publish>\r\n</div>"

/***/ }),

/***/ "./src/app/mViewer/viewers/mobius-cesium/setting/setting.component.ts":
/*!****************************************************************************!*\
  !*** ./src/app/mViewer/viewers/mobius-cesium/setting/setting.component.ts ***!
  \****************************************************************************/
/*! exports provided: SettingComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SettingComponent", function() { return SettingComponent; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var _data_DataSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../data/DataSubscriber */ "./src/app/mViewer/viewers/mobius-cesium/data/DataSubscriber.ts");
/* harmony import */ var chroma_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! chroma-js */ "./node_modules/chroma-js/chroma.js");
/* harmony import */ var chroma_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(chroma_js__WEBPACK_IMPORTED_MODULE_2__);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __values = (undefined && undefined.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};



var SettingComponent = /** @class */ (function (_super) {
    __extends(SettingComponent, _super);
    function SettingComponent(injector, myElement) {
        return _super.call(this, injector) || this;
    }
    //get data and mode
    SettingComponent.prototype.ngOnInit = function () {
        this.data = this.dataService.getGsModel();
        this.mode = this.dataService.getmode();
        if (this.mode === "viewer") {
            this.changedata(3);
        }
        else if (this.mode === "editor") {
            this.changedata(1);
        }
    };
    //change data and load new data
    SettingComponent.prototype.notify = function (message) {
        if (message === "model_update") {
            this.data = this.dataService.getGsModel();
            this.mode = this.dataService.getmode();
            try {
                if (this.data !== undefined && this.data["features"] !== undefined) {
                    if (this.mode === "viewer") {
                        this.changedata(3);
                    }
                    else if (this.mode === "editor") {
                        this.changedata(1);
                    }
                }
            }
            catch (ex) {
                console.log(ex);
            }
        }
    };
    //change index from editor version to publish version
    SettingComponent.prototype.changedata = function (id) {
        this.dataService.set_index(id);
        if (id === 1) {
            this.dataArr = this.dataService.get_ViData();
        }
        else if (id === 3) {
            this.dataArr = this.dataService.get_PuData();
        }
        if (this.dataArr !== undefined) {
            this.LoadViewer();
        }
    };
    //reset button to reset everthing in publish version
    SettingComponent.prototype.Reset = function () {
        this.dataArr = this.dataService.get_PuData();
    };
    //change color and extrudeHeight of entity
    SettingComponent.prototype.LoadViewer = function () {
        var promise = this.dataService.getcesiumpromise();
        var _ColorKey = this.dataArr["ColorKey"];
        var _ColorMax = this.dataArr["ColorMax"];
        var _ColorMin = this.dataArr["ColorMin"];
        var _ColorText = this.dataArr["ColorText"];
        var _ColorInvert = this.dataArr["ColorInvert"];
        var _ExtrudeKey = this.dataArr["ExtrudeKey"];
        var _ExtrudeMax = this.dataArr["ExtrudeMax"];
        var _ExtrudeMin = this.dataArr["ExtrudeMin"];
        var _HeightChart = this.dataArr["HeightChart"];
        var _Invert = this.dataArr["Invert"];
        var _Scale = this.dataArr["Scale"];
        var _indexArr = this.dataArr["indexArr"];
        var _Filter;
        if (this.dataArr["Filter"] !== undefined && this.dataArr["Filter"].length !== 0) {
            _Filter = this.dataArr["Filter"];
        }
        else {
            _Filter = [];
        }
        var _ChromaScale = chroma_js__WEBPACK_IMPORTED_MODULE_2__["scale"]("SPECTRAL");
        if (_ColorInvert === true) {
            _ChromaScale = chroma_js__WEBPACK_IMPORTED_MODULE_2__["scale"]("SPECTRAL").domain([1, 0]);
        }
        var self = this;
        promise.then(function (dataSource) {
            var e_1, _a;
            var entities = dataSource.entities.values;
            try {
                for (var _indexArr_1 = __values(_indexArr), _indexArr_1_1 = _indexArr_1.next(); !_indexArr_1_1.done; _indexArr_1_1 = _indexArr_1.next()) {
                    var i = _indexArr_1_1.value;
                    var entity = entities[i];
                    var _CheckHide = void 0;
                    if (entity.polygon !== undefined) {
                        if (_Filter.length !== 0) {
                            _CheckHide = self.Hide(_Filter, entity, _HeightChart);
                            if (_CheckHide === true) {
                                if (entity.polygon !== undefined) {
                                    entity.polygon.extrudedHeight = 0;
                                    entity.polygon.material = Cesium.Color.LIGHTSLATEGRAY.withAlpha(1);
                                    if (_HeightChart === true) {
                                        if (entity.polyline !== undefined) {
                                            entity.polyline.show = false;
                                        }
                                    }
                                }
                                if (entity.polyline !== undefined) {
                                    entity.polyline.material = Cesium.Color.LIGHTSLATEGRAY.withAlpha(1);
                                }
                            }
                        }
                        if (_Filter.length === 0 || _CheckHide === false) {
                            if (_ColorKey !== "None") {
                                if (typeof (_ColorText[0]) === "number") {
                                    self.colorByNum(entity, _ColorMax, _ColorMin, _ColorKey, _ChromaScale);
                                }
                                else {
                                    self.colorByCat(entity, _ColorText, _ColorKey, _ChromaScale);
                                }
                            }
                            else {
                                entity.polygon.material = Cesium.Color.DARKGREY;
                            }
                            if (_ExtrudeKey !== "None") {
                                if (_HeightChart === false) {
                                    entity.polyline = undefined;
                                    if (entity.properties[_ExtrudeKey] !== undefined) {
                                        entity.polygon.extrudedHeight = self.ExtrudeHeight(entity.properties[_ExtrudeKey]._value, _ExtrudeMax, _ExtrudeMin, _Invert) * _Scale;
                                    }
                                    else {
                                        entity.polygon.extrudedHeight = 0;
                                    }
                                }
                                else {
                                    entity.polygon.extrudedHeight = 0;
                                    var center = Cesium.BoundingSphere.fromPoints(entity.polygon.hierarchy.getValue().positions).center;
                                    var radius = Math.min(Math.round(Cesium.BoundingSphere.fromPoints(entity.polygon.hierarchy.getValue().positions).radius / 100), 10);
                                    var longitudeString = Cesium.Math.toDegrees(Cesium.Ellipsoid.WGS84.
                                        cartesianToCartographic(center).longitude).toFixed(10);
                                    var latitudeString = Cesium.Math.toDegrees(Cesium.Ellipsoid.WGS84.cartesianToCartographic(center).
                                        latitude).toFixed(10);
                                    entity.polyline = new Cesium.PolylineGraphics({
                                        positions: new Cesium.Cartesian3.fromDegreesArrayHeights([longitudeString, latitudeString, 0, longitudeString,
                                            latitudeString, self.ExtrudeHeight(entity.properties[_ExtrudeKey]._value, _ExtrudeMax, _ExtrudeMin, _Invert) * _Scale]),
                                        width: radius,
                                        material: entity.polygon.material,
                                        show: true,
                                    });
                                }
                            }
                            else {
                                entity.polyline = undefined;
                                entity.polygon.extrudedHeight = 0;
                            }
                        }
                    }
                    else if (entity.polyline !== undefined) {
                        if (_ColorKey !== "None") {
                            if (typeof (_ColorText[0]) === "number") {
                                self.colorByNum(entity, _ColorMax, _ColorMin, _ColorKey, _ChromaScale);
                            }
                            else {
                                self.colorByCat(entity, _ColorText, _ColorKey, _ChromaScale);
                            }
                        }
                        else {
                            entity.polyline.material = Cesium.Color.DARKGREY;
                        }
                    }
                    else if (entity.point !== undefined) {
                        if (_ColorKey !== "None") {
                            if (typeof (_ColorText[0]) === "number") {
                                self.colorByNum(entity, _ColorMax, _ColorMin, _ColorKey, _ChromaScale);
                            }
                            else {
                                self.colorByCat(entity, _ColorText, _ColorKey, _ChromaScale);
                            }
                        }
                        else {
                            entity.point.color = Cesium.Color.DARKGREY;
                        }
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_indexArr_1_1 && !_indexArr_1_1.done && (_a = _indexArr_1.return)) _a.call(_indexArr_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    };
    //check whether entity should be hided or not
    SettingComponent.prototype.Hide = function (_Filter, entity, _HeightChart) {
        var e_2, _a;
        var _CheckHide = false;
        try {
            for (var _Filter_1 = __values(_Filter), _Filter_1_1 = _Filter_1.next(); !_Filter_1_1.done; _Filter_1_1 = _Filter_1.next()) {
                var filter = _Filter_1_1.value;
                var value = entity.properties[filter.HeightHide]._value;
                if (value !== undefined) {
                    if (typeof (value) === "number") {
                        if (this._compare(value, Number(filter.textHide), Number(filter.RelaHide))) {
                            _CheckHide = true;
                        }
                    }
                    else if (typeof (value) === "string") {
                        if (this._compareCat(value, filter.CategaryHide, Number(filter.RelaHide))) {
                            _CheckHide = true;
                        }
                    }
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_Filter_1_1 && !_Filter_1_1.done && (_a = _Filter_1.return)) _a.call(_Filter_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return _CheckHide;
    };
    SettingComponent.prototype._compare = function (value, slider, relation) {
        switch (relation) {
            case 0:
                return value < slider;
            case 1:
                return value > slider;
            case 2:
                return value !== slider;
        }
    };
    SettingComponent.prototype._compareCat = function (value, _Categary, relation) {
        switch (relation) {
            case 0:
                return value === undefined;
            case 1:
                return value !== _Categary;
            case 2:
                return value === _Categary;
        }
    };
    //caculate the extrudeHeight of entity
    SettingComponent.prototype.ExtrudeHeight = function (value, _ExtrudeMax, _ExtrudeMin, _Invert) {
        var diff;
        if (_ExtrudeMin < 0) {
            diff = Math.abs(_ExtrudeMin);
        }
        else {
            diff = 0;
        }
        if (value > _ExtrudeMax) {
            value = _ExtrudeMax;
        }
        if (value < _ExtrudeMin) {
            value = _ExtrudeMin;
        }
        switch (_Invert) {
            case true:
                return _ExtrudeMax - value;
            case false:
                return value;
        }
    };
    SettingComponent.prototype.colorByNum = function (entity, max, min, _ColorKey, _ChromaScale) {
        if (entity.properties[_ColorKey] !== undefined) {
            var texts = entity.properties[_ColorKey]._value;
            var rgb = _ChromaScale(Number(((max - texts) / (max - min)).toFixed(2)))._rgb;
            if (entity.polygon !== undefined) {
                entity.polygon.material = Cesium.Color.fromBytes(rgb[0], rgb[1], rgb[2]);
            }
            if (entity.polyline !== undefined) {
                var newColor = new Cesium.Color.fromBytes(rgb[0], rgb[1], rgb[2]);
                entity.polyline.material.color.setValue(newColor);
            }
            if (entity.point !== undefined) {
                var newColor = new Cesium.Color.fromBytes(rgb[0], rgb[1], rgb[2]);
                entity.point.color = newColor;
            }
        }
        else {
            if (entity.polygon !== undefined) {
                entity.polygon.material = Cesium.Color.LIGHTSLATEGRAY.withAlpha(1);
            }
            if (entity.polyline !== undefined) {
                entity.polyline.material = Cesium.Color.LIGHTSLATEGRAY.withAlpha(1);
            }
            if (entity.point !== undefined) {
                entity.point.color = Cesium.Color.LIGHTSLATEGRAY.withAlpha(1);
            }
        }
    };
    SettingComponent.prototype.colorByCat = function (entity, _ColorText, _ColorKey, _ChromaScale) {
        if (entity.properties[_ColorKey] !== undefined) {
            var initial = false;
            for (var j = 0; j < _ColorText.length; j++) {
                if (entity.properties[_ColorKey]._value === _ColorText[j]) {
                    var rgb = _ChromaScale(1 - (j / _ColorText.length));
                    if (entity.polygon !== undefined) {
                        entity.polygon.material = Cesium.Color.fromBytes(rgb._rgb[0], rgb._rgb[1], rgb._rgb[2]);
                    }
                    if (entity.polyline !== undefined) {
                        var newColor = new Cesium.Color.fromBytes(rgb[0], rgb[1], rgb[2]);
                        entity.polyline.material.color.setValue(newColor);
                    }
                    if (entity.point !== undefined) {
                        var newColor = new Cesium.Color.fromBytes(rgb[0], rgb[1], rgb[2]);
                        entity.point.color = newColor;
                    }
                    initial = true;
                }
            }
            if (initial === false) {
                if (entity.polygon !== undefined) {
                    entity.polygon.material = Cesium.Color.LIGHTSLATEGRAY.withAlpha(1);
                }
                if (entity.polyline !== undefined) {
                    entity.polyline.material = Cesium.Color.LIGHTSLATEGRAY.withAlpha(1);
                }
                if (entity.point !== undefined) {
                    entity.point.color = Cesium.Color.LIGHTSLATEGRAY.withAlpha(1);
                }
            }
        }
        else {
            if (entity.polygon !== undefined) {
                entity.polygon.material = Cesium.Color.LIGHTSLATEGRAY.withAlpha(1);
            }
            if (entity.polyline !== undefined) {
                entity.polyline.material = Cesium.Color.LIGHTSLATEGRAY.withAlpha(1);
            }
            if (entity.point !== undefined) {
                entity.point.color = Cesium.Color.LIGHTSLATEGRAY.withAlpha(1);
            }
        }
    };
    SettingComponent = __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"])({
            selector: "app-setting-cesium",
            template: __webpack_require__(/*! ./setting.component.html */ "./src/app/mViewer/viewers/mobius-cesium/setting/setting.component.html"),
            styles: [__webpack_require__(/*! ./setting.component.css */ "./src/app/mViewer/viewers/mobius-cesium/setting/setting.component.css")],
        }),
        __metadata("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_0__["Injector"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"]])
    ], SettingComponent);
    return SettingComponent;
}(_data_DataSubscriber__WEBPACK_IMPORTED_MODULE_1__["DataSubscriber"]));



/***/ }),

/***/ "./src/app/mViewer/viewers/mobius-cesium/setting/visualise.component.css":
/*!*******************************************************************************!*\
  !*** ./src/app/mViewer/viewers/mobius-cesium/setting/visualise.component.css ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#SettingView{\r\n  position: relative;\r\n  padding:0px;\r\n  height: 100%;\r\n  width: 100%;\r\n  color:#D3D3D3 !important;\r\n  font-family: Roboto,\"Helvetica Neue\",sans-serif;\r\n  font-size: 14px !important;\r\n  line-height: 14px;\r\n  overflow-x: hidden !important;\r\n  background-color: rgba(20,20,20,0.9);\r\n  overflow-y:overlay;\r\n}\r\n/deep/.mat-tab-label, /deep/.mat-tab-label-active{\r\n  min-width: 60px!important;\r\n  padding: 3px!important;\r\n  margin: 3px!important;\r\n  color:#D3D3D3 !important;\r\n  background-color: transparent !important;\r\n}\r\n/deep/.mat-tab-label{\r\n  height: 30px !important;\r\n  width: 60px !important;\r\n  background-color: transparent !important;\r\n}\r\n/deep/.mat-tab-labels{\r\n  background-color: rgba(20,20,20,0.9) !important;\r\n}\r\n/deep/.mat-tab-header{\r\n  width: 700px !important;\r\n}\r\n/deep/.mat-tab-header-pagination-controls-enabled{\r\n  display: none !important;\r\n}\r\n/deep/.mat-ink-bar{\r\n  background-color: #395d73 !important;\r\n}\r\n/deep/.mat-tab{\r\n  min-width: 30px !important;\r\n}\r\n/deep/.mat-tab-body-content{\r\n  overflow: hidden !important;\r\n}\r\n/deep/.mat-header{\r\n  flex-direction: row;\r\n  font-family: Roboto,\"Helvetica Neue\",sans-serif;\r\n  margin-left: 0px;\r\n  color:#395d73;\r\n  border: 0;\r\n  height: 20px;\r\n  background-color: rgba(20,20,20,0.9) !important;\r\n}\r\n/deep/.mat-tab-body-wrapper{\r\n  height:100% !important;\r\n\r\n}\r\n/deep/split-gutter{\r\n  background-color:rgb(138, 168, 192) !important;\r\n}\r\n/deep/.mat-accent .mat-slider-thumb {\r\n    background-color: #8AA8C0 !important;\r\n    cursor: -webkit-grab;\r\n}\r\n/deep/.mat-slider-thumb{\r\n  width: 5px !important;\r\n  right: -5px !important;\r\n}\r\n/deep/.mat-slider-track-fill{\r\n  background-color: #F0BFA0 !important;\r\n}\r\n/deep/.mat-slider-thumb-label-text {\r\n    color: #8AA8C0 !important;\r\n    font-size: 12px !important;\r\n}\r\n/deep/.mat-slider-thumb-label{\r\n    height: 15px !important;\r\n    width: 15px !important;\r\n    top: -20px !important;\r\n    right: -7px !important;\r\n    background-color: white !important;\r\n    border: 1px solid #8AA8C0 !important;\r\n}\r\n/deep/.mat-slider-track-background{\r\n  background-color: #D3D3D3 !important;\r\n}\r\n.mat-slider{\r\n    width: 150px !important;\r\n}\r\n.cesium-button {\r\n  display: inline-block;\r\n  position: relative;\r\n  border: 1px solid #8AA8C0;\r\n  color: #D3D3D3;\r\n  fill: #8AA8C0;\r\n  border-radius: 0px;\r\n  padding: 3px 0px;\r\n  margin: 0px 0px;\r\n  cursor: pointer;\r\n  overflow: hidden;\r\n  -moz-user-select: none;\r\n  -webkit-user-select: none;\r\n  -ms-user-select: none;\r\n  user-select: none;\r\n  width: 80px;\r\n  font-family:sans-serif !important;\r\n  background: transparent;\r\n}\r\n.cesium-button-select{\r\n  display: inline-block;\r\n  position: relative;\r\n  border: 1px solid #8AA8C0;\r\n  fill: #8AA8C0;\r\n  border-radius: 0px;\r\n  padding: 3px 0px;\r\n  margin: 0px 0px;\r\n  cursor: pointer;\r\n  overflow: hidden;\r\n  -moz-user-select: none;\r\n  -webkit-user-select: none;\r\n  -ms-user-select: none;\r\n  user-select: none;\r\n  width: 80px;\r\n  font-family:sans-serif !important;\r\n  color: #D3D3D3;\r\n  background: transparent;\r\n}\r\n.cesium-option{\r\n  background-color: #F1F1F1;\r\n  /*opacity: 0.8;*/\r\n  color: #8AA8C0;\r\n  border: 1px solid #8AA8C0;\r\n}\r\nhr {\r\n  display: block;\r\n  height: 1px;\r\n  border: 0;\r\n  border-top: 1px solid #D3D3D3 !important;\r\n  padding: 0; \r\n  color:#D3D3D3 !important;\r\n  width: 100%;\r\n  background-color: #8AA8C0 !important;\r\n}\r\n"

/***/ }),

/***/ "./src/app/mViewer/viewers/mobius-cesium/setting/visualise.component.html":
/*!********************************************************************************!*\
  !*** ./src/app/mViewer/viewers/mobius-cesium/setting/visualise.component.html ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<div id=\"SettingView\" >\r\n    <table>\r\n      <tr>\r\n      <th class=\"colorkey\" style=\"width: 80px\"><div class=\"Hide\" style=\"width: 80px;color:#D3D3D3 !important;border:0;text-align: left;font-weight: normal;\">Color</div></th>\r\n      <th><div>\r\n        <select class=\"cesium-button\" (change)=\"onChangeColor($event.target.value)\" [ngModel]=\"_ColorKey\">\r\n          <option class=\"cesium-option\"  *ngFor=\"let ColorName of _ColorProperty\" value={{ColorName}}>{{ColorName}}</option>\r\n        </select>\r\n      </div></th>\r\n      </tr>\r\n      </table>\r\n      <table>\r\n      <tr ><th style=\"width:80px;height: 25px;\"><div style=\"width: 80px;color:#D3D3D3 !important;font-weight: normal;text-align: left;border:0;\">Min</div></th>\r\n      <th style=\"width:80px;height: 18px;\"><input type=\"text\"  value={{_ColorMin}} style=\"width:80px;height: 18px;background:transparent;color:#D3D3D3;border:1px solid #8AA8C0;font-weight: normal;text-align: left;\" (change)=\"changeColorMin($event.target.value)\"></th></tr>  \r\n      </table>\r\n      <table >\r\n      <tr ><th style=\"width:80px;\"><div style=\"width: 80px;color:#D3D3D3 !important;font-weight: normal;text-align: left;border:0;\">Max</div></th>\r\n      <th style=\"width:80px;height: 18px;\"><input type=\"text\" value={{_ColorMax}} style=\"width: 80px;height: 18px;background:transparent;color:#D3D3D3;border:1px solid #8AA8C0;font-weight: normal;text-align: left;\" (change)=\"changeColorMax($event.target.value)\"></th></tr>\r\n  </table>\r\n    <table>\r\n      <tr ><th style=\"width:80px;height: 25px;\"><div style=\"width: 80px;color:#D3D3D3 !important;font-weight: normal;text-align: left;border:0;\">Invert</div></th>\r\n      <th style=\"width:80px;height: 25px;\"><div style=\"width:80px;color:#D3D3D3 !important;font-weight: normal;text-align: left;border:0;\"><input type=\"checkbox\" [checked]=\"_ColorInvert\" (click)=\"changeColorInvert()\"></div></th></tr>\r\n    </table>\r\n    <hr>\r\n      <table>\r\n      <tr>\r\n      <th class=\"colorkey\" style=\"width: 80px\"><div class=\"Hide\" style=\"width: 80px;color:#D3D3D3 !important;border:0;text-align: left;font-weight: normal;\">Extrude</div></th>\r\n      <th><div>\r\n        <select class=\"cesium-button\" (change)=\"onChangeHeight($event.target.value)\" [ngModel]=\"_ExtrudeKey\">\r\n           <option class=\"cesium-option\"  *ngFor=\"let Height of _ExtrudeProperty\" value={{Height}}>{{Height}}</option>\r\n        </select>\r\n      </div></th>\r\n      </tr>\r\n    </table>\r\n    <table>\r\n      <tr ><th style=\"width:80px;height: 25px;\"><div style=\"width: 80px;color:#D3D3D3 !important;font-weight: normal;text-align: left;border:0;\">Min</div></th>\r\n      <th style=\"width:80px;height: 18px;\"><input type=\"text\"  value={{_ExtrudeMin}} style=\"width:80px;height: 18px;background:transparent;color:#D3D3D3;border:1px solid #8AA8C0;font-weight: normal;text-align: left\" (change)=\"changeHeightMin($event.target.value)\"></th></tr>  \r\n      </table>\r\n      <table >\r\n      <tr ><th style=\"width:80px;\"><div style=\"width: 80px;color:#D3D3D3 !important;font-weight: normal;text-align: left;border:0;\">Max</div></th>\r\n      <th style=\"width:80px;height: 18px;\"><input type=\"text\" value={{_ExtrudeMax}} style=\"width: 80px;height: 18px;background:transparent;color:#D3D3D3;border:1px solid #8AA8C0;font-weight: normal;text-align: left;\" (change)=\"changeHeightMax($event.target.value)\"></th></tr>\r\n  </table>\r\n   <table>\r\n      <tr ><th style=\"width:80px;height: 25px;\"><div style=\"width: 80px;color:#D3D3D3 !important;font-weight: normal;text-align: left;border:0;\">Scale</div></th>\r\n      <th style=\"width:80px;height: 18px;\"><input type=\"text\" value={{_Scale}} style=\"width:80px;height: 18px;background:transparent;color:#D3D3D3;border:1px solid #8AA8C0;font-weight: normal;text-align: left;\" (change)=\"changescale($event.target.value)\" ></th></tr>\r\n      <tr ><th style=\"width:80px;height: 25px;\"><div style=\"width: 80px;color:#D3D3D3 !important;font-weight: normal;text-align: left;border:0;\">Invert</div></th>\r\n      <th style=\"width:80px;height: 25px;\"><div style=\"width:80px;color:#D3D3D3 !important;font-weight: normal;text-align: left;border:0;\"><input type=\"checkbox\" [checked]=\"_Invert\" (click)=\"changeopp()\"></div></th></tr>\r\n      <tr ><th style=\"width:80px;height: 25px;\"><div style=\"width: 80px;color:#D3D3D3 !important;font-weight: normal;text-align: left;border:0;\">Height Chart</div></th>\r\n      <th style=\"width:80px;height: 25px;\"><div style=\"width:80px;color:#D3D3D3 !important;font-weight: normal;text-align: left;border:0;\"><input type=\"checkbox\" [checked]=\"_HeightChart\" (click)=\"changeExtrude();\"></div></th></tr>  \r\n  </table>\r\n  <hr>\r\n  <table>\r\n    <tr>\r\n    <th class=\"colorkey\" style=\"width: 75px;height: 25px;\"><div class=\"Hide\" style=\"width: 75px;height: 25;color:#D3D3D3 !important;border-color:#395d73;border:0;text-align: left;font-weight: normal;\"><input type=\"button\" value=\"Add Filter\" style=\"color:#D3D3D3;border:1px solid #8AA8C0;width: 75px;height: 25px;background-color: transparent;cursor:pointer;\" (click)=\"addHide()\"></div></th>\r\n    <th style=\"width:20px;height: 22px;\"><div style=\"width:20px;height: 22px;margin-left: 10px\">\r\n      <select class=\"cesium-button-select\"  (change)=\"ChangeHeight($event.target.value)\">\r\n         <option class=\"cesium-option\"  *ngFor=\"let ColorName of _ColorProperty\" value={{ColorName}}>{{ColorName}}</option>\r\n      </select></div></th>\r\n    </tr>\r\n  </table>\r\n  <div class=\"hide-container\" style=\"margin-top:5px;\">\r\n    <div *ngFor=\"let item of _Filter;\" id={{item.divid}}>\r\n  <table>\r\n    <tr ><th style=\"width:85px;height: 22px;\"><div style=\"width:85px;color:#D3D3D3 !important;text-align: left;vertical-align: middle;font-weight: normal;\">{{item.HeightHide}}</div></th>\r\n    <th *ngIf=\"item.type === 'number'\" style=\"width:40px;height: 22px;\"><div style=\"width:40px;height: 22px;\">\r\n      <select class=\"cesium-button-select\" [ngModel]=\"item.RelaHide\" (change)=\"Changerelation($event.target.value,item.id)\" style=\"width:40px;height: 22px;\">\r\n         <option class=\"cesium-option\" value=0>></option>\r\n         <option class=\"cesium-option\" value=1><</option>\r\n         <option class=\"cesium-option\" value=2>=</option>\r\n      </select></div></th>\r\n      <th *ngIf=\"item.type === 'category'\" style=\"width:40px;height: 22px;\"><div style=\"width:40px;height: 22px;\">\r\n      <select class=\"cesium-button-select\" [ngModel]=\"item.RelaHide\" (change)=\"ChangeCategory($event.target.value,item.id,0)\" style=\"width:40px;height: 22px;\">\r\n        <option class=\"cesium-option\" value=0>none</option>\r\n        <option class=\"cesium-option\" value=1>=</option>\r\n        <option class=\"cesium-option\" value=2>!=</option>\r\n      </select></div></th>\r\n      <th *ngIf=\"item.type === 'number'\" style=\"width:70px;height: 20px;\"><input type=\"text\" id={{item.id}} value={{item.textHide}} (change)=\"Changetext($event.target.value,item.id)\" style=\"width:70px;height: 20px;background:transparent;color:#D3D3D3;border:1px solid #8AA8C0;\"></th>\r\n      <th *ngIf=\"item.type === 'category'\" style=\"width:73px;height: 22px;\"><div style=\"width:73px;height: 22px;\">\r\n      <select class=\"cesium-button-select\" [ngModel]=\"item.CategaryHide\" (change)=\"ChangeCategory($event.target.value,item.id,1)\" style=\"width:73px;height: 22px;\">\r\n        <option class=\"cesium-option\" *ngFor=\"let caty of item.Category\" value={{caty}}>{{caty}}</option>\r\n      </select></div></th>\r\n    <th style=\"width:20px;height: 22px;\" id={{item.id}}><span id={{item.id}} (click)=\"deleteHide(item.id)\" style=\"width:20px;height: 22px;cursor:pointer;\"><i class=\"material-icons\" style=\"color:#D3D3D3;font-size:16px\">delete</i></span></th>\r\n    <th style=\"width:20px;height: 25px;\" id={{item.id}}><input type=\"checkbox\" id={{item.id}} checked=\"checked\" (click)=\"Disable(item.id)\" tyle=\"width:20px;height: 25px;cursor:pointer;\"></th></tr>\r\n  </table>\r\n  <table>\r\n    <tr>\r\n    <th *ngIf=\"item.type === 'number'\" style=\"width:50px;height: 25px;vertical-align: top;padding-top: 10px;\"><div style=\"font-weight: normal;display: inline-block;color:#D3D3D3 !important;width:30px;\">{{item.HideMin}}</div></th>\r\n    <th *ngIf=\"item.type === 'number'\" style=\"width:150px;height: 22px;\"><div style=\"font-weight: normal;display: inline-block;width:150px;\"><mat-slider class=\"slider\" name=\"range\" id=\"0\" min={{item.HideMin}} max={{item.HideMax}} step=0.01 thumbLabel=true value={{item.textHide}} #textscale (change)=\"Changetext(textscale.value.toPrecision(2),item.id)\" >\r\n    </mat-slider></div></th>\r\n    <th *ngIf=\"item.type === 'number'\" style=\"width:50px;height: 25px;vertical-align: top;padding-top: 10px;\"><div style=\"font-weight: normal;display: inline-block;color:#D3D3D3 !important;width:30px;text-align: left;\">{{item.HideMax}}</div></th></tr>\r\n  </table><hr>\r\n    </div>\r\n  </div>\r\n  </div>\r\n  "

/***/ }),

/***/ "./src/app/mViewer/viewers/mobius-cesium/setting/visualise.component.ts":
/*!******************************************************************************!*\
  !*** ./src/app/mViewer/viewers/mobius-cesium/setting/visualise.component.ts ***!
  \******************************************************************************/
/*! exports provided: DataComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataComponent", function() { return DataComponent; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var _data_DataSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../data/DataSubscriber */ "./src/app/mViewer/viewers/mobius-cesium/data/DataSubscriber.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __values = (undefined && undefined.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};


var DataComponent = /** @class */ (function (_super) {
    __extends(DataComponent, _super);
    function DataComponent(injector, myElement) {
        var _this = _super.call(this, injector) || this;
        _this._CheckDisable = true;
        return _this;
    }
    DataComponent.prototype.ngOnInit = function () {
        this.dataArr = this.dataService.get_ViData();
        if (this.dataArr !== undefined) {
            this.LoadData();
        }
    };
    DataComponent.prototype.notify = function (message) {
        if (message === "model_update") {
            try {
                this.dataArr = this.dataService.get_ViData();
                if (this.dataArr !== undefined) {
                    this.LoadData();
                }
            }
            catch (ex) {
                console.log(ex);
            }
        }
    };
    //load data
    DataComponent.prototype.LoadData = function () {
        this._ColorProperty = this.dataArr["ColorProperty"];
        this._ColorKey = this.dataArr["ColorKey"];
        this._ColorMax = this.dataArr["ColorMax"];
        this._ColorMin = this.dataArr["ColorMin"];
        this._ColorInvert = this.dataArr["ColorInvert"];
        this._ExtrudeProperty = this.dataArr["ExtrudeProperty"];
        this._ExtrudeKey = this.dataArr["ExtrudeKey"];
        this._ExtrudeMax = this.dataArr["ExtrudeMax"];
        this._ExtrudeMin = this.dataArr["ExtrudeMin"];
        this._HeightChart = this.dataArr["HeightChart"];
        this._Invert = this.dataArr["Invert"];
        this._Scale = this.dataArr["Scale"];
        this._Filter = this.dataArr["Filter"];
        this._HideNum = this.dataArr["HideNum"];
    };
    //change color property in editor version
    DataComponent.prototype.onChangeColor = function (value) {
        this.dataArr["ColorKey"] = value;
        var promise = this.dataService.getcesiumpromise();
        var _Colortexts = [];
        var self = this;
        promise.then(function (dataSource) {
            var e_1, _a;
            var entities = dataSource.entities.values;
            try {
                for (var entities_1 = __values(entities), entities_1_1 = entities_1.next(); !entities_1_1.done; entities_1_1 = entities_1.next()) {
                    var entity = entities_1_1.value;
                    if (entity.properties[value] !== undefined) {
                        if (entity.properties[value]._value !== " ") {
                            if (_Colortexts.length === 0) {
                                _Colortexts[0] = entity.properties[value]._value;
                            }
                            else {
                                if (_Colortexts.indexOf(entity.properties[value]._value) === -1) {
                                    _Colortexts.push(entity.properties[value]._value);
                                }
                            }
                        }
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (entities_1_1 && !entities_1_1.done && (_a = entities_1.return)) _a.call(entities_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
        this.dataArr["ColorMin"] = Math.min.apply(Math, _Colortexts);
        this.dataArr["ColorMax"] = Math.max.apply(Math, _Colortexts);
        this.dataArr["ColorText"] = _Colortexts.sort();
        this.dataService.set_ViData(this.dataArr);
        this.LoadData();
    };
    //change color min in editor version
    DataComponent.prototype.changeColorMin = function (_Min) {
        this.dataArr["ColorMin"] = Number(_Min);
        this._ColorMin = this.dataArr["ColorMin"];
        this.dataService.set_ViData(this.dataArr);
    };
    //change color max in editor version
    DataComponent.prototype.changeColorMax = function (_Max) {
        this.dataArr["ColorMax"] = Number(_Max);
        this._ColorMax = this.dataArr["ColorMax"];
        this.dataService.set_ViData(this.dataArr);
    };
    //change color invert in editor version
    DataComponent.prototype.changeColorInvert = function () {
        this._ColorInvert = !this._ColorInvert;
        this.dataArr["ColorInvert"] = this._ColorInvert;
        this.dataService.set_ViData(this.dataArr);
    };
    //change extrudeheight property in editor version
    DataComponent.prototype.onChangeHeight = function (value) {
        this.dataArr["ExtrudeKey"] = value;
        var promise = this.dataService.getcesiumpromise();
        var _Heighttexts = [];
        var self = this;
        promise.then(function (dataSource) {
            var e_2, _a;
            var entities = dataSource.entities.values;
            try {
                for (var entities_2 = __values(entities), entities_2_1 = entities_2.next(); !entities_2_1.done; entities_2_1 = entities_2.next()) {
                    var entity = entities_2_1.value;
                    if (entity.properties[value] !== undefined) {
                        if (entity.properties[value]._value !== " ") {
                            if (_Heighttexts.length === 0) {
                                _Heighttexts[0] = entity.properties[value]._value;
                            }
                            else {
                                if (_Heighttexts.indexOf(entity.properties[value]._value) === -1) {
                                    _Heighttexts.push(entity.properties[value]._value);
                                }
                            }
                        }
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (entities_2_1 && !entities_2_1.done && (_a = entities_2.return)) _a.call(entities_2);
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
        this.dataArr["ExtrudeMin"] = Math.min.apply(Math, _Heighttexts);
        this.dataArr["ExtrudeMax"] = Math.max.apply(Math, _Heighttexts);
        this.dataArr["ExtrudeText"] = _Heighttexts.sort();
        this.dataService.set_ViData(this.dataArr);
        this.LoadData();
    };
    //change extrudeheight min in editor version
    DataComponent.prototype.changeHeightMin = function (_Min) {
        this.dataArr["ExtrudeMin"] = Number(_Min);
        this._ExtrudeMin = this.dataArr["ExtrudeMin"];
        this.dataService.set_ViData(this.dataArr);
    };
    //change extrudeHeight max in editor version
    DataComponent.prototype.changeHeightMax = function (_Max) {
        this.dataArr["ExtrudeMax"] = Number(_Max);
        this._ExtrudeMax = this.dataArr["ExtrudeMax"];
        this.dataService.set_ViData(this.dataArr);
    };
    //change scale in editor version
    DataComponent.prototype.changescale = function (_ScaleValue) {
        this.dataArr["Scale"] = Number(_ScaleValue);
        this._Scale = this.dataArr["Scale"];
        this.dataService.set_ViData(this.dataArr);
    };
    //change extrudeheight invert in editor version
    DataComponent.prototype.changeopp = function () {
        this._Invert = !this._Invert;
        this.dataArr["Invert"] = this._Invert;
        this.dataService.set_ViData(this.dataArr);
    };
    //change heightChart in editor version
    DataComponent.prototype.changeExtrude = function () {
        this._HeightChart = !this._HeightChart;
        this.dataArr["HeightChart"] = this._HeightChart;
        this.dataService.set_ViData(this.dataArr);
    };
    //add filter in editor version
    DataComponent.prototype.addHide = function () {
        var lastnumber;
        if (this.dataArr["HideNum"] !== undefined) {
            this._HideNum = this.dataArr["HideNum"];
            this._Filter = this.dataArr["Filter"];
        }
        if (this._HideNum === null || this._HideNum.length === 0) {
            this._HideNum[0] = "0";
            lastnumber = this._HideNum[0];
        }
        else {
            for (var i = 0; i < this._HideNum.length + 1; i++) {
                if (this._HideNum.indexOf(String(i)) === -1) {
                    this._HideNum.push(String(i));
                    lastnumber = String(i);
                    break;
                }
            }
        }
        if (this._HideValue === undefined) {
            this._HideValue = this._ColorProperty[0];
        }
        var texts = this.Initial(this._HideValue);
        var _HideType;
        if (typeof (texts[0]) === "number") {
            _HideType = "number";
        }
        else if (typeof (texts[0]) === "string") {
            _HideType = "category";
        }
        this._Filter.push({ divid: String("addHide".concat(String(lastnumber))), id: lastnumber,
            HeightHide: this._HideValue, type: _HideType, Category: texts, CategaryHide: texts[0],
            RelaHide: 0, textHide: Math.round(Math.min.apply(Math, texts) * 100) / 100,
            HideMax: Math.ceil(Math.max.apply(Math, texts)),
            HideMin: Math.round(Math.min.apply(Math, texts) * 100) / 100, Disabletext: null });
        this.dataArr["Filter"] = this._Filter;
        this.dataArr["HideNum"] = this._HideNum;
        this.dataService.set_ViData(this.dataArr);
    };
    //delete filter in editor version
    DataComponent.prototype.deleteHide = function (event) {
        var index = this._HideNum.indexOf(event);
        var divid = String("addHide".concat(String(event)));
        var addHide = document.getElementById(divid);
        var hidecontainer = document.getElementsByClassName("hide-container")[0];
        hidecontainer.removeChild(addHide);
        if (this._Filter[index].type === "number") {
            if (this._Filter[index].RelaHide === "0" || this._Filter[index].RelaHide === 0) {
                this._Filter[index].textHide = this._Filter[index].HideMin;
            }
            if (this._Filter[index].RelaHide === "1" || this._Filter[index].RelaHide === 1) {
                this._Filter[index].textHide = this._Filter[index].HideMax;
            }
        }
        else if (this._Filter[index].type === "category") {
            this._Filter[index].RelaHide = 0;
        }
        this._Filter.splice(index, 1);
        this._HideNum.splice(index, 1);
        this.dataArr["Filter"] = this._Filter;
        this.dataArr["HideNum"] = this._HideNum;
        this.dataService.set_ViData(this.dataArr);
    };
    //change disable button in filter
    DataComponent.prototype.Disable = function (event) {
        var index = this._HideNum.indexOf(event);
        var divid = String("addHide".concat(String(event)));
        var addHide = document.getElementById(divid);
        if (this._Filter[index].Disabletext === null) {
            this._CheckDisable = false;
        }
        else {
            this._CheckDisable = true;
        }
        if (this._CheckDisable === false) {
            if (this._Filter[index].type === "number") {
                var textHide = this._Filter[index].textHide;
                this._Filter[index].Disabletext = Number(textHide);
                if (this._Filter[index].RelaHide === "0" || this._Filter[index].RelaHide === 0) {
                    this._Filter[index].textHide = this._Filter[index].HideMin;
                }
                if (this._Filter[index].RelaHide === "1" || this._Filter[index].RelaHide === 1) {
                    this._Filter[index].textHide = this._Filter[index].HideMax;
                }
            }
            else if (this._Filter[index].type === "category") {
                var textHide = this._Filter[index].RelaHide;
                this._Filter[index].Disabletext = Number(textHide);
                this._Filter[index].RelaHide = 0;
            }
        }
        else {
            if (this._Filter[index].type === "number") {
                this._Filter[index].textHide = this._Filter[index].Disabletext;
                this._Filter[index].Disabletext = null;
            }
            else if (this._Filter[index].type === "category") {
                this._Filter[index].RelaHide = this._Filter[index].Disabletext;
                this._Filter[index].Disabletext = null;
            }
        }
        this.dataArr["Filter"] = this._Filter;
        this.dataArr["HideNum"] = this._HideNum;
        this.dataService.set_ViData(this.dataArr);
    };
    //change height slider in filter
    DataComponent.prototype.ChangeHeight = function (_HeightHide) {
        this._HideValue = _HeightHide;
    };
    //change relation in filter
    DataComponent.prototype.Changerelation = function (_RelaHide, id) {
        var index = this._HideNum.indexOf(id);
        var HeightHide = this._Filter[index].HeightHide;
        this._Filter[index].RelaHide = _RelaHide;
        var texts = [];
        var promise = this.dataService.getcesiumpromise();
        var self = this;
        promise.then(function (dataSource) {
            var e_3, _a;
            var entities = dataSource.entities.values;
            try {
                for (var entities_3 = __values(entities), entities_3_1 = entities_3.next(); !entities_3_1.done; entities_3_1 = entities_3.next()) {
                    var entity = entities_3_1.value;
                    if (entity.properties[HeightHide] !== undefined) {
                        if (entity.properties[HeightHide]._value !== " ") {
                            if (texts.length === 0) {
                                texts[0] = entity.properties[HeightHide]._value;
                            }
                            else {
                                if (texts.indexOf(entity.properties[HeightHide]._value) === -1) {
                                    texts.push(entity.properties[HeightHide]._value);
                                }
                            }
                        }
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (entities_3_1 && !entities_3_1.done && (_a = entities_3.return)) _a.call(entities_3);
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
        this._Filter[index].HideMax = Math.ceil(Math.max.apply(Math, texts));
        this._Filter[index].HideMin = Math.round(Math.min.apply(Math, texts) * 100) / 100;
        if (_RelaHide === "0" || _RelaHide === 0) {
            this._Filter[index].textHide = this._Filter[index].HideMin;
        }
        if (_RelaHide === "1" || _RelaHide === 1) {
            this._Filter[index].textHide = this._Filter[index].HideMax;
        }
    };
    //change category in filter
    DataComponent.prototype.ChangeCategory = function (categary, id, type) {
        var index = this._HideNum.indexOf(id);
        if (type === 1) {
            this._Filter[index].CategaryHide = categary;
        }
        if (type === 0) {
            this._Filter[index].RelaHide = Number(categary);
        }
    };
    //change text in filter
    DataComponent.prototype.Changetext = function (value, id) {
        var index = this._HideNum.indexOf(id);
        this._Filter[index].textHide = value;
    };
    //get text according to property
    DataComponent.prototype.Initial = function (_HideValue) {
        var texts = [];
        var promise = this.dataService.getcesiumpromise();
        var self = this;
        promise.then(function (dataSource) {
            var e_4, _a;
            var entities = dataSource.entities.values;
            try {
                for (var entities_4 = __values(entities), entities_4_1 = entities_4.next(); !entities_4_1.done; entities_4_1 = entities_4.next()) {
                    var entity = entities_4_1.value;
                    if (entity.properties[_HideValue] !== undefined) {
                        if (entity.properties[_HideValue]._value !== " ") {
                            if (texts.length === 0) {
                                texts[0] = entity.properties[_HideValue]._value;
                            }
                            else {
                                if (texts.indexOf(entity.properties[_HideValue]._value) === -1) {
                                    texts.push(entity.properties[_HideValue]._value);
                                }
                            }
                        }
                    }
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (entities_4_1 && !entities_4_1.done && (_a = entities_4.return)) _a.call(entities_4);
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
        return texts;
    };
    DataComponent = __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"])({
            selector: "app-data",
            template: __webpack_require__(/*! ./visualise.component.html */ "./src/app/mViewer/viewers/mobius-cesium/setting/visualise.component.html"),
            styles: [__webpack_require__(/*! ./visualise.component.css */ "./src/app/mViewer/viewers/mobius-cesium/setting/visualise.component.css")],
        }),
        __metadata("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_0__["Injector"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"]])
    ], DataComponent);
    return DataComponent;
}(_data_DataSubscriber__WEBPACK_IMPORTED_MODULE_1__["DataSubscriber"]));



/***/ }),

/***/ "./src/app/mViewer/viewers/mobius-cesium/viewer/viewer.component.css":
/*!***************************************************************************!*\
  !*** ./src/app/mViewer/viewers/mobius-cesium/viewer/viewer.component.css ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "body{\r\n  background: red;\r\n}\r\n#cesiumContainer{\r\n height: 100%;\r\n width: 100%; \r\n font-family: sans-serif !important;\r\n margin: 0px !important;\r\n padding: 0px !important;\r\n font-size: 14px;\r\n}\r\n#ColorBar{\r\n  z-index:99;\r\n  margin: 5px;\r\n  width: 100%;\r\n  padding: 2px 5px;\r\n  position: absolute;\r\n  display:inline-block;\r\n  bottom: 7%;\r\n  overflow: hidden !important;\r\n  text-overflow: ellipsis !important;\r\n  table-layout:fixed !important;\r\n  white-space: nowrap !important;\r\n}\r\n#ColorKey{\r\n  z-index:99;\r\n  margin: 5px;\r\n  width: 100%;\r\n  padding: 2px 5px;\r\n  position: absolute;\r\n  display:inline-block;\r\n  bottom: 2%;\r\n  overflow: hidden !important;\r\n  text-overflow: ellipsis !important;\r\n  table-layout:fixed !important;\r\n  white-space: nowrap !important;\r\n}\r\n#Download{\r\n  z-index: 99;\r\n  top: 5px;\r\n  position: absolute;\r\n  right: 120px;\r\n  width: 32px;\r\n  height: 32px;\r\n  font-size: 16px;\r\n  box-sizing: border-box;\r\n  border-radius: 14%;\r\n  padding: 0;\r\n  vertical-align: middle;\r\n}\r\n\r\n"

/***/ }),

/***/ "./src/app/mViewer/viewers/mobius-cesium/viewer/viewer.component.html":
/*!****************************************************************************!*\
  !*** ./src/app/mViewer/viewers/mobius-cesium/viewer/viewer.component.html ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<div id=\"cesiumContainer\" (click)=\"select();showAttribs($event)\" (mousemove)=\"Colortext();\">\r\n  <button class=\"cesium-button cesium-button-toolbar\" (click)=\"save_geojson()\" id=\"Download\"><i class=\"fa fa-download\"></i></button>\r\n  <div id=\"ColorBar\" *ngIf=\"texts!==undefined\">\r\n  \t<table border=\"0\" cellspacing=\"0\" cellpadding=\"0\" bordercolor=\"#d0d0d0\" style=\"width: 88%;margin-left: 9%\">\r\n       <tr >\r\n          <th *ngFor=\"let text of texts;\" style=\"text-align:right;width: 7%\"><div  style=\"width: 8%;vertical-align: text-top;color:white;text-shadow: 0px 0px 3px black;\">{{text}}</div></th>\r\n        </tr>\r\n    </table>\r\n\t<table border=\"0\" cellspacing=\"0\" cellpadding=\"0\" bordercolor=\"#d0d0d0\" style=\"width: 80%;margin: 0 auto;\">\r\n       <tr>\r\n          <th  *ngFor=\"let color of _Colorbar;let indx=index\" style=\"width: 0.5px;\" ><div [ngStyle]=\"{ 'background-color': color}\" ><div *ngIf=\"indx%8===0\" style=\"border-left: #FFFFFF 1px solid;border-color: black\">&nbsp;</div><div *ngIf=\"indx%8!==0\">&nbsp;</div></div></th>\r\n        </tr>\r\n    </table>\r\n  </div>\r\n  <div id=\"ColorBar\" *ngIf=\"_Cattexts!==undefined\" style=\"width: 100%;text-align: center\">\r\n    <table border=\"0\" cellspacing=\"0\" cellpadding=\"0\" bordercolor=\"#d0d0d0\" *ngFor=\"let cattext of _Cattexts\" style=\"display:inline-block;overflow: hidden !important;text-overflow: ellipsis !important;table-layout:fixed !important;white-space: nowrap !important; \">\r\n          <tr >\r\n            <th  style=\"width:80px;display:inline-block;overflow: hidden !important;text-overflow: ellipsis !important;table-layout:fixed !important;white-space: nowrap !important; \"><div [ngStyle]=\"{ 'background-color': cattext.color}\" >&nbsp;&nbsp;&nbsp;</div></th>\r\n        </tr>\r\n        <tr>\r\n            <th><div matTooltip={{cattext.text}}  style=\"width:80px;text-align: left;white-space: nowrap;display:inline-block;overflow: hidden !important;text-overflow: ellipsis !important;cursor:pointer;color:white;text-shadow: 0px 0px 3px black;\">{{cattext.text}}</div></th>\r\n          </tr>\r\n        </table>\r\n  </div>\r\n  <div id=\"ColorBar\" *ngIf=\"_CatNumtexts!==undefined\" >\r\n    <table border=\"0\" cellspacing=\"0\" cellpadding=\"0\" bordercolor=\"#d0d0d0\" style=\"width: 82%;margin: 0 auto;\">\r\n      <tr >\r\n        <th *ngFor=\"let cattext of _CatNumtexts;\" style=\"text-align:left;max-width: 3%\"><div *ngIf=\"cattext.text!==null\" style=\"width: 0.5px;vertical-align: text-top;color:white;text-shadow: 0px 0px 3px black;\">{{cattext.text}}</div><div *ngIf=\"cattext.text===null\" style=\"width: 0.5px;vertical-align: text-top;color:white;text-shadow: 0px 0px 3px black;\">&nbsp;&nbsp;&nbsp;</div></th>\r\n      </tr>\r\n    </table>\r\n    <table border=\"0\" cellspacing=\"0\" cellpadding=\"0\" bordercolor=\"#d0d0d0\" style=\"width: 80%;margin: 0 auto;\">\r\n      <tr>\r\n        <th  *ngFor=\"let cattext of _CatNumtexts;let indx=index\" style=\"width: 0.5px;\" ><div [ngStyle]=\"{ 'background-color': cattext.color}\" ><div style=\"border-color: black\">&nbsp;</div></div></th>\r\n      </tr>\r\n    </table>\r\n  </div>\r\n  <div *ngIf=\"mode==='viewer'\" id=\"ColorKey\">\r\n    <table border=\"0\" cellspacing=\"0\" cellpadding=\"0\" bordercolor=\"#d0d0d0\" style=\"width: 80%;margin: 0 auto;text-align:center;color:white;text-shadow: 0px 0px 3px black;\" >\r\n      <tr>\r\n        <th  style=\"width: 40%;\" ><div>Color:&nbsp;{{_ColorKey}}</div></th>\r\n        <th  style=\"width: 40%;\" ><div>Extrude:&nbsp;{{_ExtrudeKey}}</div></th>\r\n      </tr>\r\n    </table>\r\n  </div>\r\n  <div>\r\n    <table id=\"cesium-infoBox-defaultTable\" style=\"width: 140px;position:absolute;padding:4px;background-color:white;display: none;\">\r\n       <tr *ngFor=\"let pickupArr of pickupArrs\"><th style=\"font-size: 10px;font-weight: normal;color:#395d73;width: 60px;height: 14px\"><div matTooltip={{pickupArr.name}} style=\"width: 60px;height:14px;text-align: left;white-space: nowrap;display:block;overflow: hidden !important;text-overflow: ellipsis !important;cursor:pointer;\">{{pickupArr.name}}</div></th><th style=\"font-size: 10px;font-weight: normal;color:#395d73;width: 80px;height: 14px\"><div matTooltip={{pickupArr.data}} style=\"width: 80px;height:14px;text-align: left;white-space: nowrap;display:block;overflow: hidden !important;text-overflow: ellipsis !important;cursor:pointer;\">{{pickupArr.data}}</div></th></tr>\r\n       </table>\r\n        \r\n     </div>\r\n</div>"

/***/ }),

/***/ "./src/app/mViewer/viewers/mobius-cesium/viewer/viewer.component.ts":
/*!**************************************************************************!*\
  !*** ./src/app/mViewer/viewers/mobius-cesium/viewer/viewer.component.ts ***!
  \**************************************************************************/
/*! exports provided: ViewerComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ViewerComponent", function() { return ViewerComponent; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var _data_DataSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../data/DataSubscriber */ "./src/app/mViewer/viewers/mobius-cesium/data/DataSubscriber.ts");
/* harmony import */ var chroma_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! chroma-js */ "./node_modules/chroma-js/chroma.js");
/* harmony import */ var chroma_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(chroma_js__WEBPACK_IMPORTED_MODULE_2__);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __values = (undefined && undefined.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};


// import * as d3 from "d3-array";

var ViewerComponent = /** @class */ (function (_super) {
    __extends(ViewerComponent, _super);
    function ViewerComponent(injector, myElement) {
        var _this = _super.call(this, injector) || this;
        _this.selectEntity = null;
        _this.myElement = myElement;
        return _this;
    }
    ViewerComponent.prototype.ngOnInit = function () {
        //pass mode to dataService
        this.mode = this.dataService.getmode();
        if (this.dataService.getViewer() === undefined) {
            this.CreateViewer();
        }
        //pass data to dataService
        this.data = this.dataService.getGsModel();
        //load data
        this.LoadData(this.data);
    };
    ViewerComponent.prototype.notify = function (message) {
        if (message === "model_update") {
            this.data = this.dataService.getGsModel();
            try {
                if (this.dataService.getViewer() === undefined) {
                    this.CreateViewer();
                }
                this.LoadData(this.data);
            }
            catch (ex) {
                console.log(ex);
            }
        }
    };
    //create cesium viewer and change home button funciton
    ViewerComponent.prototype.CreateViewer = function () {
        var viewer = new Cesium.Viewer("cesiumContainer", {
            infoBox: false,
            showRenderLoopErrors: false,
            orderIndependentTranslucency: false,
            baseLayerPicker: false,
            fullscreenButton: false,
            automaticallyTrackDataSourceClocks: false,
            animation: false,
            shadows: true,
            scene3DOnly: true,
        });
        viewer.scene.imageryLayers.removeAll();
        viewer.scene.globe.baseColor = Cesium.Color.GRAY;
        document.getElementsByClassName("cesium-viewer-bottom")[0].remove();
        var self = this;
        viewer.homeButton.viewModel.command.beforeExecute.addEventListener(function (e) {
            e.cancel = true;
            viewer.zoomTo(self.dataService.getcesiumpromise());
        });
        this.dataService.setViewer(viewer);
    };
    //Cesium geoJson to load data and check mode
    ViewerComponent.prototype.LoadData = function (data) {
        if (this.data !== undefined) {
            //get viewer from dataService and remove the last dataSources
            var viewer = this.dataService.getViewer();
            viewer.dataSources.removeAll({ destroy: true });
            //load geojson and add geojson to dataSources
            this.data = data;
            var promise = Cesium.GeoJsonDataSource.load(this.data);
            viewer.dataSources.add(promise);
            //check whether show colorbar or not
            promise.then(function (dataSource) {
                var entities = dataSource.entities.values;
                var self = this;
                if (entities[0].polygon !== undefined) {
                    self._ShowColorBar = true;
                }
                else {
                    self._ShowColorBar = false;
                }
            });
            // pass promise to dataService
            this.dataService.setcesiumpromise(promise);
            //check the mode and load different data
            if (this.mode === "editor") {
                this.dataService.getValue(this.data);
                this.dataService.LoadJSONData();
                this.dataArr = this.dataService.get_ViData();
                this._index = 1;
            }
            if (this.mode === "viewer") {
                this.dataService.LoadJSONData();
                this.dataArr = this.dataService.get_PuData();
                this._index = 3;
            }
            viewer.zoomTo(promise);
            this.Colortext();
        }
    };
    //create color bar and text at bottom of viewer
    ViewerComponent.prototype.Colortext = function () {
        if (this.dataArr !== undefined) {
            if (this._index !== this.dataService.get_index()) {
                this._index = this.dataService.get_index();
                if (this._index === 1) {
                    this.dataArr = this.dataService.get_ViData();
                }
                else if (this._index === 3) {
                    this.dataArr = this.dataService.get_PuData();
                }
            }
            var propertyname = this.dataArr["ColorKey"];
            var texts = this.dataArr["ColorText"].sort();
            var _Max = this.dataArr["ColorMax"];
            var _Min = this.dataArr["ColorMin"];
            if (this.mode === "viewer") {
                this._ColorKey = this.dataArr["ColorKey"];
                this._ExtrudeKey = this.dataArr["ExtrudeKey"];
            }
            this.texts = undefined;
            this._Cattexts = [];
            this._CatNumtexts = [];
            var _ColorKey = void 0;
            var _ChromaScale = chroma_js__WEBPACK_IMPORTED_MODULE_2__["scale"]("SPECTRAL");
            if (this.dataArr["ColorInvert"] === true) {
                _ChromaScale = chroma_js__WEBPACK_IMPORTED_MODULE_2__["scale"]("SPECTRAL").domain([1, 0]);
            }
            this._Colorbar = [];
            for (var i = 79; i > -1; i--) {
                this._Colorbar.push(_ChromaScale(i / 80));
            }
            if (typeof (texts[0]) === "number") {
                this.texts = [Number(_Min.toFixed(2))];
                for (var i = 1; i < 10; i++) {
                    this.texts.push(Number((_Min + (_Max - _Min) * (i / 10)).toFixed(2)));
                }
                this.texts.push(Number(_Max.toFixed(2)));
                for (var i = 0; i < this.texts.length; i++) {
                    if (this.texts[i] / 1000000000 > 1) {
                        this.texts[i] = String(Number((this.texts[i] / 1000000000).toFixed(3))).concat("B");
                    }
                    else if (this.texts[i] / 1000000 > 1) {
                        this.texts[i] = String(Number((this.texts[i] / 1000000).toFixed(3))).concat("M");
                    }
                    else if (this.texts[i] / 1000 > 1) {
                        this.texts[i] = String(Number(((this.texts[i] / 1000)).toFixed(3))).concat("K");
                    }
                }
            }
            if (typeof (texts[0]) === "string") {
                if (texts.length <= 12) {
                    for (var j = 0; j < texts.length; j++) {
                        _ColorKey = [];
                        _ColorKey.text = texts[j];
                        _ColorKey.color = _ChromaScale(1 - (j / texts.length));
                        this._Cattexts.push(_ColorKey);
                    }
                }
                else {
                    for (var j = 0; j < this._Colorbar.length; j++) {
                        _ColorKey = [];
                        if (j === 0) {
                            _ColorKey.text = texts[j];
                        }
                        else if (j === this._Colorbar.length - 1) {
                            if (texts[texts.length - 1] !== null) {
                                _ColorKey.text = texts[texts.length - 1];
                            }
                            else {
                                _ColorKey.text = texts[texts.length - 2];
                            }
                        }
                        else {
                            _ColorKey.text = null;
                        }
                        _ColorKey.color = this._Colorbar[j];
                        this._CatNumtexts.push(_ColorKey);
                    }
                }
            }
        }
        if (this._ShowColorBar === false) {
            this._Cattexts = undefined;
            this._Colorbar = undefined;
        }
    };
    //click building to select and  pass whole entity to dataService
    ViewerComponent.prototype.select = function () {
        event.stopPropagation();
        var viewer = this.dataService.getViewer(); //this.viewer;
        if (this.dataArr !== undefined) {
            if (this.selectEntity !== undefined && this.selectEntity !== null) {
                this.ColorSelect(this.selectEntity);
            }
            if (viewer.selectedEntity !== undefined && viewer.selectedEntity.polygon !== null) {
                this.dataService.set_SelectedEntity(viewer.selectedEntity);
                var material = void 0;
                if (viewer.selectedEntity.polygon !== undefined) {
                    material = viewer.selectedEntity.polygon.material;
                    viewer.selectedEntity.polygon.material = Cesium.Color.WHITE;
                }
                if (viewer.selectedEntity.polyline !== undefined) {
                    material = viewer.selectedEntity.polyline.material;
                    viewer.selectedEntity.polyline.material = Cesium.Color.WHITE;
                }
                this.selectEntity = viewer.selectedEntity;
                this.material = material;
            }
            else {
                this.dataService.set_SelectedEntity(undefined);
                this.selectEntity = undefined;
                this.material = undefined;
            }
        }
    };
    //if unselect the building, it will show the color before
    ViewerComponent.prototype.ColorSelect = function (entity) {
        var promise = this.dataService.getcesiumpromise();
        var _ColorKey = this.dataArr["ColorKey"];
        var _ColorMax = this.dataArr["ColorMax"];
        var _ColorMin = this.dataArr["ColorMin"];
        var _ColorText = this.dataArr["ColorText"];
        var _ColorInvert = this.dataArr["ColorInvert"];
        var _ExtrudeKey = this.dataArr["ExtrudeKey"];
        var _ExtrudeMax = this.dataArr["ExtrudeMax"];
        var _ExtrudeMin = this.dataArr["ExtrudeMin"];
        var _HeightChart = this.dataArr["HeightChart"];
        var _Invert = this.dataArr["Invert"];
        var _Scale = this.dataArr["Scale"];
        var _Filter = this.dataArr["Filter"];
        var _ChromaScale = chroma_js__WEBPACK_IMPORTED_MODULE_2__["scale"]("SPECTRAL");
        if (_ColorInvert === true) {
            _ChromaScale = chroma_js__WEBPACK_IMPORTED_MODULE_2__["scale"]("SPECTRAL").domain([1, 0]);
        }
        var _CheckHide;
        if (entity.properties["TYPE"] === undefined || entity.properties["TYPE"]._value !== "STATIC") {
            if (_Filter.length !== 0) {
                _CheckHide = this.Hide(_Filter, entity, _HeightChart);
                if (_CheckHide === true) {
                    if (entity.polygon !== undefined) {
                        entity.polygon.extrudedHeight = 0;
                        entity.polygon.material = Cesium.Color.LIGHTSLATEGRAY.withAlpha(1);
                        if (_HeightChart === true) {
                            if (entity.polyline !== undefined) {
                                entity.polyline.show = false;
                            }
                        }
                    }
                    if (entity.polyline !== undefined) {
                        entity.polyline.material = Cesium.Color.LIGHTSLATEGRAY.withAlpha(1);
                    }
                }
            }
            if (_Filter.length === 0 || _CheckHide === false) {
                if (_ColorKey !== "None") {
                    if (typeof (_ColorText[0]) === "number") {
                        this.colorByNum(entity, _ColorMax, _ColorMin, _ColorKey, _ChromaScale);
                    }
                    else {
                        this.colorByCat(entity, _ColorText, _ColorKey, _ChromaScale);
                    }
                }
                else {
                    entity.polygon.material = Cesium.Color.DARKGREY;
                }
            }
        }
        else {
            entity.polygon.height = entity.properties["HEIGHT"];
            entity.polygon.extrudedHeight = entity.properties["EXTRUHEIGHT"];
            var ColorValue = entity.properties["COLOR"]._value;
            entity.polygon.material = Cesium.Color.fromBytes(ColorValue[0], ColorValue[1], ColorValue[2], ColorValue[3]);
        }
    };
    //check the selected building  color before
    ViewerComponent.prototype.Hide = function (_Filter, entity, _HeightChart) {
        var e_1, _a;
        var _CheckHide = false;
        try {
            for (var _Filter_1 = __values(_Filter), _Filter_1_1 = _Filter_1.next(); !_Filter_1_1.done; _Filter_1_1 = _Filter_1.next()) {
                var filter = _Filter_1_1.value;
                var value = entity.properties[filter.HeightHide]._value;
                if (value !== undefined) {
                    if (typeof (value) === "number") {
                        if (this._compare(value, Number(filter.textHide), Number(filter.RelaHide))) {
                            _CheckHide = true;
                        }
                    }
                    else if (typeof (value) === "string") {
                        if (this._compareCat(value, filter.CategaryHide, Number(filter.RelaHide))) {
                            _CheckHide = true;
                        }
                    }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_Filter_1_1 && !_Filter_1_1.done && (_a = _Filter_1.return)) _a.call(_Filter_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return _CheckHide;
    };
    ViewerComponent.prototype._compare = function (value, slider, relation) {
        switch (relation) {
            case 0:
                return value < slider;
            case 1:
                return value > slider;
            case 2:
                return value !== slider;
        }
    };
    ViewerComponent.prototype._compareCat = function (value, _Categary, relation) {
        switch (relation) {
            case 0:
                return value === undefined;
            case 1:
                return value !== _Categary;
            case 2:
                return value === _Categary;
        }
    };
    ViewerComponent.prototype.colorByNum = function (entity, max, min, _ColorKey, _ChromaScale) {
        if (entity.properties[_ColorKey] !== undefined) {
            var texts = entity.properties[_ColorKey]._value;
            var rgb = _ChromaScale(Number(((max - texts) / (max - min)).toFixed(2)))._rgb;
            if (entity.polygon !== undefined) {
                entity.polygon.material = Cesium.Color.fromBytes(rgb[0], rgb[1], rgb[2]);
            }
            if (entity.polyline !== undefined) {
                var newColor = new Cesium.Color.fromBytes(rgb[0], rgb[1], rgb[2]);
                entity.polyline.material.color.setValue(newColor);
            }
            if (entity.point !== undefined) {
                var newColor = new Cesium.Color.fromBytes(rgb[0], rgb[1], rgb[2]);
                entity.point.color = newColor;
            }
        }
        else {
            if (entity.polygon !== undefined) {
                entity.polygon.material = Cesium.Color.LIGHTSLATEGRAY.withAlpha(1);
            }
            if (entity.polyline !== undefined) {
                entity.polyline.material = Cesium.Color.LIGHTSLATEGRAY.withAlpha(1);
            }
            if (entity.point !== undefined) {
                entity.point.color = Cesium.Color.LIGHTSLATEGRAY.withAlpha(1);
            }
        }
    };
    ViewerComponent.prototype.colorByCat = function (entity, _ColorText, _ColorKey, _ChromaScale) {
        if (entity.properties[_ColorKey] !== undefined) {
            var initial = false;
            for (var j = 0; j < _ColorText.length; j++) {
                if (entity.properties[_ColorKey]._value === _ColorText[j]) {
                    var rgb = _ChromaScale(1 - (j / _ColorText.length));
                    if (entity.polygon !== undefined) {
                        entity.polygon.material = Cesium.Color.fromBytes(rgb._rgb[0], rgb._rgb[1], rgb._rgb[2]);
                    }
                    if (entity.polyline !== undefined) {
                        var newColor = new Cesium.Color.fromBytes(rgb[0], rgb[1], rgb[2]);
                        entity.polyline.material.color.setValue(newColor);
                    }
                    if (entity.point !== undefined) {
                        var newColor = new Cesium.Color.fromBytes(rgb[0], rgb[1], rgb[2]);
                        entity.point.color = newColor;
                    }
                    initial = true;
                }
            }
            if (initial === false) {
                if (entity.polygon !== undefined) {
                    entity.polygon.material = Cesium.Color.LIGHTSLATEGRAY.withAlpha(1);
                }
                if (entity.polyline !== undefined) {
                    entity.polyline.material = Cesium.Color.LIGHTSLATEGRAY.withAlpha(1);
                }
                if (entity.point !== undefined) {
                    entity.point.color = Cesium.Color.LIGHTSLATEGRAY.withAlpha(1);
                }
            }
        }
        else {
            if (entity.polygon !== undefined) {
                entity.polygon.material = Cesium.Color.LIGHTSLATEGRAY.withAlpha(1);
            }
            if (entity.polyline !== undefined) {
                entity.polyline.material = Cesium.Color.LIGHTSLATEGRAY.withAlpha(1);
            }
            if (entity.point !== undefined) {
                entity.point.color = Cesium.Color.LIGHTSLATEGRAY.withAlpha(1);
            }
        }
    };
    //in viewer mode,set some attibutes to show
    ViewerComponent.prototype.showAttribs = function (event) {
        var e_2, _a;
        var viewer = this.dataService.getViewer();
        if (this.data !== undefined && this.mode === "viewer") {
            if (this.data["cesium"] !== undefined) {
                if (this.data["cesium"].select !== undefined) {
                    if (viewer.selectedEntity !== undefined) {
                        var pickup = viewer.scene.pick(new Cesium.Cartesian2(event.clientX, event.clientY));
                        this.pickupArrs = [];
                        this.pickupArrs.push({ name: "ID", data: pickup.id.id });
                        try {
                            for (var _b = __values(this.data["cesium"].select), _c = _b.next(); !_c.done; _c = _b.next()) {
                                var _propertyName = _c.value;
                                this.pickupArrs.push({ name: _propertyName, data: this.dataService.get_SelectedEntity().properties[_propertyName]._value });
                            }
                        }
                        catch (e_2_1) { e_2 = { error: e_2_1 }; }
                        finally {
                            try {
                                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                            }
                            finally { if (e_2) throw e_2.error; }
                        }
                        var nameOverlay = document.getElementById("cesium-infoBox-defaultTable");
                        viewer.container.appendChild(nameOverlay);
                        nameOverlay.style.bottom = viewer.canvas.clientHeight - event.clientY + "px";
                        nameOverlay.style.left = event.clientX + "px";
                        nameOverlay.style.display = "block";
                    }
                    else {
                        document.getElementById("cesium-infoBox-defaultTable").style.display = "none";
                    }
                }
            }
        }
    };
    // save the geojson
    ViewerComponent.prototype.save_geojson = function () {
        var fileString = JSON.stringify(this.data);
        var blob = new Blob([fileString], { type: 'application/json' });
        FileUtils.downloadContent(blob, "output.geojson");
    };
    ViewerComponent = __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"])({
            selector: "cesium-viewer",
            template: __webpack_require__(/*! ./viewer.component.html */ "./src/app/mViewer/viewers/mobius-cesium/viewer/viewer.component.html"),
            styles: [__webpack_require__(/*! ./viewer.component.css */ "./src/app/mViewer/viewers/mobius-cesium/viewer/viewer.component.css")],
        }),
        __metadata("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_0__["Injector"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"]])
    ], ViewerComponent);
    return ViewerComponent;
}(_data_DataSubscriber__WEBPACK_IMPORTED_MODULE_1__["DataSubscriber"]));

//download geojson
var FileUtils = /** @class */ (function () {
    function FileUtils() {
    }
    FileUtils.downloadContent = function (blob, filename) {
        if (window.navigator.msSaveOrOpenBlob) {
            window.navigator.msSaveOrOpenBlob(blob, filename);
        }
        else {
            var a_1 = document.createElement('a');
            document.body.appendChild(a_1);
            var url_1 = window.URL.createObjectURL(blob);
            a_1.href = url_1;
            a_1.download = filename;
            a_1.click();
            setTimeout(function () {
                window.URL.revokeObjectURL(url_1);
                document.body.removeChild(a_1);
            }, 0);
        }
    };
    return FileUtils;
}());


/***/ }),

/***/ "./src/app/mViewer/viewers/viewer-text.component.ts":
/*!**********************************************************!*\
  !*** ./src/app/mViewer/viewers/viewer-text.component.ts ***!
  \**********************************************************/
/*! exports provided: TextViewerComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextViewerComponent", function() { return TextViewerComponent; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var _modules__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @modules */ "./src/app/core/modules/index.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


var TextViewerComponent = /** @class */ (function () {
    function TextViewerComponent() {
        console.log("Text Viewer Created");
    }
    TextViewerComponent.prototype.ngOnInit = function () {
        if (!this.node) {
            this.output = "no-value";
        }
        else if (typeof this.node.output.value === 'number' || this.node.output.value === undefined) {
            this.output = this.node.output.value;
        }
        else if (typeof this.node.output.value === 'string') {
            this.output = '"' + this.node.output.value + '"';
        }
        else if (this.node.output.value.constructor === [].constructor) {
            this.output = JSON.stringify(this.node.output.value);
        }
        else if (this.node.output.value.constructor === {}.constructor) {
            this.output = JSON.stringify(this.node.output.value);
        }
        else if (this.node.output.value.constructor === _modules__WEBPACK_IMPORTED_MODULE_1__["gsConstructor"]) {
            this.output = this.node.output.value.toJSON();
        }
        else {
            console.log('Unknown output type:', this.node.output.value);
            this.output = this.node.output.value;
        }
    };
    TextViewerComponent.prototype.ngDoCheck = function () {
        if (!this.node) {
            this.output = "no-value";
        }
        else if (typeof this.node.output.value === 'number' || this.node.output.value === undefined) {
            this.output = this.node.output.value;
        }
        else if (typeof this.node.output.value === 'string') {
            this.output = '"' + this.node.output.value + '"';
        }
        else if (this.node.output.value.constructor === [].constructor) {
            this.output = JSON.stringify(this.node.output.value);
        }
        else if (this.node.output.value.constructor === {}.constructor) {
            this.output = JSON.stringify(this.node.output.value);
        }
        else if (this.node.output.value.constructor === _modules__WEBPACK_IMPORTED_MODULE_1__["gsConstructor"]) {
            this.output = JSON.stringify(this.node.output.value.toJSON());
        }
        else {
            console.log('Unknown output type:', this.node.output.value);
            this.output = this.node.output.value;
        }
    };
    __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(),
        __metadata("design:type", Object)
    ], TextViewerComponent.prototype, "node", void 0);
    TextViewerComponent = __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"])({
            selector: 'text-viewer',
            template: "<br><div>{{ output || \"no-value\" }}</div>",
            styles: []
        }),
        __metadata("design:paramtypes", [])
    ], TextViewerComponent);
    return TextViewerComponent;
}());



/***/ }),

/***/ "./src/app/ngFlowchart-svg/edge/edge.component.html":
/*!**********************************************************!*\
  !*** ./src/app/ngFlowchart-svg/edge/edge.component.html ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<!--the main line-->\r\n<svg:polyline \r\nid=\"main-edge\" \r\nclass = \"edge\" \r\n[class.selected] = \"edge.selected\"\r\n[attr.points] = \"(edge.source.parentNode.position.x + outputOffset[0]) + ',' +\r\n                    (edge.source.parentNode.position.y + outputOffset[1]+ 9) + ' ' +\r\n\r\n                    (edge.source.parentNode.position.x + outputOffset[0]) + ',' +\r\n                    (edge.source.parentNode.position.y + outputOffset[1] + 17) + ' ' +\r\n\r\n                    (edge.target.parentNode.position.x + inputOffset[0]) + ',' +\r\n                    (edge.target.parentNode.position.y + inputOffset[1] - 29) + ' ' +\r\n\r\n                    (edge.target.parentNode.position.x + inputOffset[0]) + ',' +\r\n                    (edge.target.parentNode.position.y + inputOffset[1] - 24)\" \r\n/>\r\n\r\n<!--a wider invisible line to make the wire easier to click-->\r\n<svg:polyline \r\nid=\"invisible-edge\" \r\nclass = \"inviEdge\" \r\n[attr.points] = \"(edge.source.parentNode.position.x + outputOffset[0]) + ',' +\r\n                    (edge.source.parentNode.position.y + outputOffset[1]+ 15) + ' ' +\r\n\r\n                    (edge.source.parentNode.position.x + outputOffset[0]) + ',' +\r\n                    (edge.source.parentNode.position.y + outputOffset[1] + 17) + ' ' +\r\n\r\n                    (edge.target.parentNode.position.x + inputOffset[0]) + ',' +\r\n                    (edge.target.parentNode.position.y + inputOffset[1] - 29) + ' ' +\r\n\r\n                    (edge.target.parentNode.position.x + inputOffset[0]) + ',' +\r\n                    (edge.target.parentNode.position.y + inputOffset[1] - 10)\" \r\n(click)='select($event)'/>\r\n    \r\n\r\n"

/***/ }),

/***/ "./src/app/ngFlowchart-svg/edge/edge.component.ts":
/*!********************************************************!*\
  !*** ./src/app/ngFlowchart-svg/edge/edge.component.ts ***!
  \********************************************************/
/*! exports provided: EdgeComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EdgeComponent", function() { return EdgeComponent; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

var EdgeComponent = /** @class */ (function () {
    function EdgeComponent() {
        this.delete = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.selected = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
    }
    // select a wire
    EdgeComponent.prototype.select = function (event) {
        event.preventDefault();
        event.stopPropagation();
        if (this.edge.selected) {
            this.selected.emit(event.ctrlKey);
        }
        else {
            if (event.ctrlKey)
                this.selected.emit('ctrl');
            else
                this.selected.emit('single');
        }
    };
    // delete a wire
    EdgeComponent.prototype.deleteEdge = function () {
        this.delete.emit();
    };
    EdgeComponent.prototype.ngOnInit = function () {
    };
    __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ViewChild"])('canvas'),
        __metadata("design:type", _angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"])
    ], EdgeComponent.prototype, "canvas", void 0);
    __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(),
        __metadata("design:type", Object)
    ], EdgeComponent.prototype, "edge", void 0);
    __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(),
        __metadata("design:type", Object)
    ], EdgeComponent.prototype, "inputOffset", void 0);
    __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(),
        __metadata("design:type", Object)
    ], EdgeComponent.prototype, "outputOffset", void 0);
    __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"])(),
        __metadata("design:type", Object)
    ], EdgeComponent.prototype, "delete", void 0);
    __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"])(),
        __metadata("design:type", Object)
    ], EdgeComponent.prototype, "selected", void 0);
    EdgeComponent = __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"])({
            selector: '[edge]',
            template: __webpack_require__(/*! ./edge.component.html */ "./src/app/ngFlowchart-svg/edge/edge.component.html"),
            styles: ["\n    .edge{\n        fill: none;\n        stroke: rgb(80, 80, 80);\n        stroke-linecap: round;\n        stroke-linejoin: round;\n        stroke-width: 2px;\n        opacity: 1;\n        pointer-events: stroke;\n        marker-end: url(#arrow);\n    }  \n    .inviEdge{\n        fill: none;\n        stroke: gray;\n        stroke-width: 30px;\n        opacity: 0;\n        pointer-events: stroke;\n    }  \n    .selected{\n        stroke: rgb(0, 0, 150);\n        opacity: 1;\n        marker-end: url(#arrow_selected);\n\n    }\n  "]
        })
    ], EdgeComponent);
    return EdgeComponent;
}());



/***/ }),

/***/ "./src/app/ngFlowchart-svg/flowchart.component.html":
/*!**********************************************************!*\
  !*** ./src/app/ngFlowchart-svg/flowchart.component.html ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<div id = 'flowchart-main-container' class='container'>\r\n\r\n      <!-- svg component -->\r\n      <svg id=\"svg-canvas\" class = \"svgCanvas\" viewBox=\"0 0 1500 1500\" \r\n      (mousedown)='panStart($event)'\r\n      (mousemove)='handleMouseMove($event)'  \r\n      (mouseup)='handleMouseUp($event)'\r\n      (mouseenter)='activateKeyEvent()'\r\n      (mouseleave)='deactivateKeyEvent()'\r\n      (wheel)='scale($event)'\r\n      >\r\n            <!-- definitions for svg: grid patterns, arrow head for connecting wire-->\r\n            <defs>\r\n                  <!-- grid pattern -->\r\n                  <pattern id=\"smallGrid\" width=\"20\" height=\"20\" patternUnits=\"userSpaceOnUse\">\r\n                    <path d=\"M 20 0 L 0 0 0 20\" fill=\"none\" stroke=\"gray\" stroke-width=\"0.5\"/>\r\n                  </pattern>\r\n                  <pattern id=\"grid\" width=\"100\" height=\"100\" patternUnits=\"userSpaceOnUse\">\r\n                    <rect width=\"100\" height=\"100\" fill=\"url(#smallGrid)\"/>\r\n                    <path d=\"M 100 0 L 0 0 0 100\" fill=\"none\" stroke=\"gray\" stroke-width=\"1\"/>\r\n                  </pattern>\r\n\r\n                  <!-- arrow head -->\r\n                  <marker id=\"arrow\" markerWidth=\"30\" markerHeight=\"30\" refX=\"0\" refY=\"4\" orient=\"auto\" markerUnits=\"strokeWidth\" viewBox=\"0 0 40 40\">\r\n                    <path d=\"M0,0 L0,8 L9,4 z\" stroke=\"rgb(80, 80, 80)\" fill=\"transparent\" />\r\n                  </marker>\r\n                  <marker id=\"arrow_selected\" markerWidth=\"30\" markerHeight=\"30\" refX=\"0\" refY=\"4\" orient=\"auto\" markerUnits=\"strokeWidth\" viewBox=\"0 0 40 40\">\r\n                        <path d=\"M0,0 L0,8 L9,4 z\" stroke=\"rgb(0, 0, 150)\" fill=\"transparent\"  />\r\n                  </marker>\r\n            </defs>\r\n\r\n            <!-- svg frame-->\r\n            <rect width=\"100%\" height=\"100%\" fill=\"url(#grid)\" />\r\n                          \r\n\r\n            <!-- wires => edge.component -->\r\n            <g edge *ngFor=\"let edge of data.edges; let edge_index = index\" \r\n            [edge]='edge'\r\n            [inputOffset]='inputOffset'\r\n            [outputOffset]='outputOffset'\r\n            (selected)='selectEdge($event, edge_index)'\r\n            />\r\n\r\n            <!-- temporary wire while dragging port, default position to <(0,0),(0,0)>, modified when a port is being dragged -->\r\n            <line id=\"temporary-wire\" class=\"temp-wire\" x1=\"0\" y1='0' x2='0' y2='0'></line>\r\n\r\n            <!-- nodes => node.component -->\r\n            <g node *ngFor=\"let node of data.nodes; let node_index = index\" \r\n            id='flw_node_{{node_index}}'\r\n            [node]='node' \r\n            [selected]='isSelected(node_index)'\r\n            [inputOffset]='inputOffset'\r\n            [outputOffset]='outputOffset'\r\n            (action)='nodeAction($event, node_index)'\r\n            />\r\n      </svg>\r\n\r\n      <!-- 3 top left buttons of the svg: add Node, delete Node and delete Wire -->\r\n      <div class='button-row'>\r\n            <button mat-icon-button disableRipple='true' (click)='addNode()' title=\"Add Node\">\r\n            <mat-icon>add</mat-icon>\r\n            </button>\r\n            <button mat-icon-button disableRipple='true' (click)='deleteSelectedNodes()' title=\"Delete Selected Node\">\r\n            <mat-icon>remove</mat-icon>\r\n            </button>\r\n            <button mat-icon-button disableRipple='true' (click)='deleteSelectedEdges()' title=\"Delete Selected Wires\">\r\n            <mat-icon>link_off</mat-icon>\r\n            </button>\r\n      </div>\r\n\r\n      <!-- focus on flowchart button on the top right of the svg -->\r\n      <button class='resetViewer-button' mat-icon-button disableRipple='true' (click)='focusFlowchart()' title=\"Zoom to Fit\">\r\n            <mat-icon>control_camera</mat-icon>\r\n      </button>\r\n      \r\n\r\n</div>\r\n\r\n\r\n\r\n"

/***/ }),

/***/ "./src/app/ngFlowchart-svg/flowchart.component.scss":
/*!**********************************************************!*\
  !*** ./src/app/ngFlowchart-svg/flowchart.component.scss ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ".reset {\n  margin: 0px;\n  padding: 0px; }\n\n.default {\n  font-size: 12px;\n  color: #8AA8C0;\n  line-height: 150px;\n  text-align: center; }\n\n.viewer {\n  /* \twidth: 100%; \r\noverflow: auto;\r\n\r\npadding: 0px;\r\nmargin: 0px;\r\n\r\n.header{\r\n\r\n\tdisplay: flex; \r\n\tflex-direction: row; \r\n\tjustify-content: space-between;\r\n\r\n\tposition: relative;\r\n\tfont-size: 14px; \r\n\tfont-weight: 600; \r\n\tline-height: $header-height;\r\n\ttext-transform: uppercase;\r\n\tletter-spacing: 1.5px;\r\n\theight: $header-height;\r\n\r\n\tcolor: #ADADAD;\r\n\r\n\t.btn-group{\r\n\t\theight: $header-height; \r\n\r\n\t\tbutton{\r\n\t\t\twidth: 0.9*$header-height; \r\n\t\t\theight: 0.9*$header-height; \r\n\t\t\tmargin: 0px;\r\n\t\t\tborder: 1px solid #B4B1B1;\r\n\t\t\tbox-shadow: none;\r\n\r\n\t\t\t&:focus{\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t}\r\n\r\n}\r\n\r\n.container{\r\n}\r\n\r\nbutton{\r\n\t&:focus{\r\n\t\t\r\n\t}\r\n} */ }\n\n.viewer .container {\n    display: flex;\n    flex-direction: row;\n    height: 100%; }\n\n.viewer .container .sidebar {\n      z-index: 100; }\n\n.viewer .container .view-container {\n      box-sizing: border-box;\n      height: 100%;\n      width: 100%;\n      padding-bottom: 30px;\n      overflow: auto; }\n\n.container {\n  position: relative;\n  width: 100%;\n  height: 100%;\n  overflow: hidden; }\n\n.container .svgCanvas .temp-wire {\n    stroke: #505050;\n    stroke-width: 2px;\n    stroke-dasharray: 10 15;\n    opacity: 0.5; }\n\n.transform--container {\n  position: absolute;\n  width: 100%;\n  transition: -webkit-transform 0.1s;\n  transition: transform 0.1s;\n  transition: transform 0.1s, -webkit-transform 0.1s; }\n\nsplit-area {\n  overflow: auto !important; }\n\ninput {\n  border: none; }\n\ninput:focus {\n  border-bottom: 1px dashed gray; }\n\n#flowchart__name {\n  margin: 0 auto;\n  font-size: 14px;\n  line-height: 28px;\n  font-weight: bold;\n  color: #8AA8C0; }\n\n.button-row {\n  position: absolute;\n  top: 0px;\n  left: 10px; }\n\n.button-row button {\n    color: #505050;\n    width: 28px; }\n\n.resetViewer-button {\n  position: absolute;\n  top: 0px;\n  right: 0px;\n  color: #505050; }\n\n.viewer {\n  position: relative;\n  height: 100%;\n  width: 100%;\n  display: flex;\n  flex-direction: column;\n  background-image: repeating-linear-gradient(0deg, transparent, transparent 70px, #F1F1F1 70px, #F1F1F1 71px), repeating-linear-gradient(-90deg, transparent, transparent 70px, #F1F1F1 70px, #F1F1F1 71px);\n  background-size: 71px 71px;\n  background-color: white;\n  box-sizing: border-box;\n  height: 100%;\n  width: 100%;\n  padding-bottom: 30px; }\n\n.viewer .container {\n    position: absolute;\n    height: 100%;\n    overflow: hidden; }\n\n.viewer .container .disabled {\n      color: #8AA8C0; }\n\n.viewer .container .disabled:hover {\n        color: #8AA8C0 !important; }\n\n.viewer .container .sidebar {\n      font-size: 12px;\n      background-color: #F1F1F1;\n      color: #395D73;\n      white-space: nowrap;\n      overflow-x: hidden !important; }\n\n.viewer .container .sidebar section {\n        padding-left: 15px;\n        padding-bottom: 5px;\n        padding-top: 5px;\n        border-bottom: 1px solid #8AA8C0; }\n\n.viewer .container .sidebar section div {\n          cursor: pointer; }\n\n.viewer .container .sidebar section div:hover {\n            color: #F0BFA0; }\n\n.viewer .content-wrapper {\n    position: relative;\n    height: 100%;\n    width: 100%;\n    -webkit-transform-origin: top left;\n            transform-origin: top left; }\n\n.viewer .info-container {\n    padding: 0px 30px;\n    display: flex;\n    flex-direction: row;\n    justify-content: space-between; }\n\n.viewer .info-container .info {\n      display: flex;\n      flex-direction: column; }\n\n.viewer .info-container .info .label {\n        font-size: 12px;\n        font-weight: 100;\n        color: #F07A79; }\n\n.viewer .info-container .info .value {\n        color: #395D73;\n        font-size: 11px;\n        font-weight: 600; }\n\n.viewer .info-container .info .action {\n        cursor: pointer;\n        font-size: 11px;\n        color: #8AA8C0; }\n\n.viewer .graph-container {\n    position: absolute;\n    height: 100%;\n    width: 100%;\n    -webkit-transform-origin: top left;\n            transform-origin: top left; }\n\n.viewer .graph-container #graph-edges {\n      background-color: transparent;\n      z-index: 1000; }\n\n.viewer .graph-container #graph-edges #temporary-edge .hidden {\n        display: none; }\n\n.viewer .graph-container #graph-nodes {\n      background-color: transparent;\n      overflow: hidden;\n      z-index: 1000; }\n\n.viewer .info-container {\n    position: absolute;\n    right: 0;\n    bottom: 0; }\n\n.viewer .info-container .label, .viewer .info-container .value {\n      margin-right: 5px;\n      font-weight: normal !important; }\n\n.viewer .node-container {\n    position: relative; }\n\n.viewer .node-container .node {\n      position: absolute;\n      -webkit-transform-origin: top left;\n              transform-origin: top left;\n      z-index: 3;\n      margin: 0px;\n      color: #395D73; }\n\n.viewer .node-container .node.hidden {\n        display: none; }\n\n.viewer .node-container .node .btn-container {\n        position: absolute;\n        right: -30px;\n        display: flex;\n        flex-direction: column;\n        justify-content: space-between;\n        height: 100px; }\n\n.viewer .node-container .node .btn-container .btn-group {\n          position: relative;\n          display: flex;\n          flex-direction: column;\n          justify-content: center;\n          background: none; }\n\n.viewer .node-container .node .btn-container .btn-group .action-button {\n            position: relative;\n            width: 25px;\n            height: 24px;\n            cursor: pointer;\n            font-size: 9px;\n            text-align: center; }\n\n.viewer .node-container .node .btn-container .btn-group .action-button .material-icons {\n              font-size: 18px;\n              line-height: 24px;\n              color: #8AA8C0; }\n\n.viewer .node-container .node .btn-container .btn-group .action-button:hover {\n              color: white; }\n\n.viewer .node-container .node .btn-container .btn-group .action-button:hover .mat-icon {\n                color: #F0BFA0; }\n\n.viewer .node-container .node .node-body {\n        display: flex;\n        flex-direction: column;\n        justify-content: center;\n        position: relative;\n        min-height: 30px;\n        min-width: 70px;\n        width: auto;\n        border: 1px solid #395D73;\n        background-color: rgba(255, 255, 255, 0.7);\n        cursor: move; }\n\n.viewer .node-container .node .node-body.disabled {\n          opacity: 0.4; }\n\n.viewer .node-container .node .node-body.selected {\n          border-color: green; }\n\n.viewer .node-container .node .node-body.library {\n          border-color: #395D73;\n          border-style: solid; }\n\n.viewer .node-container .node .node-body.error {\n          background-color: #E94858; }\n\n.viewer .node-container .node .node-body.function {\n          background-color: yellow;\n          border: 1px dashed green; }\n\n.viewer .node-container .node .node-body .node-name {\n          font-family: sans-serif;\n          font-size: 12px;\n          border-bottom: 1px solid #395D73;\n          text-align: center;\n          background-color: #F1F1F1; }\n\n.viewer .node-container .node .node-body .node-name input {\n            background-color: inherit;\n            border: 0px;\n            color: #395D73;\n            text-align: center; }\n\n.viewer .node-container .node .node-body .node-name.selected {\n            background-color: #8AA8C0; }\n\n.viewer .node-container .node .node-body .node-name.selected input {\n              color: white;\n              font-weight: bold; }\n\n.viewer .node-container .node .node-body .node-name.selected input:focus {\n                color: #395D73;\n                background-color: #F0BFA0; }\n\n.viewer .node-container .node .node-body .port-container {\n          display: flex;\n          flex-direction: column;\n          margin-top: 10px;\n          margin-bottom: 10px; }\n\n.viewer .node-container .node .node-body .port-container .divider {\n            height: 2px;\n            width: 100%;\n            background-color: #8AA8C0; }\n\n.viewer .node-container .node .node-body .port-container .port {\n            display: flex;\n            flex-direction: row;\n            margin: 5px 0px; }\n\n.viewer .node-container .node .node-body .port-container .port.hidden {\n              display: none; }\n\n.viewer .node-container .node .node-body .port-container .port .port-grip {\n              width: 15px;\n              height: 15px;\n              border-radius: 50%;\n              background-color: #F1F1F1;\n              border: 1px solid #395D73;\n              cursor: pointer; }\n\n.viewer .node-container .node .node-body .port-container .port .port-grip.isFunction {\n                border-style: dashed;\n                background-color: gray;\n                border-radius: 0px; }\n\n.viewer .node-container .node .node-body .port-container .port .port-grip.selected {\n                border: 2px solid #8AA8C0;\n                background-color: #F0BFA0; }\n\n.viewer .node-container .node .node-body .port-container .port .port-grip:hover {\n                background-color: #F0BFA0; }\n\n.viewer .node-container .node .node-body .port-container .port .port-name {\n              font-size: 12px;\n              margin: 0px 5px; }\n\n.viewer .node-container .node .node-body .port-container .port .port-name.isFunction {\n                color: black;\n                font-size: 9.6px; }\n\n.viewer .node-container .node .node-body .port-container .port.input {\n              justify-content: flex-start;\n              margin-left: -7.5px; }\n\n.viewer .node-container .node .node-body .port-container .port.output {\n              justify-content: flex-end;\n              margin-right: -7.5px; }\n\n.viewer .node-container .node:active {\n        cursor: none; }\n"

/***/ }),

/***/ "./src/app/ngFlowchart-svg/flowchart.component.ts":
/*!********************************************************!*\
  !*** ./src/app/ngFlowchart-svg/flowchart.component.ts ***!
  \********************************************************/
/*! exports provided: FlowchartComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FlowchartComponent", function() { return FlowchartComponent; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var _models_node__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @models/node */ "./src/app/shared/models/node/index.ts");
/* harmony import */ var _node_node_actions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node/node.actions */ "./src/app/ngFlowchart-svg/node/node.actions.ts");
/* harmony import */ var circular_json__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! circular-json */ "./node_modules/circular-json/build/circular-json.node.js");
/* harmony import */ var circular_json__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(circular_json__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm5/index.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __values = (undefined && undefined.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};





var FlowchartComponent = /** @class */ (function () {
    function FlowchartComponent() {
        this.switch = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.startCoords = [];
        // variable for flowchart zooming
        this.mousePos = [0, 0];
        this.zoom = 1;
        // variable for edge
        this.edge = { source: undefined, target: undefined, selected: false };
        this.selectedEdge = [];
        // listener for events, only activated when the mouse is hovering over the svg component
        this.keydownListener = Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["fromEvent"])(document, 'keydown');
        this.copyListener = Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["fromEvent"])(document, 'copy');
        this.pasteListener = Object(rxjs__WEBPACK_IMPORTED_MODULE_4__["fromEvent"])(document, 'paste');
        // constants for offset positions of input/output port relative to the node's position
        this.inputOffset = [50, -8];
        this.outputOffset = [50, 88];
    }
    FlowchartComponent.prototype.ngOnInit = function () {
        this.canvas = document.getElementById("svg-canvas");
        var bRect = this.canvas.getBoundingClientRect();
        this.offset = [bRect.left, bRect.top];
    };
    /*
    handle event received from node component
    */
    FlowchartComponent.prototype.nodeAction = function (event, node_index) {
        switch (event.action) {
            // switch the viewchild of the appModule to the node's procedure view when double-click on the node
            case _node_node_actions__WEBPACK_IMPORTED_MODULE_2__["ACTIONS"].PROCEDURE:
                this.switch.emit("editor");
                this.deactivateKeyEvent();
                break;
            // select a node
            case _node_node_actions__WEBPACK_IMPORTED_MODULE_2__["ACTIONS"].SELECT:
                this.data.meta.selected_nodes = [node_index];
                break;
            // initiate dragging node
            case _node_node_actions__WEBPACK_IMPORTED_MODULE_2__["ACTIONS"].DRAGNODE:
                this.element = this.data.nodes[node_index];
                var pt = this.canvas.createSVGPoint();
                // get current mouse position in the page
                pt.x = event.data.pageX;
                pt.y = event.data.pageY;
                // convert mouse position to svg position (special procedure for firefox)
                var svgP = void 0;
                var isFirefox = typeof InstallTrigger !== 'undefined';
                if (isFirefox) {
                    var ctm = this.canvas.getScreenCTM();
                    var bRect = this.canvas.getBoundingClientRect();
                    ctm.a = ctm.a * this.zoom;
                    ctm.d = ctm.d * this.zoom;
                    ctm.e = bRect.x;
                    ctm.f = bRect.y;
                    svgP = pt.matrixTransform(ctm.inverse());
                }
                else {
                    svgP = pt.matrixTransform(this.canvas.getScreenCTM().inverse());
                }
                // save the svg position as startCoords
                this.startCoords = [
                    svgP.x,
                    svgP.y
                ];
                if (this.startCoords[0] == NaN) {
                    this.startCoords = [0, 0];
                }
                // mark the dragging mode as dragNode
                this.isDown = 2;
                break;
            // initiate dragging input/output port
            case _node_node_actions__WEBPACK_IMPORTED_MODULE_2__["ACTIONS"].DRAGPORT:
                // create a new edge
                this.edge = { source: undefined, target: undefined, selected: false };
                // assign the port to the edge's input/output accordingly
                if (event.type == 'input') {
                    this.edge.target = event.data;
                }
                else {
                    this.edge.source = event.data;
                }
                this.startType = event.type;
                // modify the temporary-edge's coordinate
                this.element = document.getElementById("temporary-wire");
                this.element.setAttribute('x1', event.position[0]);
                this.element.setAttribute('y1', event.position[1]);
                this.element.setAttribute('x2', event.position[0]);
                this.element.setAttribute('y2', event.position[1]);
                this.isDown = 3;
                break;
        }
    };
    // check if the node at node_index is selected 
    FlowchartComponent.prototype.isSelected = function (node_index) {
        return this.data.meta.selected_nodes.indexOf(node_index) > -1;
    };
    // add a new node
    FlowchartComponent.prototype.addNode = function () {
        // create a new node
        var newNode = _models_node__WEBPACK_IMPORTED_MODULE_1__["NodeUtils"].getNewNode();
        // the new node's position would be (20,100) relative to the current view
        var pt = this.canvas.createSVGPoint();
        pt.x = 20;
        pt.y = 100;
        // convert the position to svg position
        var svgP;
        var isFirefox = typeof InstallTrigger !== 'undefined';
        if (isFirefox) {
            var ctm = this.canvas.getScreenCTM();
            var bRect = this.canvas.getBoundingClientRect();
            ctm.a = ctm.a * this.zoom;
            ctm.d = ctm.d * this.zoom;
            ctm.e = bRect.x;
            ctm.f = bRect.y;
            svgP = pt.matrixTransform(ctm.inverse());
        }
        else {
            svgP = pt.matrixTransform(this.canvas.getScreenCTM().inverse());
        }
        // assign the position to the new node and add it to the flowchart
        newNode.position.x = svgP.x;
        newNode.position.y = svgP.y;
        this.data.nodes.push(newNode);
    };
    // activate event listener for copy (ctrl+c), paste (ctrl+v), delete (Delete) when mouse hover over the svg component
    FlowchartComponent.prototype.activateKeyEvent = function () {
        var _this = this;
        // copy: copy node
        this.copySub = this.copyListener.subscribe(function (val) {
            var node = _this.data.nodes[_this.data.meta.selected_nodes[0]];
            if (node.type != 'start' && node.type != 'end') {
                console.log('copied node:', node);
                var cp = circular_json__WEBPACK_IMPORTED_MODULE_3__["parse"](circular_json__WEBPACK_IMPORTED_MODULE_3__["stringify"](node));
                _this.copied = circular_json__WEBPACK_IMPORTED_MODULE_3__["stringify"](cp);
            }
        });
        // paste: paste copied node
        this.pasteSub = this.pasteListener.subscribe(function (val) {
            if (_this.copied) {
                event.preventDefault();
                var newNode = circular_json__WEBPACK_IMPORTED_MODULE_3__["parse"](_this.copied);
                var pt = _this.canvas.createSVGPoint();
                pt.x = 20;
                pt.y = 100;
                var svgP = void 0;
                var isFirefox = typeof InstallTrigger !== 'undefined';
                if (isFirefox) {
                    var ctm = _this.canvas.getScreenCTM();
                    var bRect = _this.canvas.getBoundingClientRect();
                    ctm.a = ctm.a * _this.zoom;
                    ctm.d = ctm.d * _this.zoom;
                    ctm.e = bRect.x;
                    ctm.f = bRect.y;
                    svgP = pt.matrixTransform(ctm.inverse());
                }
                else {
                    svgP = pt.matrixTransform(_this.canvas.getScreenCTM().inverse());
                }
                _models_node__WEBPACK_IMPORTED_MODULE_1__["NodeUtils"].updateNode(newNode, svgP);
                _this.data.nodes.push(newNode);
                console.log('pasting node:', newNode);
            }
        });
        // delete: delete selected edge(s)
        this.keydownSub = this.keydownListener.subscribe(function (val) {
            if (val.key == 'Delete') {
                _this.deleteSelectedEdges();
            }
        });
    };
    // deactivate the event listeners when the mouse exit the svg component
    FlowchartComponent.prototype.deactivateKeyEvent = function () {
        this.copySub.unsubscribe();
        this.pasteSub.unsubscribe();
        this.keydownSub.unsubscribe();
    };
    // delete selected node
    FlowchartComponent.prototype.deleteSelectedNodes = function () {
        // for each of the selected node
        while (this.data.meta.selected_nodes.length > 0) {
            var node_index = this.data.meta.selected_nodes.pop();
            var node = this.data.nodes[node_index];
            // continue if the node is a start/end node
            if (node.type == "start" || node.type == "end")
                continue;
            var edge_index = 0;
            // delete all the edges connected to the node
            while (edge_index < this.data.edges.length) {
                var tbrEdge = this.data.edges[edge_index];
                if (tbrEdge.target.parentNode == node || tbrEdge.source.parentNode == node) {
                    this.deleteEdge(edge_index);
                    continue;
                }
                edge_index += 1;
            }
            // remove the node from the flowchart
            this.data.nodes.splice(Number(node_index), 1);
        }
    };
    // delete an edge with a known index
    FlowchartComponent.prototype.deleteEdge = function (edge_index) {
        var tbrEdge = this.data.edges[edge_index];
        // remove the edge from the target node's list of edges
        for (var i in this.data.edges) {
            if (tbrEdge.target.edges[i] == tbrEdge) {
                tbrEdge.target.edges.splice(Number(i), 1);
                break;
            }
        }
        // remove the edge from the source node's list of edges
        for (var i in tbrEdge.source.edges) {
            if (tbrEdge.source.edges[i] == tbrEdge) {
                tbrEdge.source.edges.splice(Number(i), 1);
                break;
            }
        }
        // remove the edge from the general list of edges
        this.data.edges.splice(edge_index, 1);
        this.data.ordered = false;
    };
    // delete all the selected edges
    FlowchartComponent.prototype.deleteSelectedEdges = function () {
        var e_1, _a;
        this.selectedEdge.sort().reverse();
        try {
            for (var _b = __values(this.selectedEdge), _c = _b.next(); !_c.done; _c = _b.next()) {
                var edge_index = _c.value;
                this.deleteEdge(edge_index);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        this.selectedEdge = [];
    };
    // select an edge
    FlowchartComponent.prototype.selectEdge = function (event, edge_index) {
        var e_2, _a;
        // if ctrl is pressed, add the edge into the list of selected edges
        if (event == 'ctrl') {
            this.selectedEdge.push(edge_index);
            this.data.edges[edge_index].selected = true;
        }
        else if (event == 'single' || (event === false && this.selectedEdge.length > 1)) {
            if (this.selectedEdge.length > 0) {
                try {
                    for (var _b = __values(this.selectedEdge), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var e = _c.value;
                        this.data.edges[e].selected = false;
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
            this.selectedEdge = [edge_index];
            this.data.edges[edge_index].selected = true;
        }
        else {
            this.data.edges[edge_index].selected = false;
            for (var i = 0; i < this.selectedEdge.length; i++)
                if (this.selectedEdge[i] == edge_index) {
                    this.selectedEdge.splice(i, 1);
                    break;
                }
        }
    };
    // focus view onto the flowchart
    FlowchartComponent.prototype.focusFlowchart = function () {
        var e_3, _a;
        // find the frame of the flowchart: frame = [minX, minY, maxX, maxY]
        var frame = [this.data.nodes[0].position.x, this.data.nodes[0].position.y,
            this.data.nodes[0].position.x, this.data.nodes[0].position.y];
        try {
            for (var _b = __values(this.data.nodes), _c = _b.next(); !_c.done; _c = _b.next()) {
                var node = _c.value;
                if (node.position.x < frame[0]) {
                    frame[0] = node.position.x;
                }
                else if (node.position.x > frame[2]) {
                    frame[2] = node.position.x;
                }
                if (node.position.y < frame[1]) {
                    frame[1] = node.position.y;
                }
                else if (node.position.y > frame[3]) {
                    frame[3] = node.position.y;
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
        frame[2] += 100;
        frame[3] += 80;
        // calculate the zoom to fit the whole flowchart
        var bRect = this.canvas.getBoundingClientRect();
        var ctm = this.canvas.getScreenCTM();
        var zoom = bRect.width / (ctm.a * (frame[2] - frame[0]));
        var heightZoom = bRect.height / (ctm.d * (frame[3] - frame[1]));
        if (zoom > heightZoom)
            zoom = heightZoom;
        if (zoom > 2.5)
            zoom = 2.5;
        // calculate the difference between height and width, if height is bigger than width, centering the flowchart based on the difference
        var height_width_diff = ((frame[3] - frame[1]) - (frame[2] - frame[0])) / 2;
        if (height_width_diff > 0) {
            frame[0] -= height_width_diff;
        }
        // if the minX or minY goes below 0 (outside of svg frame), change them back to 0
        if (frame[0] < 0)
            frame[0] = 0;
        if (frame[1] < 0)
            frame[1] = 0;
        // transform
        this.canvas.style.transition = 'transform 0ms ease-in';
        this.canvas.style.transformOrigin = 'top left';
        this.canvas.style.transform = "matrix(" + zoom + ",0,0," + zoom + "," + -frame[0] * ctm.a * zoom / this.zoom + "," + -frame[1] * ctm.a * zoom / this.zoom + ")";
        this.zoom = zoom;
    };
    // scale view on mouse wheel
    FlowchartComponent.prototype.scale = function (event) {
        event.preventDefault();
        event.stopPropagation();
        // calculate new zoom value
        var scaleFactor = 0.1;
        var value = this.zoom - (Math.sign(event.deltaY)) * scaleFactor;
        // limit the zoom value to be between 1 and 2.5
        if (value >= 1 && value <= 2.5) {
            value = Number((value).toPrecision(5));
        }
        else {
            return;
        }
        // if new zoom is bigger than current zoom, update the mouse position to current position
        if (value > this.zoom) {
            this.mousePos = [event.clientX - this.offset[0], event.clientY - this.offset[1]];
        }
        // find transformation matrix
        var m = this.canvas.createSVGMatrix()
            .translate(this.mousePos[0], this.mousePos[1])
            .scale(value)
            .translate(-this.mousePos[0], -this.mousePos[1]);
        var transf = "matrix(" + m.a + "," + m.b + "," + m.c + "," + m.d + "," + m.e + "," + m.f + ")";
        // transform
        this.canvas.style.transition = 'transform 50ms ease-in';
        this.canvas.style.transformOrigin = "top left";
        this.canvas.style.transform = transf;
        this.zoom = value;
    };
    // initiate dragging the view window
    FlowchartComponent.prototype.panStart = function (event) {
        event.preventDefault();
        this.canvas.style.transition = 'transform 0ms linear';
        this.canvas.style.transformOrigin = "top left";
        var bRect = this.canvas.getBoundingClientRect();
        // set start coords to current view window position
        this.startCoords = [
            event.clientX - (bRect.left - this.offset[0]),
            event.clientY - (bRect.top - this.offset[1])
        ];
        // set drag mode to drag view
        this.isDown = 1;
    };
    // handle mouse move for dragging view/node/port
    FlowchartComponent.prototype.handleMouseMove = function (event) {
        // return if no dragging initiated
        if (!this.isDown) {
            return;
            // if drag view
        }
        else if (this.isDown == 1) {
            event.preventDefault();
            var bRect = this.canvas.getBoundingClientRect();
            var x = Number(event.clientX - this.startCoords[0]);
            var y = Number(event.clientY - this.startCoords[1]);
            var boundingDiv = document.getElementById("flowchart-main-container").getBoundingClientRect();
            if (x > 0 || bRect.width < boundingDiv.width) {
                x = 0;
            }
            else if (boundingDiv.width - x > bRect.width) {
                x = boundingDiv.width - bRect.width;
            }
            if (y > 0 || bRect.height < boundingDiv.height) {
                y = 0;
            }
            else if (boundingDiv.height - y > bRect.height) {
                y = boundingDiv.height - bRect.height;
            }
            this.canvas.style.transform = "matrix(" + this.zoom + ",0,0," + this.zoom + "," + x + "," + y + ")";
            // if drag node
        }
        else if (this.isDown == 2) {
            var pt = this.canvas.createSVGPoint();
            pt.x = event.pageX;
            pt.y = event.pageY;
            var svgP = void 0;
            var isFirefox = typeof InstallTrigger !== 'undefined';
            if (isFirefox) {
                var ctm = this.canvas.getScreenCTM();
                var bRect = this.canvas.getBoundingClientRect();
                ctm.a = ctm.a * this.zoom;
                ctm.d = ctm.d * this.zoom;
                ctm.e = bRect.x;
                ctm.f = bRect.y;
                svgP = pt.matrixTransform(ctm.inverse());
            }
            else {
                svgP = pt.matrixTransform(this.canvas.getScreenCTM().inverse());
            }
            var xDiff = this.startCoords[0] - svgP.x;
            var yDiff = this.startCoords[1] - svgP.y;
            this.startCoords[0] = svgP.x;
            this.startCoords[1] = svgP.y;
            this.element.position.x -= xDiff;
            this.element.position.y -= yDiff;
            // if drag port
        }
        else if (this.isDown == 3) {
            event.preventDefault();
            var pt = this.canvas.createSVGPoint();
            pt.x = event.pageX;
            pt.y = event.pageY;
            var isFirefox = typeof InstallTrigger !== 'undefined';
            if (isFirefox) {
                var ctm = this.canvas.getScreenCTM();
                var bRect = this.canvas.getBoundingClientRect();
                ctm.a = ctm.a * this.zoom;
                ctm.d = ctm.d * this.zoom;
                ctm.e = bRect.x;
                ctm.f = bRect.y;
                var svgP = pt.matrixTransform(ctm.inverse());
                this.element.setAttribute('x2', svgP.x);
                this.element.setAttribute('y2', svgP.y);
            }
            else {
                var svgP = pt.matrixTransform(this.canvas.getScreenCTM().inverse());
                this.element.setAttribute('x2', svgP.x);
                this.element.setAttribute('y2', svgP.y);
            }
        }
    };
    FlowchartComponent.prototype.handleMouseUp = function (event) {
        var e_4, _a, e_5, _b;
        this.element = undefined;
        // drop port --> create new edge if drop position is within 15px of an input/output port
        if (this.isDown == 3) {
            var pt = this.canvas.createSVGPoint();
            pt.x = event.pageX;
            pt.y = event.pageY;
            var svgP = void 0;
            var isFirefox = typeof InstallTrigger !== 'undefined';
            if (isFirefox) {
                var ctm = this.canvas.getScreenCTM();
                var bRect = this.canvas.getBoundingClientRect();
                ctm.a = ctm.a * this.zoom;
                ctm.d = ctm.d * this.zoom;
                ctm.e = bRect.x;
                ctm.f = bRect.y;
                svgP = pt.matrixTransform(ctm.inverse());
            }
            else {
                svgP = pt.matrixTransform(this.canvas.getScreenCTM().inverse());
            }
            // reset temporary edge position to <(0,0),(0,0)>
            var tempLine = document.getElementById("temporary-wire");
            tempLine.setAttribute('x1', '0');
            tempLine.setAttribute('y1', '0');
            tempLine.setAttribute('x2', '0');
            tempLine.setAttribute('y2', '0');
            try {
                // go through all of the nodes' input/output ports
                for (var _c = __values(this.data.nodes), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var n = _d.value;
                    var pPos;
                    // find the node's corresponding port and its position
                    if (this.startType == 'input') {
                        if (this.edge.target.parentNode == n || n.type == 'end')
                            continue;
                        this.edge.source = n.output;
                        pPos = [n.position.x + this.outputOffset[0], n.position.y + this.outputOffset[1]];
                    }
                    else {
                        if (this.edge.source.parentNode == n || n.type == 'start')
                            continue;
                        this.edge.target = n.input;
                        pPos = [n.position.x + this.inputOffset[0], n.position.y + this.inputOffset[1]];
                    }
                    // if the distance between the port's position and the dropped position is bigger than 15px, continue
                    if (Math.abs(pPos[0] - svgP.x) > 25 || Math.abs(pPos[1] - svgP.y) > 25)
                        continue;
                    try {
                        // if there is already an existing edge with the same source and target as the new edge, return
                        for (var _e = __values(this.data.edges), _f = _e.next(); !_f.done; _f = _e.next()) {
                            var edge = _f.value;
                            if (edge.target == this.edge.target && edge.source == this.edge.source) {
                                this.isDown = 0;
                                return;
                            }
                        }
                    }
                    catch (e_5_1) { e_5 = { error: e_5_1 }; }
                    finally {
                        try {
                            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                        }
                        finally { if (e_5) throw e_5.error; }
                    }
                    this.edge.target.edges.push(this.edge);
                    this.edge.source.edges.push(this.edge);
                    this.data.edges.push(this.edge);
                    this.data.ordered = false;
                    break;
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_4) throw e_4.error; }
            }
        }
        this.isDown = 0;
    };
    __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(),
        __metadata("design:type", Object)
    ], FlowchartComponent.prototype, "data", void 0);
    __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"])(),
        __metadata("design:type", Object)
    ], FlowchartComponent.prototype, "switch", void 0);
    FlowchartComponent = __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"])({
            selector: 'flowchart',
            template: __webpack_require__(/*! ./flowchart.component.html */ "./src/app/ngFlowchart-svg/flowchart.component.html"),
            styles: [__webpack_require__(/*! ./flowchart.component.scss */ "./src/app/ngFlowchart-svg/flowchart.component.scss")]
        })
    ], FlowchartComponent);
    return FlowchartComponent;
}());



/***/ }),

/***/ "./src/app/ngFlowchart-svg/flowchart.module.ts":
/*!*****************************************************!*\
  !*** ./src/app/ngFlowchart-svg/flowchart.module.ts ***!
  \*****************************************************/
/*! exports provided: SVGFlowchartModule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SVGFlowchartModule", function() { return SVGFlowchartModule; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm5/common.js");
/* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/forms */ "./node_modules/@angular/forms/fesm5/forms.js");
/* harmony import */ var _angular_material__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/material */ "./node_modules/@angular/material/esm5/material.es5.js");
/* harmony import */ var _flowchart_component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./flowchart.component */ "./src/app/ngFlowchart-svg/flowchart.component.ts");
/* harmony import */ var _node_node_component__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./node/node.component */ "./src/app/ngFlowchart-svg/node/node.component.ts");
/* harmony import */ var _edge_edge_component__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./edge/edge.component */ "./src/app/ngFlowchart-svg/edge/edge.component.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};







var SVGFlowchartModule = /** @class */ (function () {
    function SVGFlowchartModule() {
    }
    SVGFlowchartModule = __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"])({
            declarations: [
                _flowchart_component__WEBPACK_IMPORTED_MODULE_4__["FlowchartComponent"],
                _node_node_component__WEBPACK_IMPORTED_MODULE_5__["NodeComponent"],
                _edge_edge_component__WEBPACK_IMPORTED_MODULE_6__["EdgeComponent"],
            ],
            exports: [_flowchart_component__WEBPACK_IMPORTED_MODULE_4__["FlowchartComponent"]],
            imports: [_angular_common__WEBPACK_IMPORTED_MODULE_1__["CommonModule"],
                _angular_forms__WEBPACK_IMPORTED_MODULE_2__["FormsModule"],
                _angular_material__WEBPACK_IMPORTED_MODULE_3__["MatIconModule"],
                _angular_material__WEBPACK_IMPORTED_MODULE_3__["MatButtonModule"]],
            entryComponents: [],
            providers: []
        }),
        __metadata("design:paramtypes", [])
    ], SVGFlowchartModule);
    return SVGFlowchartModule;
}());



/***/ }),

/***/ "./src/app/ngFlowchart-svg/index.ts":
/*!******************************************!*\
  !*** ./src/app/ngFlowchart-svg/index.ts ***!
  \******************************************/
/*! exports provided: SVGFlowchartModule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _flowchart_module__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./flowchart.module */ "./src/app/ngFlowchart-svg/flowchart.module.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SVGFlowchartModule", function() { return _flowchart_module__WEBPACK_IMPORTED_MODULE_0__["SVGFlowchartModule"]; });




/***/ }),

/***/ "./src/app/ngFlowchart-svg/node/node.actions.ts":
/*!******************************************************!*\
  !*** ./src/app/ngFlowchart-svg/node/node.actions.ts ***!
  \******************************************************/
/*! exports provided: ACTIONS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ACTIONS", function() { return ACTIONS; });
var ACTIONS;
(function (ACTIONS) {
    ACTIONS[ACTIONS["SELECT"] = 0] = "SELECT";
    ACTIONS[ACTIONS["DELETE"] = 1] = "DELETE";
    ACTIONS[ACTIONS["COPY"] = 2] = "COPY";
    ACTIONS[ACTIONS["CONNECT"] = 3] = "CONNECT";
    ACTIONS[ACTIONS["DRAGNODE"] = 4] = "DRAGNODE";
    ACTIONS[ACTIONS["DROPPORT"] = 5] = "DROPPORT";
    ACTIONS[ACTIONS["DRAGPORT"] = 6] = "DRAGPORT";
    ACTIONS[ACTIONS["PROCEDURE"] = 7] = "PROCEDURE";
})(ACTIONS || (ACTIONS = {}));


/***/ }),

/***/ "./src/app/ngFlowchart-svg/node/node.component.html":
/*!**********************************************************!*\
  !*** ./src/app/ngFlowchart-svg/node/node.component.html ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<!-- svg group for the selectable and draggable area of normal node -->\r\n<svg:g (click)='nodeSelect($event)' draggable=\"true\" \r\n(mousedown)='startDragNode($event)' \r\n(dblclick)='switchToProcedure($event)'\r\n*ngIf='node.type==\"\"'>\r\n\r\n    <!-- rectangular box with border -->\r\n    <rect class=\"node\" \r\n    width=\"100\" height=\"80\"\r\n    [class.node--selected]='selected'\r\n    [class.node--error]=\"node.hasError\"\r\n    [attr.x]=\"node.position.x\" \r\n    [attr.y]=\"node.position.y\"\r\n    />\r\n\r\n    <!-- node description inside the rectangular box -->\r\n    <svg:foreignObject [attr.x]=\"node.position.x\" [attr.y]=\"node.position.y + 3\" \r\n    width=\"100\" height = \"80\"\r\n    (mousedown)='focusText($event)'>\r\n        <xhtml:div class='textdiv'>\r\n            <xhtml:textarea \r\n                id={{node.id}}\r\n                autocomplete=off \r\n                [(ngModel)]='node.name'\r\n                [class.selected]='selected'\r\n                title={{node.name}}\r\n                style=\"font-weight: 600;\"\r\n                placeholder='Description of Node'/>  \r\n        </xhtml:div>\r\n    </svg:foreignObject>\r\n</svg:g>\r\n\r\n<!-- svg group for the selectable and draggable area of start node -->\r\n<svg:g (click)='nodeSelect($event)' draggable=\"true\" \r\n(mousedown)='startDragNode($event)' \r\n(dblclick)='switchToProcedure($event)'\r\n*ngIf='node.type==\"start\"'>\r\n\r\n    <!-- ellipse with border -->\r\n    <ellipse class=\"node\" \r\n        [class.node--selected]='selected'\r\n        [class.node--error]=\"node.hasError\"\r\n        [attr.cx]=\"node.position.x + inputOffset[0]\" \r\n        [attr.cy]=\"node.position.y + (inputOffset[1]+outputOffset[1])/2 + 10\"\r\n        [attr.rx]=\"40\"\r\n        [attr.ry]=\"30\"\r\n        />\r\n\r\n    <!-- node description inside the ellipse -->\r\n    <svg:foreignObject \r\n    [attr.x]=\"node.position.x\" [attr.y]=\"node.position.y + 38\" \r\n    width=\"100\" height = \"40\">\r\n        <xhtml:div class='textdiv'>\r\n            <xhtml:textarea \r\n                id={{node.id}}\r\n                class='textarea_startend'\r\n                autocomplete=off \r\n                [class.selected]='selected'\r\n                [(ngModel)]='node.name'/>  \r\n        </xhtml:div>\r\n    </svg:foreignObject>\r\n</svg:g>\r\n\r\n<!-- svg group for the selectable and draggable area of end node -->\r\n<svg:g (click)='nodeSelect($event)' draggable=\"true\" \r\n(mousedown)='startDragNode($event)' \r\n(dblclick)='switchToProcedure($event)'\r\n*ngIf='node.type==\"end\"'>\r\n\r\n    <!-- ellipse with border -->\r\n    <ellipse class=\"node\" \r\n        [class.node--selected]='selected'\r\n        [class.node--error]=\"node.hasError\"\r\n        [attr.cx]=\"node.position.x + inputOffset[0]\" \r\n        [attr.cy]=\"node.position.y + (inputOffset[1]+outputOffset[1])/2 - 10\"\r\n        [attr.rx]=\"40\"\r\n        [attr.ry]=\"30\"\r\n        />\r\n\r\n    <!-- node description inside the ellipse -->\r\n    <svg:foreignObject [attr.x]=\"node.position.x\" [attr.y]=\"node.position.y + 18\" \r\n    width=\"100\" height = \"40\">\r\n        <xhtml:div class='textdiv'>\r\n            <xhtml:textarea \r\n                id={{node.id}}\r\n                class='textarea_startend'\r\n                autocomplete=off \r\n                [class.selected]='selected'\r\n                [(ngModel)]='node.name'/>  \r\n        </xhtml:div>\r\n    </svg:foreignObject>\r\n</svg:g>\r\n\r\n\r\n\r\n<!-- circles as draggable input/output ports of the node -->\r\n<svg:circle\r\nr=3\r\n[attr.cx]=\"node.position.x + inputOffset[0]\" \r\n[attr.cy]=\"node.position.y + inputOffset[1]\"\r\n*ngIf=\"inputDraggable()\" \r\nclass='inputPort'\r\nid = 'node.input.id'\r\n(mousedown)='startDragPort($event, \"input\")'/>\r\n\r\n<svg:circle *ngIf=\"outputDraggable()\" \r\nclass='outputPort'\r\nid = 'node.output.id'\r\n(mousedown)='startDragPort($event, \"output\")' \r\n[attr.cx]=\"node.position.x + outputOffset[0]\" \r\n[attr.cy]=\"node.position.y + outputOffset[1]\" \r\npointer-events=\"all\"\r\nr=3\r\nfill=\"black\"/>\r\n\r\n"

/***/ }),

/***/ "./src/app/ngFlowchart-svg/node/node.component.scss":
/*!**********************************************************!*\
  !*** ./src/app/ngFlowchart-svg/node/node.component.scss ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "/*\r\n$color-main: #2D4885;\r\n$color-accent: #50ABB9;\r\n$color-muted: #88D4DD;\r\n$color-text-accent: #DC772F;\r\n*/\n.node {\n  fill: #fafafa;\n  stroke-width: 2px;\n  stroke: #505050;\n  stroke-opacity: 1;\n  stroke-linecap: round;\n  stroke-linejoin: round; }\n.node.node--disabled {\n    stroke: #505050;\n    stroke-opacity: 0.5;\n    fill-opacity: 0.5; }\n.node.node--selected {\n    stroke: #000096; }\n.node.node--error {\n    stroke: red; }\n.textdiv {\n  text-align: center;\n  width: 94px; }\n.foreignObject {\n  width: 100;\n  height: 80; }\ntextarea {\n  font-family: sans-serif;\n  background: transparent;\n  display: inline-block;\n  border: none;\n  font-size: 14px;\n  width: 100%;\n  height: 70px;\n  font-weight: 600;\n  text-align: center;\n  vertical-align: middle;\n  resize: none;\n  overflow: hidden;\n  color: #505050; }\ntextarea.selected {\n    color: #000096; }\n.textarea_startend {\n  font-size: 14px;\n  font-weight: 600;\n  color: #505050;\n  height: 20px;\n  pointer-events: none; }\n.inputPort {\n  stroke: transparent;\n  stroke-width: 20px;\n  pointer-events: all;\n  fill: #505050; }\n.outputPort {\n  stroke: transparent;\n  stroke-width: 20px;\n  pointer-events: all;\n  fill: #505050; }\n"

/***/ }),

/***/ "./src/app/ngFlowchart-svg/node/node.component.ts":
/*!********************************************************!*\
  !*** ./src/app/ngFlowchart-svg/node/node.component.ts ***!
  \********************************************************/
/*! exports provided: NodeComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NodeComponent", function() { return NodeComponent; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var _node_actions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node.actions */ "./src/app/ngFlowchart-svg/node/node.actions.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


var NodeComponent = /** @class */ (function () {
    function NodeComponent() {
        this.action = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.last = [0, 0];
        this.isDown = false;
    }
    /*
    update the position of the node
    */
    NodeComponent.prototype.updatePosition = function (position) {
        this.node.position = position;
    };
    ;
    /*
    select a node
    */
    NodeComponent.prototype.nodeSelect = function (event) {
        this.action.emit({ action: _node_actions__WEBPACK_IMPORTED_MODULE_1__["ACTIONS"].SELECT });
    };
    ;
    /*
    check if the input port of the node is draggable --> false only for start node, true otherwise
    */
    NodeComponent.prototype.inputDraggable = function () {
        return !(this.node.type == 'start');
    };
    /*
    check if the output port of the node is draggable --> false only for end node, true otherwise
    */
    NodeComponent.prototype.outputDraggable = function () {
        return !(this.node.type == 'end');
    };
    /*
    initiate dragging node when mousedown inside the node group
    */
    NodeComponent.prototype.startDragNode = function (event) {
        event.preventDefault();
        event.stopPropagation();
        this.action.emit({ action: _node_actions__WEBPACK_IMPORTED_MODULE_1__["ACTIONS"].DRAGNODE, data: event });
    };
    /*
    initiate dragging port when mousedown inside the port (inside the invisible stroke of the port)
    */
    NodeComponent.prototype.startDragPort = function (event, portType) {
        event.preventDefault();
        event.stopPropagation();
        var pos = this.node.position;
        var data;
        if (portType == 'input') {
            data = this.node.input;
            pos = [pos.x + this.inputOffset[0], pos.y + this.inputOffset[1]];
        }
        else {
            data = this.node.output;
            pos = [pos.x + this.outputOffset[0], pos.y + this.outputOffset[1]];
        }
        this.action.emit({ action: _node_actions__WEBPACK_IMPORTED_MODULE_1__["ACTIONS"].DRAGPORT, data: data, position: pos, type: portType });
    };
    /*
    focus on the description of the node when mouse down inside the node
    ** no stopPropagation to allow propagation to startDragNode --> node can still be dragged
    */
    NodeComponent.prototype.focusText = function (event) {
        document.getElementById(this.node.id).focus();
    };
    /*
    switch the viewchild of the appModule to the node's procedure view when double-click on the node
    */
    NodeComponent.prototype.switchToProcedure = function (event) {
        this.action.emit({ action: _node_actions__WEBPACK_IMPORTED_MODULE_1__["ACTIONS"].PROCEDURE });
    };
    __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(),
        __metadata("design:type", Object)
    ], NodeComponent.prototype, "node", void 0);
    __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(),
        __metadata("design:type", Boolean)
    ], NodeComponent.prototype, "selected", void 0);
    __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(),
        __metadata("design:type", Object)
    ], NodeComponent.prototype, "inputOffset", void 0);
    __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(),
        __metadata("design:type", Object)
    ], NodeComponent.prototype, "outputOffset", void 0);
    __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"])(),
        __metadata("design:type", Object)
    ], NodeComponent.prototype, "action", void 0);
    NodeComponent = __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"])({
            selector: '[node]',
            template: __webpack_require__(/*! ./node.component.html */ "./src/app/ngFlowchart-svg/node/node.component.html"),
            styles: [__webpack_require__(/*! ./node.component.scss */ "./src/app/ngFlowchart-svg/node/node.component.scss")]
        })
    ], NodeComponent);
    return NodeComponent;
}());



/***/ }),

/***/ "./src/app/shared/components/add-components/add_input.component.ts":
/*!*************************************************************************!*\
  !*** ./src/app/shared/components/add-components/add_input.component.ts ***!
  \*************************************************************************/
/*! exports provided: AddInputComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AddInputComponent", function() { return AddInputComponent; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

var AddInputComponent = /** @class */ (function () {
    function AddInputComponent() {
    }
    AddInputComponent.prototype.addInput = function () {
        return;
        /*
        let newPort = PortUtils.getNewInput();
        newPort.parentNode = this.node;
        this.node.input.push(newPort);
        */
    };
    __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(),
        __metadata("design:type", Object)
    ], AddInputComponent.prototype, "node", void 0);
    AddInputComponent = __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"])({
            selector: 'add-input',
            template: "<button (click)='addInput()'>AddInput</button>",
            styles: []
        }),
        __metadata("design:paramtypes", [])
    ], AddInputComponent);
    return AddInputComponent;
}());



/***/ }),

/***/ "./src/app/shared/components/add-components/add_node.component.ts":
/*!************************************************************************!*\
  !*** ./src/app/shared/components/add-components/add_node.component.ts ***!
  \************************************************************************/
/*! exports provided: AddNodeComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AddNodeComponent", function() { return AddNodeComponent; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var _models_node__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @models/node */ "./src/app/shared/models/node/index.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


var AddNodeComponent = /** @class */ (function () {
    function AddNodeComponent() {
    }
    AddNodeComponent.prototype.addNode = function () { this.flowchart.nodes.push(_models_node__WEBPACK_IMPORTED_MODULE_1__["NodeUtils"].getNewNode()); };
    __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(),
        __metadata("design:type", Object)
    ], AddNodeComponent.prototype, "flowchart", void 0);
    AddNodeComponent = __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"])({
            selector: 'add-node',
            template: "<button (click)='addNode()'>AddNode</button>",
            styles: []
        }),
        __metadata("design:paramtypes", [])
    ], AddNodeComponent);
    return AddNodeComponent;
}());



/***/ }),

/***/ "./src/app/shared/components/add-components/add_output.component.ts":
/*!**************************************************************************!*\
  !*** ./src/app/shared/components/add-components/add_output.component.ts ***!
  \**************************************************************************/
/*! exports provided: AddOutputComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AddOutputComponent", function() { return AddOutputComponent; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

var AddOutputComponent = /** @class */ (function () {
    function AddOutputComponent() {
    }
    AddOutputComponent.prototype.addOutput = function () {
        return;
        /*
        let newPort = PortUtils.getNewOutput();
        newPort.parentNode = this.node;
        this.node.output.push(newPort);
        */
    };
    __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(),
        __metadata("design:type", Object)
    ], AddOutputComponent.prototype, "node", void 0);
    AddOutputComponent = __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"])({
            selector: 'add-output',
            template: "<button (click)='addOutput()'>AddOutput</button>",
            styles: []
        }),
        __metadata("design:paramtypes", [])
    ], AddOutputComponent);
    return AddOutputComponent;
}());



/***/ }),

/***/ "./src/app/shared/components/execute/execute.component.ts":
/*!****************************************************************!*\
  !*** ./src/app/shared/components/execute/execute.component.ts ***!
  \****************************************************************/
/*! exports provided: ExecuteComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ExecuteComponent", function() { return ExecuteComponent; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var _models_flowchart__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @models/flowchart */ "./src/app/shared/models/flowchart/index.ts");
/* harmony import */ var _models_code__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @models/code */ "./src/app/shared/models/code/index.ts");
/* harmony import */ var _modules__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @modules */ "./src/app/core/modules/index.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (undefined && undefined.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};




var ExecuteComponent = /** @class */ (function () {
    function ExecuteComponent() {
    }
    ExecuteComponent.prototype.execute = function () {
        return __awaiter(this, void 0, void 0, function () {
            var e_1, _a, e_2, _b, e_3, _c, _d, _e, node, funcStrings, _f, _g, func, _h, _j, e_2_1, _k, _l, node, e_3_1;
            return __generator(this, function (_m) {
                switch (_m.label) {
                    case 0:
                        this.globalVars = '';
                        try {
                            // reset input of all nodes except start
                            for (_d = __values(this.flowchart.nodes), _e = _d.next(); !_e.done; _e = _d.next()) {
                                node = _e.value;
                                if (node.type != 'start') {
                                    if (node.input.edges) {
                                        node.input.value = undefined;
                                    }
                                }
                            }
                        }
                        catch (e_1_1) { e_1 = { error: e_1_1 }; }
                        finally {
                            try {
                                if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
                            }
                            finally { if (e_1) throw e_1.error; }
                        }
                        // order the flowchart
                        if (!this.flowchart.ordered) {
                            _models_flowchart__WEBPACK_IMPORTED_MODULE_1__["FlowchartUtils"].orderNodes(this.flowchart);
                        }
                        funcStrings = {};
                        _m.label = 1;
                    case 1:
                        _m.trys.push([1, 6, 7, 8]);
                        _f = __values(this.flowchart.functions), _g = _f.next();
                        _m.label = 2;
                    case 2:
                        if (!!_g.done) return [3 /*break*/, 5];
                        func = _g.value;
                        _h = funcStrings;
                        _j = func.name;
                        return [4 /*yield*/, _models_code__WEBPACK_IMPORTED_MODULE_2__["CodeUtils"].getFunctionString(func)];
                    case 3:
                        _h[_j] = _m.sent();
                        _m.label = 4;
                    case 4:
                        _g = _f.next();
                        return [3 /*break*/, 2];
                    case 5: return [3 /*break*/, 8];
                    case 6:
                        e_2_1 = _m.sent();
                        e_2 = { error: e_2_1 };
                        return [3 /*break*/, 8];
                    case 7:
                        try {
                            if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
                        }
                        finally { if (e_2) throw e_2.error; }
                        return [7 /*endfinally*/];
                    case 8:
                        _m.trys.push([8, 13, 14, 15]);
                        _k = __values(this.flowchart.nodes), _l = _k.next();
                        _m.label = 9;
                    case 9:
                        if (!!_l.done) return [3 /*break*/, 12];
                        node = _l.value;
                        if (!node.enabled) {
                            node.output.value = undefined;
                            return [3 /*break*/, 11];
                        }
                        return [4 /*yield*/, this.executeNode(node, funcStrings)];
                    case 10:
                        _m.sent();
                        _m.label = 11;
                    case 11:
                        _l = _k.next();
                        return [3 /*break*/, 9];
                    case 12: return [3 /*break*/, 15];
                    case 13:
                        e_3_1 = _m.sent();
                        e_3 = { error: e_3_1 };
                        return [3 /*break*/, 15];
                    case 14:
                        try {
                            if (_l && !_l.done && (_c = _k.return)) _c.call(_k);
                        }
                        finally { if (e_3) throw e_3.error; }
                        return [7 /*endfinally*/];
                    case 15: return [2 /*return*/];
                }
            });
        });
    };
    ExecuteComponent.prototype.executeNode = function (node, funcStrings) {
        return __awaiter(this, void 0, void 0, function () {
            var params, fnString, hasFunctions, funcName, mergeString, fn, result, constant, ex_1, prodWithError_1, markError_1, error;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        params = { "currentProcedure": [''] };
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, _models_code__WEBPACK_IMPORTED_MODULE_2__["CodeUtils"].getNodeCode(node, true)];
                    case 2:
                        fnString = _a.sent();
                        // add the constants from the start node
                        fnString = this.globalVars + fnString;
                        params["model"] = node.input.value;
                        hasFunctions = false;
                        for (funcName in funcStrings) {
                            fnString = funcStrings[funcName] + fnString;
                            hasFunctions = true;
                        }
                        if (hasFunctions) {
                            mergeString = _models_code__WEBPACK_IMPORTED_MODULE_2__["CodeUtils"].mergeInputs.toString();
                            fnString = 'function mergeInputs' + mergeString.substring(9, mergeString.length) + '\n\n' + fnString;
                        }
                        console.log("/*    " + node.name.toUpperCase() + "    */\n\n" + fnString);
                        fn = new Function('__modules__', '__params__', fnString);
                        result = fn(_modules__WEBPACK_IMPORTED_MODULE_3__, params);
                        node.output.value = result;
                        if (node.type == 'start') {
                            for (constant in params["constants"]) {
                                this.globalVars += "const " + constant + " = " + params["constants"][constant] + ";\n";
                            }
                            this.globalVars += '\n';
                        }
                        return [3 /*break*/, 4];
                    case 3:
                        ex_1 = _a.sent();
                        node.hasError = true;
                        prodWithError_1 = params["currentProcedure"][0];
                        markError_1 = function (prod, id) {
                            if (prod["ID"] && id && prod["ID"] == id) {
                                prod.hasError = true;
                            }
                            if (prod.hasOwnProperty('children')) {
                                prod.children.map(function (p) {
                                    markError_1(p, id);
                                });
                            }
                        };
                        if (prodWithError_1 != '') {
                            node.procedure.map(function (prod) {
                                if (prod["ID"] == prodWithError_1) {
                                    prod.hasError = true;
                                }
                                if (prod.hasOwnProperty('children')) {
                                    prod.children.map(function (p) {
                                        markError_1(p, prodWithError_1);
                                    });
                                }
                            });
                        }
                        error = void 0;
                        if (ex_1.toString().indexOf("Unexpected identifier") > -1) {
                            error = new Error("Unexpected Identifier error. Did you declare everything? Check that your strings are enclosed in quotes (\")");
                        }
                        else if (ex_1.toString().indexOf("Unexpected token") > -1) {
                            error = new Error("Unexpected token error. Check for stray spaces or reserved keywords?");
                        }
                        else {
                            error = new Error(ex_1);
                        }
                        throw error;
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(),
        __metadata("design:type", Object)
    ], ExecuteComponent.prototype, "flowchart", void 0);
    ExecuteComponent = __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"])({
            selector: 'execute',
            /*
            template: `<button class="btn--execute"
                              (click)="execute()">
                          Execute
                       </button>`,
              */
            template: "<button class=\"btn\" mat-icon-button title=\"Execute\" (click)=\"execute()\">\n    <mat-icon>play_circle_outline</mat-icon>\n    </button>\n    ",
            styles: [
                ".btn--execute{ \n                display: inline-block;\n                vertical-align: middle;\n                font-size: 14px;\n                line-height: 18px;\n                border: 3px solid #E0C229;\n                border-radius: 4px;\n                padding: 1px 10px;\n                background-color: #E0C229; \n                color: #494D59;\n                font-weight: 600;\n                text-transform: uppercase;\n              }\n              .btn{\n                vertical-align: middle;\n                background-color: transparent; \n                border: none;\n                color: rgb(80,80,80);\n              }\n              .btn:hover{\n                color: blue;\n              }"
            ]
        })
    ], ExecuteComponent);
    return ExecuteComponent;
}());



/***/ }),

/***/ "./src/app/shared/components/file/download.utils.ts":
/*!**********************************************************!*\
  !*** ./src/app/shared/components/file/download.utils.ts ***!
  \**********************************************************/
/*! exports provided: downloadUtils */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "downloadUtils", function() { return downloadUtils; });
var downloadUtils = /** @class */ (function () {
    function downloadUtils() {
    }
    downloadUtils.downloadFile = function (fileName, fileContent) {
        if (window.navigator.msSaveOrOpenBlob) {
            window.navigator.msSaveOrOpenBlob(fileContent, fileName);
        }
        else {
            var a_1 = document.createElement('a');
            document.body.appendChild(a_1);
            var url_1 = window.URL.createObjectURL(fileContent);
            a_1.href = url_1;
            a_1.download = fileName;
            a_1.click();
            setTimeout(function () {
                window.URL.revokeObjectURL(url_1);
                document.body.removeChild(a_1);
            }, 0);
        }
    };
    return downloadUtils;
}());



/***/ }),

/***/ "./src/app/shared/components/file/index.ts":
/*!*************************************************!*\
  !*** ./src/app/shared/components/file/index.ts ***!
  \*************************************************/
/*! exports provided: SaveFileComponent, LoadFileComponent, NewFileComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _savefile_component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./savefile.component */ "./src/app/shared/components/file/savefile.component.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SaveFileComponent", function() { return _savefile_component__WEBPACK_IMPORTED_MODULE_0__["SaveFileComponent"]; });

/* harmony import */ var _loadfile_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./loadfile.component */ "./src/app/shared/components/file/loadfile.component.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LoadFileComponent", function() { return _loadfile_component__WEBPACK_IMPORTED_MODULE_1__["LoadFileComponent"]; });

/* harmony import */ var _newfile_component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./newfile.component */ "./src/app/shared/components/file/newfile.component.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "NewFileComponent", function() { return _newfile_component__WEBPACK_IMPORTED_MODULE_2__["NewFileComponent"]; });






/***/ }),

/***/ "./src/app/shared/components/file/loadfile.component.ts":
/*!**************************************************************!*\
  !*** ./src/app/shared/components/file/loadfile.component.ts ***!
  \**************************************************************/
/*! exports provided: LoadFileComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoadFileComponent", function() { return LoadFileComponent; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm5/index.js");
/* harmony import */ var circular_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! circular-json */ "./node_modules/circular-json/build/circular-json.node.js");
/* harmony import */ var circular_json__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(circular_json__WEBPACK_IMPORTED_MODULE_2__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



var LoadFileComponent = /** @class */ (function () {
    function LoadFileComponent() {
        this.loaded = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        //   @ViewChild('fileInput') fileInput: ElementRef;
        //   openPicker(): void{
        //     let el: HTMLElement = this.fileInput.nativeElement as HTMLElement;
        //     el.click();
        //   }
        //   loadFile(url ?:string): void{
        //     let file = this.fileInput.nativeElement.files[0];
        //     if (file) {
        //         var reader = new FileReader();
        //         reader.readAsText(file, "UTF-8");
        //         let fs = this.flowchartService;
        //         reader.onload = function (evt) {
        //           let fileString: string = evt.target["result"];
        //           fs.loadFile(fileString);
        //         }
        //         reader.onerror = function (evt) {
        //             console.log("Error reading file");
        //         }
        //     }
        // this.flowchartService.loadFile(url);
    }
    LoadFileComponent.prototype.sendloadfile = function () {
        var _this = this;
        var selectedFile = document.getElementById('file-input').files[0];
        var stream = rxjs__WEBPACK_IMPORTED_MODULE_1__["Observable"].create(function (observer) {
            var reader = new FileReader();
            reader.onloadend = function () {
                //if (typeof reader.result === 'string') {}
                var f = circular_json__WEBPACK_IMPORTED_MODULE_2__["parse"](reader.result);
                var file = {
                    name: f.name,
                    author: f.author,
                    flowchart: f.flowchart,
                    last_updated: f.last_updated,
                    version: f.version
                };
                observer.next(file);
                observer.complete();
            };
            reader.readAsText(selectedFile);
        });
        stream.subscribe(function (loadeddata) {
            _this.loaded.emit(circular_json__WEBPACK_IMPORTED_MODULE_2__["stringify"](loadeddata));
        });
        document.getElementById('file-input').value = "";
    };
    __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"])(),
        __metadata("design:type", Object)
    ], LoadFileComponent.prototype, "loaded", void 0);
    LoadFileComponent = __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"])({
            selector: 'file-load',
            template: "<button id='loadfile' class='btn' onclick=\"document.getElementById('file-input').click();\">Load</button>\n              <input id=\"file-input\" type=\"file\" name=\"name\" (change)=\"sendloadfile()\" style=\" display: none;\" />",
            styles: [
                "            \n            button.btn{ \n                margin: 0px 0px 0px 0px;\n                font-size: 10px;\n                line-height: 12px;\n                border: 2px solid gray;\n                border-radius: 4px;\n                padding: 2px 5px;\n                background-color: #3F4651; \n                color: #E7BF00;\n                font-weight: 600;\n                text-transform: uppercase;\n             }\n            button.btn:hover{\n                background-color: gray;\n                color: white;\n            }\n\n             "
            ]
        })
    ], LoadFileComponent);
    return LoadFileComponent;
}());



/***/ }),

/***/ "./src/app/shared/components/file/newfile.component.ts":
/*!*************************************************************!*\
  !*** ./src/app/shared/components/file/newfile.component.ts ***!
  \*************************************************************/
/*! exports provided: NewFileComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NewFileComponent", function() { return NewFileComponent; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var _models_flowchart__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @models/flowchart */ "./src/app/shared/models/flowchart/index.ts");
/* harmony import */ var circular_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! circular-json */ "./node_modules/circular-json/build/circular-json.node.js");
/* harmony import */ var circular_json__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(circular_json__WEBPACK_IMPORTED_MODULE_2__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



var NewFileComponent = /** @class */ (function () {
    function NewFileComponent(cdr) {
        this.cdr = cdr;
        this.create = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
    }
    NewFileComponent.prototype.sendNewFile = function () {
        var confirmed = confirm("Resetting would delete the current flowchart. Would you like to continue?");
        if (!confirmed)
            return;
        var file = {
            name: "default_file.mob",
            author: "new_user",
            flowchart: _models_flowchart__WEBPACK_IMPORTED_MODULE_1__["FlowchartUtils"].newflowchart(),
            last_updated: new Date(),
            version: 1
        };
        this.create.emit(circular_json__WEBPACK_IMPORTED_MODULE_2__["stringify"](file));
        this.cdr.detectChanges();
    };
    __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"])(),
        __metadata("design:type", Object)
    ], NewFileComponent.prototype, "create", void 0);
    NewFileComponent = __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"])({
            selector: 'file-new',
            template: "<button id='newfile' class='btn' (click)='sendNewFile()'>New</button>",
            styles: [
                "\n            button.btn{ \n                margin: 0px 0px 0px 0px;\n                font-size: 10px;\n                line-height: 12px;\n                border: 2px solid gray;\n                border-radius: 4px;\n                padding: 2px 5px;\n                background-color: #3F4651; \n                color: #E7BF00;\n                font-weight: 600;\n                text-transform: uppercase;\n            }\n            button.btn:hover{\n                background-color: gray;\n                color: white;\n            }\n             "
            ]
        }),
        __metadata("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ChangeDetectorRef"]])
    ], NewFileComponent);
    return NewFileComponent;
}());



/***/ }),

/***/ "./src/app/shared/components/file/savefile.component.ts":
/*!**************************************************************!*\
  !*** ./src/app/shared/components/file/savefile.component.ts ***!
  \**************************************************************/
/*! exports provided: SaveFileComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SaveFileComponent", function() { return SaveFileComponent; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var _download_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./download.utils */ "./src/app/shared/components/file/download.utils.ts");
/* harmony import */ var circular_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! circular-json */ "./node_modules/circular-json/build/circular-json.node.js");
/* harmony import */ var circular_json__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(circular_json__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _models_flowchart__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @models/flowchart */ "./src/app/shared/models/flowchart/index.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __values = (undefined && undefined.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};




var SaveFileComponent = /** @class */ (function () {
    function SaveFileComponent() {
    }
    // todo: save file
    SaveFileComponent.prototype.download = function () {
        var e_1, _a, e_2, _b, e_3, _c, e_4, _d;
        if (!this.file.flowchart.ordered) {
            _models_flowchart__WEBPACK_IMPORTED_MODULE_3__["FlowchartUtils"].orderNodes(this.file.flowchart);
        }
        var savedfile = circular_json__WEBPACK_IMPORTED_MODULE_2__["parse"](circular_json__WEBPACK_IMPORTED_MODULE_2__["stringify"](this.file));
        try {
            for (var _e = __values(savedfile.flowchart.nodes), _f = _e.next(); !_f.done; _f = _e.next()) {
                var node = _f.value;
                if (node.input.hasOwnProperty('value')) {
                    node.input.value = undefined;
                }
                if (node.output.hasOwnProperty('value')) {
                    node.output.value = undefined;
                }
                try {
                    for (var _g = __values(node.state.procedure), _h = _g.next(); !_h.done; _h = _g.next()) {
                        var prod = _h.value;
                        prod.selected = false;
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_h && !_h.done && (_b = _g.return)) _b.call(_g);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
                node.state.procedure = [];
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_f && !_f.done && (_a = _e.return)) _a.call(_e);
            }
            finally { if (e_1) throw e_1.error; }
        }
        try {
            // **** need to modify this when changing the input's constant function: 
            // **** this part resets the value of the last argument of the function when saving the file
            for (var _j = __values(savedfile.flowchart.nodes[0].procedure), _k = _j.next(); !_k.done; _k = _j.next()) {
                var prod = _k.value;
                prod.args[prod.argCount - 1].value = undefined;
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_k && !_k.done && (_c = _j.return)) _c.call(_j);
            }
            finally { if (e_3) throw e_3.error; }
        }
        savedfile.flowchart.meta.selected_nodes = [0];
        try {
            for (var _l = __values(savedfile.flowchart.edges), _m = _l.next(); !_m.done; _m = _l.next()) {
                var edge = _m.value;
                edge.selected = false;
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_m && !_m.done && (_d = _l.return)) _d.call(_l);
            }
            finally { if (e_4) throw e_4.error; }
        }
        savedfile.name = savedfile.flowchart.name;
        var fileString = circular_json__WEBPACK_IMPORTED_MODULE_2__["stringify"](savedfile);
        var fname = savedfile.flowchart.name.replace(/\ /g, '_') + ".mob";
        var blob = new Blob([fileString], { type: 'application/json' });
        _download_utils__WEBPACK_IMPORTED_MODULE_1__["downloadUtils"].downloadFile(fname, blob);
    };
    __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(),
        __metadata("design:type", Object)
    ], SaveFileComponent.prototype, "file", void 0);
    SaveFileComponent = __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"])({
            selector: 'file-save',
            template: "<button id='savefile' class='btn' (click)='download()'>Save</button>",
            styles: [
                "\n            button.btn{ \n                margin: 0px 0px 0px 0px;\n                font-size: 10px;\n                line-height: 12px;\n                border: 2px solid gray;\n                border-radius: 4px;\n                padding: 2px 5px;\n                background-color: #3F4651; \n                color: #E7BF00;\n                font-weight: 600;\n                text-transform: uppercase;\n             }\n            button.btn:hover{\n                background-color: gray;\n                color: white;\n            }\n             "
            ]
        })
    ], SaveFileComponent);
    return SaveFileComponent;
}());



/***/ }),

/***/ "./src/app/shared/components/header/header.component.ts":
/*!**************************************************************!*\
  !*** ./src/app/shared/components/header/header.component.ts ***!
  \**************************************************************/
/*! exports provided: HeaderComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HeaderComponent", function() { return HeaderComponent; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

var HeaderComponent = /** @class */ (function () {
    function HeaderComponent() {
    }
    __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(),
        __metadata("design:type", Object)
    ], HeaderComponent.prototype, "node", void 0);
    __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(),
        __metadata("design:type", String)
    ], HeaderComponent.prototype, "title", void 0);
    HeaderComponent = __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"])({
            selector: 'panel-header',
            template: "<div class='panel__header'> \n                    <h3>{{node?.name}} // {{title}}</h3>\n              </div>",
            styles: [
                ".panel__header{ \n                font-weight: 600;\n                border: 2px solid #222;\n                border-radius: 4px;\n                padding: 5px;\n             }\n             h3{\n                margin: 0px;\n             }"
            ]
        }),
        __metadata("design:paramtypes", [])
    ], HeaderComponent);
    return HeaderComponent;
}());



/***/ }),

/***/ "./src/app/shared/components/navigation/navigation.component.ts":
/*!**********************************************************************!*\
  !*** ./src/app/shared/components/navigation/navigation.component.ts ***!
  \**********************************************************************/
/*! exports provided: NavigationComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NavigationComponent", function() { return NavigationComponent; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var _angular_router__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/router */ "./node_modules/@angular/router/fesm5/router.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


var NavigationComponent = /** @class */ (function () {
    function NavigationComponent(_router) {
        this._router = _router;
        this._links = [
            { path: '/about',
                name: 'about'
            },
            { path: '/gallery',
                name: 'gallery'
            },
            { path: '/publish',
                name: 'publish'
            },
            { path: '/editor',
                name: 'editor'
            },
        ];
    }
    NavigationComponent = __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"])({
            selector: 'navigation',
            template: "<ul class='nav'>\n                <li class='link' *ngFor='let link of _links;' \n                      [class.active]='link.path == _router.url'\n                      [routerLink]=\"link.path\" \n                      >{{link.name}}</li>\n              </ul>",
            styles: ["\n      ul.nav{\n        margin: 0px;\n        padding: 0px;\n      }\n\n      li.link{\n        display: inline;\n        border: 2px solid gray;\n        border-radius: 4px;\n        margin: 15px 15px 15px 0px;\n        padding: 5px;\n        text-transform: uppercase;\n        font-weight: 600;\n        cursor: pointer;\n        font-size: 16px;\n      }\n\n      li.link:hover{\n        background-color: gray;\n        color: white;\n      }\n\n      .active{\n        background-color: #222;\n        color: white;\n        border-color: #222 !important;\n      }\n  "],
        }),
        __metadata("design:paramtypes", [_angular_router__WEBPACK_IMPORTED_MODULE_1__["Router"]])
    ], NavigationComponent);
    return NavigationComponent;
}());



/***/ }),

/***/ "./src/app/shared/components/not-found/not-found.component.html":
/*!**********************************************************************!*\
  !*** ./src/app/shared/components/not-found/not-found.component.html ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<h1>Page Not Found</h1>\r\n<p>Dolore ex aliqua ut incididunt laborum deserunt pariatur officia.</p>\r\n"

/***/ }),

/***/ "./src/app/shared/components/not-found/not-found.component.scss":
/*!**********************************************************************!*\
  !*** ./src/app/shared/components/not-found/not-found.component.scss ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ""

/***/ }),

/***/ "./src/app/shared/components/not-found/not-found.component.ts":
/*!********************************************************************!*\
  !*** ./src/app/shared/components/not-found/not-found.component.ts ***!
  \********************************************************************/
/*! exports provided: PageNotFoundComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PageNotFoundComponent", function() { return PageNotFoundComponent; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

var PageNotFoundComponent = /** @class */ (function () {
    function PageNotFoundComponent() {
    }
    PageNotFoundComponent = __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"])({
            selector: 'page-not-found',
            template: __webpack_require__(/*! ./not-found.component.html */ "./src/app/shared/components/not-found/not-found.component.html"),
            styles: [__webpack_require__(/*! ./not-found.component.scss */ "./src/app/shared/components/not-found/not-found.component.scss")],
        }),
        __metadata("design:paramtypes", [])
    ], PageNotFoundComponent);
    return PageNotFoundComponent;
}());



/***/ }),

/***/ "./src/app/shared/components/parameter-viewer/input-port-viewer/input-port-viewer.component.html":
/*!*******************************************************************************************************!*\
  !*** ./src/app/shared/components/parameter-viewer/input-port-viewer/input-port-viewer.component.html ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<div class='container container--parameter'>\r\n\r\n    <div class='parameter__name'>{{ port.name }}</div>\r\n\r\n    <!-- Slider, SimpleInput ... etc -->\r\n    <div class='parameter__mode' [ngSwitch]=\"port.meta.mode\">\r\n        \r\n        <!-- Simple Input Template -->\r\n        <div *ngSwitchCase=\"PortTypes.SimpleInput\">\r\n            <input [(ngModel)]='port.value' name='port.name' placeholder='Enter Value: Defaults to {{port.default}}'> \r\n        </div>\r\n\r\n        <div *ngSwitchCase=\"PortTypes.Slider\">\r\n            <!-- <input  placeholder='Enter Value: Defaults to {{port.default}}'> -->\r\n            <input [(ngModel)]='port.value' value='port.value' placeholder='{{port.default}}' disabled>\r\n            <input [(ngModel)]='port.value' name='port.name' placeholder='{{port.default}}' type=\"range\">\r\n        </div>\r\n\r\n        <div *ngSwitchCase=\"PortTypes.Checkbox\">\r\n            <input *ngSwitchCase=\"PortTypes.Checkbox\" [(ngModel)]='port.value' name='port.name' type=\"checkbox\">\r\n        </div>\r\n\r\n        <div *ngSwitchCase=\"PortTypes.URL\">\r\n            <input [(ngModel)]='port.value' name='port.name' placeholder='Enter URL: Defaults to {{port.default}}'> \r\n        </div>\r\n        <div *ngSwitchCase=\"PortTypes.File\">\r\n            <input (change)=\"onFileChange($event)\" type=\"file\">\r\n        </div>\r\n    \r\n        <!-- TODO1: SwitchCase for remaining PortTypes -->\r\n        <!-- TODO2: Connect values to port.value -->\r\n    \r\n    </div>\r\n\r\n</div>"

/***/ }),

/***/ "./src/app/shared/components/parameter-viewer/input-port-viewer/input-port-viewer.component.scss":
/*!*******************************************************************************************************!*\
  !*** ./src/app/shared/components/parameter-viewer/input-port-viewer/input-port-viewer.component.scss ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ".container {\n  margin: 5px 0px; }\n\n.container--parameter {\n  display: flex;\n  flex-direction: row;\n  flex-wrap: wrap; }\n\n.parameter__name {\n  width: 100px;\n  height: auto;\n  word-wrap: break-word; }\n"

/***/ }),

/***/ "./src/app/shared/components/parameter-viewer/input-port-viewer/input-port-viewer.component.ts":
/*!*****************************************************************************************************!*\
  !*** ./src/app/shared/components/parameter-viewer/input-port-viewer/input-port-viewer.component.ts ***!
  \*****************************************************************************************************/
/*! exports provided: InputPortViewerComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InputPortViewerComponent", function() { return InputPortViewerComponent; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var _models_port__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @models/port */ "./src/app/shared/models/port/index.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


var InputPortViewerComponent = /** @class */ (function () {
    function InputPortViewerComponent() {
        this.PortTypes = _models_port__WEBPACK_IMPORTED_MODULE_1__["InputType"];
    }
    InputPortViewerComponent.prototype.onFileChange = function (event) {
        this.port.value = event.target.files[0];
    };
    __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(),
        __metadata("design:type", Object)
    ], InputPortViewerComponent.prototype, "port", void 0);
    InputPortViewerComponent = __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"])({
            selector: 'input-port-viewer',
            template: __webpack_require__(/*! ./input-port-viewer.component.html */ "./src/app/shared/components/parameter-viewer/input-port-viewer/input-port-viewer.component.html"),
            styles: [__webpack_require__(/*! ./input-port-viewer.component.scss */ "./src/app/shared/components/parameter-viewer/input-port-viewer/input-port-viewer.component.scss")]
        }),
        __metadata("design:paramtypes", [])
    ], InputPortViewerComponent);
    return InputPortViewerComponent;
}());



/***/ }),

/***/ "./src/app/shared/components/parameter-viewer/parameter-viewer.component.html":
/*!************************************************************************************!*\
  !*** ./src/app/shared/components/parameter-viewer/parameter-viewer.component.html ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<h2>{{flowchart.name}}</h2>\r\n<p>{{flowchart.description}}</p>\r\n<hr>\r\n\r\n<!-- <p>Edit the parameters of your flowchart here. These parameters are visible in the viewer when you share your flowchart.</p> -->\r\n<procedure-input-viewer *ngFor=\"let prod of startNode.procedure\" [prod]=\"prod\"></procedure-input-viewer>\r\n"

/***/ }),

/***/ "./src/app/shared/components/parameter-viewer/parameter-viewer.component.scss":
/*!************************************************************************************!*\
  !*** ./src/app/shared/components/parameter-viewer/parameter-viewer.component.scss ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ".container {\n  background-color: transparent;\n  width: auto;\n  height: auto;\n  display: flex;\n  flex-direction: column;\n  flex-wrap: wrap; }\n\nh2 {\n  color: #505050;\n  text-align: left;\n  padding-left: 15px;\n  font-size: 12px;\n  line-height: 16px; }\n\np {\n  color: #505050;\n  text-align: left;\n  padding-left: 15px;\n  font-size: 12px;\n  line-height: 14px; }\n\nhr {\n  border-top: 2px solid #efefef; }\n\ndiv[class^=\"container--\"] {\n  display: flex;\n  flex-direction: column;\n  margin: 10px 0px; }\n"

/***/ }),

/***/ "./src/app/shared/components/parameter-viewer/parameter-viewer.component.ts":
/*!**********************************************************************************!*\
  !*** ./src/app/shared/components/parameter-viewer/parameter-viewer.component.ts ***!
  \**********************************************************************************/
/*! exports provided: ParameterViewerComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParameterViewerComponent", function() { return ParameterViewerComponent; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

var ParameterViewerComponent = /** @class */ (function () {
    function ParameterViewerComponent() {
    }
    __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(),
        __metadata("design:type", Object)
    ], ParameterViewerComponent.prototype, "flowchart", void 0);
    __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(),
        __metadata("design:type", Object)
    ], ParameterViewerComponent.prototype, "startNode", void 0);
    __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(),
        __metadata("design:type", Object)
    ], ParameterViewerComponent.prototype, "endNode", void 0);
    ParameterViewerComponent = __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"])({
            selector: 'parameter-viewer',
            template: __webpack_require__(/*! ./parameter-viewer.component.html */ "./src/app/shared/components/parameter-viewer/parameter-viewer.component.html"),
            styles: [__webpack_require__(/*! ./parameter-viewer.component.scss */ "./src/app/shared/components/parameter-viewer/parameter-viewer.component.scss")]
        })
    ], ParameterViewerComponent);
    return ParameterViewerComponent;
}());



/***/ }),

/***/ "./src/app/shared/components/parameter-viewer/procedure-input-viewer/procedure-input-viewer.component.html":
/*!*****************************************************************************************************************!*\
  !*** ./src/app/shared/components/parameter-viewer/procedure-input-viewer/procedure-input-viewer.component.html ***!
  \*****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<div class='container'>\r\n    <div class='container--parameter'>\r\n        <input [class.disabled-input]='true' value='{{prod.args[prod.argCount-2].value||\"Undefined\"}}:' disabled>\r\n        <!--\r\n        <select name={{prod.id}}_type [(ngModel)]=\"prod.meta.inputMode\">\r\n            <option \r\n                *ngFor=\"let ptype of PortTypesArr\" \r\n                [value]=\"PortTypes[ptype]\" \r\n                [selected]=\"prod.meta.inputMode == ptype\">{{ptype}}</option>\r\n        </select>\r\n        -->\r\n        <ng-container class='parameter__name' [ngSwitch]=\"prod.meta.inputMode\">\r\n            <!--\r\n\r\n            <div *ngSwitchCase=\"PortTypes.SimpleInput\">\r\n                <input [(ngModel)]='port.value' name='port.name' placeholder='Enter Value: Defaults to {{port.default}}'> \r\n            </div>\r\n\r\n            <div *ngSwitchCase=\"PortTypes.Slider\">\r\n                <input [(ngModel)]='port.value' value='port.value' placeholder='{{port.default}}' disabled>\r\n                <input [(ngModel)]='port.value' name='port.name' placeholder='{{port.default}}' type=\"range\">\r\n            </div>\r\n\r\n            <div *ngSwitchCase=\"PortTypes.Checkbox\">\r\n                <input *ngSwitchCase=\"PortTypes.Checkbox\" [(ngModel)]='port.value' name='port.name' type=\"checkbox\">\r\n            </div>\r\n\r\n            <div *ngSwitchCase=\"PortTypes.URL\">\r\n                <input [(ngModel)]='port.value' name='port.name' placeholder='Enter URL: Defaults to {{port.default}}'> \r\n            </div>\r\n            <div *ngSwitchCase=\"PortTypes.File\">\r\n                <input (change)=\"onFileChange($event)\" type=\"file\">\r\n            </div>\r\n        \r\n            -->\r\n\r\n            <input *ngSwitchCase=\"PortTypes.SimpleInput\" [(ngModel)]='prod.args[prod.argCount-1].value' \r\n            placeholder='{{prod.args[prod.argCount-1].default}}'\r\n            size={{prod.args[prod.argCount-1].value?.length||prod.args[prod.argCount-1].default.length}}>\r\n            \r\n            <ng-container *ngSwitchCase=\"PortTypes.Slider\">\r\n                <mat-slider\r\n                    [(ngModel)]='prod.args[prod.argCount-1].value'\r\n                    thumbLabel\r\n                    tickInterval=\"auto\"\r\n                    min={{prod.args[prod.argCount-1].min||0}}\r\n                    max={{prod.args[prod.argCount-1].max||100}}></mat-slider>\r\n                <input [class.disabled-input]='true' [(ngModel)]='prod.args[prod.argCount-1].value' size={{prod.args[prod.argCount-1].value?.length||1}} disabled>\r\n\r\n\r\n                <!--\r\n                <input [(ngModel)]='prod.args[prod.argCount-1].value' name='prod.args[prod.argCount-1].value' type=\"range\" placeholder='{{prod.args[prod.argCount-1].default}}'>\r\n                <input [(ngModel)]='prod.args[prod.argCount-1].value' value='prod.args[prod.argCount-1].value'  placeholder='{{prod.args[prod.argCount-1].default}}' disabled>\r\n                -->\r\n            </ng-container>\r\n            <input *ngSwitchCase=\"PortTypes.Checkbox\" [(ngModel)]='prod.args[prod.argCount-1].value' type=\"checkbox\">\r\n            <input *ngSwitchCase=\"PortTypes.URL\" [(ngModel)]='prod.args[prod.argCount-1].value' placeholder='Enter URL: Defaults to {{prod.args[prod.argCount-1].default}}'>\r\n            <input *ngSwitchCase=\"PortTypes.File\" (change)=\"onFileChange($event)\" type=\"file\">\r\n        </ng-container>\r\n    </div>\r\n</div>\r\n\r\n"

/***/ }),

/***/ "./src/app/shared/components/parameter-viewer/procedure-input-viewer/procedure-input-viewer.component.scss":
/*!*****************************************************************************************************************!*\
  !*** ./src/app/shared/components/parameter-viewer/procedure-input-viewer/procedure-input-viewer.component.scss ***!
  \*****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ".container {\n  display: block;\n  margin: 5px 0px 0px 5px;\n  width: 100%; }\n\n.container--parameter {\n  display: inline-block;\n  flex-direction: row;\n  flex-wrap: wrap;\n  bottom: 0px;\n  padding-bottom: 5px;\n  border-bottom: 1px solid #efefef;\n  border-left: 1px solid #efefef;\n  width: 100%; }\n\n.container--input {\n  display: inline-flex;\n  flex-direction: row; }\n\ninput {\n  color: #505050;\n  background-color: gainsboro;\n  border: none;\n  border-bottom: 1px solid #505050;\n  margin-left: 5px;\n  vertical-align: bottom; }\n\ninput.disabled-input {\n    border-bottom: none; }\n\n.parameter__name {\n  display: inline-block;\n  flex-direction: row;\n  flex-wrap: wrap;\n  width: 100px; }\n\nmat-slider {\n  width: 300px; }\n"

/***/ }),

/***/ "./src/app/shared/components/parameter-viewer/procedure-input-viewer/procedure-input-viewer.component.ts":
/*!***************************************************************************************************************!*\
  !*** ./src/app/shared/components/parameter-viewer/procedure-input-viewer/procedure-input-viewer.component.ts ***!
  \***************************************************************************************************************/
/*! exports provided: procedureInputViewerComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "procedureInputViewerComponent", function() { return procedureInputViewerComponent; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var _models_port__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @models/port */ "./src/app/shared/models/port/index.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


var procedureInputViewerComponent = /** @class */ (function () {
    function procedureInputViewerComponent() {
        this.delete = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.PortTypes = _models_port__WEBPACK_IMPORTED_MODULE_1__["InputType"];
    }
    procedureInputViewerComponent.prototype.editOptions = function () { };
    procedureInputViewerComponent.prototype.onFileChange = function (event) {
        this.prod.args[this.prod.args.length - 1] = event.target.files[0];
    };
    __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(),
        __metadata("design:type", Object)
    ], procedureInputViewerComponent.prototype, "prod", void 0);
    __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"])(),
        __metadata("design:type", Object)
    ], procedureInputViewerComponent.prototype, "delete", void 0);
    procedureInputViewerComponent = __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"])({
            selector: 'procedure-input-viewer',
            template: __webpack_require__(/*! ./procedure-input-viewer.component.html */ "./src/app/shared/components/parameter-viewer/procedure-input-viewer/procedure-input-viewer.component.html"),
            styles: [__webpack_require__(/*! ./procedure-input-viewer.component.scss */ "./src/app/shared/components/parameter-viewer/procedure-input-viewer/procedure-input-viewer.component.scss")]
        }),
        __metadata("design:paramtypes", [])
    ], procedureInputViewerComponent);
    return procedureInputViewerComponent;
}());



/***/ }),

/***/ "./src/app/shared/decorators/index.ts":
/*!********************************************!*\
  !*** ./src/app/shared/decorators/index.ts ***!
  \********************************************/
/*! exports provided: ModuleAware, ProcedureTypesAware, ViewerTypesAware, PortTypesAware */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _module_aware_decorator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./module-aware.decorator */ "./src/app/shared/decorators/module-aware.decorator.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ModuleAware", function() { return _module_aware_decorator__WEBPACK_IMPORTED_MODULE_0__["ModuleAware"]; });

/* harmony import */ var _prodtypes_aware_decorator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./prodtypes-aware.decorator */ "./src/app/shared/decorators/prodtypes-aware.decorator.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ProcedureTypesAware", function() { return _prodtypes_aware_decorator__WEBPACK_IMPORTED_MODULE_1__["ProcedureTypesAware"]; });

/* harmony import */ var _viewertypes_aware_decorator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./viewertypes-aware.decorator */ "./src/app/shared/decorators/viewertypes-aware.decorator.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ViewerTypesAware", function() { return _viewertypes_aware_decorator__WEBPACK_IMPORTED_MODULE_2__["ViewerTypesAware"]; });

/* harmony import */ var _porttypes_aware_decorator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./porttypes-aware.decorator */ "./src/app/shared/decorators/porttypes-aware.decorator.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PortTypesAware", function() { return _porttypes_aware_decorator__WEBPACK_IMPORTED_MODULE_3__["PortTypesAware"]; });







/***/ }),

/***/ "./src/app/shared/decorators/module-aware.decorator.ts":
/*!*************************************************************!*\
  !*** ./src/app/shared/decorators/module-aware.decorator.ts ***!
  \*************************************************************/
/*! exports provided: ModuleAware */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ModuleAware", function() { return ModuleAware; });
/* harmony import */ var _modules__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @modules */ "./src/app/core/modules/index.ts");
var __values = (undefined && undefined.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};

// todo: bug fix for defaults
function extract_params(func) {
    var fnStr = func.toString().replace(/((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg, '');
    var result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).split(","); //.match( /([^\s,]+)/g);
    if (result === null || result[0] == "") {
        result = [];
    }
    var final_result = result.map(function (r) {
        r = r.trim();
        var r_value = r.split("=");
        if (r_value.length == 1) {
            return { name: r_value[0].trim(), value: undefined, default: 0 };
        }
        else {
            return { name: r_value[0].trim(), value: undefined, default: 0 };
        }
    });
    var hasReturn = true;
    if (fnStr.indexOf("return") === -1 || fnStr.indexOf("return;") !== -1) {
        hasReturn = false;
    }
    return [final_result, hasReturn];
}
function ModuleAware(constructor) {
    var e_1, _a;
    var module_list = [];
    for (var m_name in _modules__WEBPACK_IMPORTED_MODULE_0__) {
        if (m_name[0] == '_' || m_name == 'gs' || m_name == 'gsConstructor') {
            continue;
        }
        var modObj = {};
        modObj.module = m_name;
        modObj.functions = [];
        try {
            for (var _b = __values(Object.keys(_modules__WEBPACK_IMPORTED_MODULE_0__[m_name])), _c = _b.next(); !_c.done; _c = _b.next()) {
                var fn_name = _c.value;
                var func = _modules__WEBPACK_IMPORTED_MODULE_0__[m_name][fn_name];
                var fnObj = {};
                fnObj.module = m_name;
                fnObj.name = fn_name;
                fnObj.argCount = func.length;
                var args = extract_params(func);
                fnObj.args = args[0];
                fnObj.hasReturn = args[1];
                modObj.functions.push(fnObj);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        module_list.push(modObj);
    }
    constructor.prototype.Modules = module_list;
}


/***/ }),

/***/ "./src/app/shared/decorators/porttypes-aware.decorator.ts":
/*!****************************************************************!*\
  !*** ./src/app/shared/decorators/porttypes-aware.decorator.ts ***!
  \****************************************************************/
/*! exports provided: PortTypesAware */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PortTypesAware", function() { return PortTypesAware; });
/* harmony import */ var _models_port__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @models/port */ "./src/app/shared/models/port/index.ts");

function PortTypesAware(constructor) {
    constructor.prototype.PortTypes = _models_port__WEBPACK_IMPORTED_MODULE_0__["InputType"];
    // array form
    var keys = Object.keys(_models_port__WEBPACK_IMPORTED_MODULE_0__["InputType"]);
    constructor.prototype.PortTypesArr = keys.slice(keys.length / 2);
}


/***/ }),

/***/ "./src/app/shared/decorators/prodtypes-aware.decorator.ts":
/*!****************************************************************!*\
  !*** ./src/app/shared/decorators/prodtypes-aware.decorator.ts ***!
  \****************************************************************/
/*! exports provided: ProcedureTypesAware */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ProcedureTypesAware", function() { return ProcedureTypesAware; });
/* harmony import */ var _models_procedure__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @models/procedure */ "./src/app/shared/models/procedure/index.ts");

function ProcedureTypesAware(constructor) {
    constructor.prototype.ProcedureTypes = _models_procedure__WEBPACK_IMPORTED_MODULE_0__["ProcedureTypes"];
    // array form
    var keys = Object.keys(_models_procedure__WEBPACK_IMPORTED_MODULE_0__["ProcedureTypes"]);
    constructor.prototype.ProcedureTypesArr = keys.slice(keys.length / 2);
}


/***/ }),

/***/ "./src/app/shared/decorators/viewertypes-aware.decorator.ts":
/*!******************************************************************!*\
  !*** ./src/app/shared/decorators/viewertypes-aware.decorator.ts ***!
  \******************************************************************/
/*! exports provided: ViewerTypesAware */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ViewerTypesAware", function() { return ViewerTypesAware; });
/* harmony import */ var _models_port__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @models/port */ "./src/app/shared/models/port/index.ts");

function ViewerTypesAware(constructor) {
    constructor.prototype.ViewerTypes = _models_port__WEBPACK_IMPORTED_MODULE_0__["OutputType"];
    // array form
    var keys = Object.keys(_models_port__WEBPACK_IMPORTED_MODULE_0__["OutputType"]);
    constructor.prototype.ViewerTypesArr = keys.slice(keys.length / 2);
}


/***/ }),

/***/ "./src/app/shared/directives/filesys/index.ts":
/*!****************************************************!*\
  !*** ./src/app/shared/directives/filesys/index.ts ***!
  \****************************************************/
/*! exports provided: MbFileReaderDirective */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _mobfile_reader_directive__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mobfile-reader.directive */ "./src/app/shared/directives/filesys/mobfile-reader.directive.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MbFileReaderDirective", function() { return _mobfile_reader_directive__WEBPACK_IMPORTED_MODULE_0__["MbFileReaderDirective"]; });




/***/ }),

/***/ "./src/app/shared/directives/filesys/mobfile-reader.directive.ts":
/*!***********************************************************************!*\
  !*** ./src/app/shared/directives/filesys/mobfile-reader.directive.ts ***!
  \***********************************************************************/
/*! exports provided: MbFileReaderDirective */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MbFileReaderDirective", function() { return MbFileReaderDirective; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var circular_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! circular-json */ "./node_modules/circular-json/build/circular-json.node.js");
/* harmony import */ var circular_json__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(circular_json__WEBPACK_IMPORTED_MODULE_1__);
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
/*
 *	Adding this to an HTML5 input element
 *	allows for the file being read to be converted into a Mobius
 *	Flowchart
 *
 */


var MbFileReaderDirective = /** @class */ (function () {
    function MbFileReaderDirective(el) {
        this.el = el;
        this.data = {};
        this.load = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
    }
    MbFileReaderDirective.prototype.onFileChange = function () {
        var f = this.el.nativeElement.files[0];
        if (f) {
            var reader = new FileReader();
            reader.readAsText(f, "UTF-8");
            var ins_1 = this;
            reader.onload = function (evt) {
                var fileString = evt.target["result"];
                ins_1.load_flowchart_from_string(fileString);
            };
            reader.onerror = function (evt) {
                console.log("Error reading file");
            };
        }
    };
    //
    // Input: string
    // Output: MobiusFile DS
    //  
    //
    MbFileReaderDirective.prototype.load_flowchart_from_string = function (fileString) {
        var _this = this;
        var jsonData;
        var flowchart; // IFlowchart;
        try {
            var data = circular_json__WEBPACK_IMPORTED_MODULE_1__["parse"](fileString);
            this.load.emit(data);
            // this.data.flowchart = data.flowchart; 
            // this.data.modules = data.modules;
            // this.data.language = data.language;
            // this.update_code_generator(CodeFactory.getCodeGenerator(data["language"]));
            //TODO: this.update_modules();
            //flowchart = FlowchartReader.read_flowchart_from_data(data["flowchart"]);
            // TODO: select a node
        }
        catch (err) {
            console.error("Mob-file-reader error", err);
        }
    };
    __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(),
        __metadata("design:type", Object)
    ], MbFileReaderDirective.prototype, "data", void 0);
    __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"])(),
        __metadata("design:type", Object)
    ], MbFileReaderDirective.prototype, "load", void 0);
    __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["HostListener"])("change"),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], MbFileReaderDirective.prototype, "onFileChange", null);
    MbFileReaderDirective = __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"])({
            selector: "[mbFileReader]"
        }),
        __metadata("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"]])
    ], MbFileReaderDirective);
    return MbFileReaderDirective;
}());



/***/ }),

/***/ "./src/app/shared/directives/textarea/autogrow.directive.ts":
/*!******************************************************************!*\
  !*** ./src/app/shared/directives/textarea/autogrow.directive.ts ***!
  \******************************************************************/
/*! exports provided: autogrowDirective */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "autogrowDirective", function() { return autogrowDirective; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

var autogrowDirective = /** @class */ (function () {
    function autogrowDirective(el) {
        this.el = el;
    }
    autogrowDirective.prototype.onKeyUp = function () {
        this.el.nativeElement.style.height = "5px";
        this.el.nativeElement.style.height = (this.el.nativeElement.scrollHeight) + "px";
    };
    autogrowDirective.prototype.onKeyDown = function () {
        this.el.nativeElement.style.height = "5px";
        this.el.nativeElement.style.height = (this.el.nativeElement.scrollHeight) + "px";
    };
    __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["HostListener"])("keyup"),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], autogrowDirective.prototype, "onKeyUp", null);
    __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["HostListener"])("keydown"),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], autogrowDirective.prototype, "onKeyDown", null);
    autogrowDirective = __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"])({
            selector: "[autogrow]"
        }),
        __metadata("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ElementRef"]])
    ], autogrowDirective);
    return autogrowDirective;
}());



/***/ }),

/***/ "./src/app/shared/directives/textarea/index.ts":
/*!*****************************************************!*\
  !*** ./src/app/shared/directives/textarea/index.ts ***!
  \*****************************************************/
/*! exports provided: autogrowDirective */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _autogrow_directive__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./autogrow.directive */ "./src/app/shared/directives/textarea/autogrow.directive.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "autogrowDirective", function() { return _autogrow_directive__WEBPACK_IMPORTED_MODULE_0__["autogrowDirective"]; });




/***/ }),

/***/ "./src/app/shared/models/code/code.utils.ts":
/*!**************************************************!*\
  !*** ./src/app/shared/models/code/code.utils.ts ***!
  \**************************************************/
/*! exports provided: CodeUtils */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CodeUtils", function() { return CodeUtils; });
/* harmony import */ var _models_procedure__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @models/procedure */ "./src/app/shared/models/procedure/index.ts");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rxjs */ "./node_modules/rxjs/_esm5/index.js");
/* harmony import */ var circular_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! circular-json */ "./node_modules/circular-json/build/circular-json.node.js");
/* harmony import */ var circular_json__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(circular_json__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var gs_json__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! gs-json */ "./node_modules/gs-json/dist2015/index.js");
/* harmony import */ var gs_json__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(gs_json__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _modules__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @modules */ "./src/app/core/modules/index.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (undefined && undefined.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};






var CodeUtils = /** @class */ (function () {
    function CodeUtils() {
    }
    CodeUtils.getProcedureCode = function (prod, existingVars, addProdArr) {
        var e_1, _a, e_2, _b, e_3, _c, e_4, _d, e_5, _e;
        if (prod.enabled === false)
            return '';
        prod.hasError = false;
        var codeStr = [];
        var args = prod.args;
        var prefix = args.hasOwnProperty('0') && existingVars.indexOf(args[0].value) === -1 ? 'let ' : '';
        if (addProdArr && prod.type != _models_procedure__WEBPACK_IMPORTED_MODULE_0__["ProcedureTypes"].Else && prod.type != _models_procedure__WEBPACK_IMPORTED_MODULE_0__["ProcedureTypes"].Elseif) {
            codeStr.push("__params__.currentProcedure[0] = \"" + prod.ID + "\";");
        }
        switch (prod.type) {
            case _models_procedure__WEBPACK_IMPORTED_MODULE_0__["ProcedureTypes"].Variable:
                if (args[0].value.indexOf('__params__') != -1 || args[1].value.indexOf('__params__') != -1)
                    throw new Error("Unexpected Identifier");
                codeStr.push("" + prefix + args[0].value + " = " + args[1].value + ";");
                if (prefix === 'let ') {
                    existingVars.push(args[0].value);
                }
                break;
            case _models_procedure__WEBPACK_IMPORTED_MODULE_0__["ProcedureTypes"].If:
                if (args[0].value.indexOf('__params__') != -1)
                    throw new Error("Unexpected Identifier");
                codeStr.push("if (" + args[0].value + "){");
                try {
                    for (var _f = __values(prod.children), _g = _f.next(); !_g.done; _g = _f.next()) {
                        var p = _g.value;
                        codeStr.push(CodeUtils.getProcedureCode(p, existingVars, addProdArr));
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_g && !_g.done && (_a = _f.return)) _a.call(_f);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                codeStr.push("}");
                break;
            case _models_procedure__WEBPACK_IMPORTED_MODULE_0__["ProcedureTypes"].Else:
                codeStr.push("else {");
                try {
                    for (var _h = __values(prod.children), _j = _h.next(); !_j.done; _j = _h.next()) {
                        var p = _j.value;
                        codeStr.push(CodeUtils.getProcedureCode(p, existingVars, addProdArr));
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_j && !_j.done && (_b = _h.return)) _b.call(_h);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
                codeStr.push("}");
                break;
            case _models_procedure__WEBPACK_IMPORTED_MODULE_0__["ProcedureTypes"].Elseif:
                if (args[0].value.indexOf('__params__') != -1)
                    throw new Error("Unexpected Identifier");
                codeStr.push("else if(" + args[0].value + "){");
                try {
                    for (var _k = __values(prod.children), _l = _k.next(); !_l.done; _l = _k.next()) {
                        var p = _l.value;
                        codeStr.push(CodeUtils.getProcedureCode(p, existingVars, addProdArr));
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (_l && !_l.done && (_c = _k.return)) _c.call(_k);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
                codeStr.push("}");
                break;
            case _models_procedure__WEBPACK_IMPORTED_MODULE_0__["ProcedureTypes"].Foreach:
                //codeStr.push(`for (${prefix} ${args[0].value} of [...Array(${args[1].value}).keys()]){`);
                if (args[0].value.indexOf('__params__') != -1)
                    throw new Error("Unexpected Identifier");
                codeStr.push("for (" + prefix + " " + args[0].value + " of " + args[1].value + "){");
                try {
                    for (var _m = __values(prod.children), _o = _m.next(); !_o.done; _o = _m.next()) {
                        var p = _o.value;
                        codeStr.push(CodeUtils.getProcedureCode(p, existingVars, addProdArr));
                    }
                }
                catch (e_4_1) { e_4 = { error: e_4_1 }; }
                finally {
                    try {
                        if (_o && !_o.done && (_d = _m.return)) _d.call(_m);
                    }
                    finally { if (e_4) throw e_4.error; }
                }
                codeStr.push("}");
                break;
            case _models_procedure__WEBPACK_IMPORTED_MODULE_0__["ProcedureTypes"].While:
                if (args[0].value.indexOf('__params__') != -1)
                    throw new Error("Unexpected Identifier");
                codeStr.push("while (" + args[0].value + "){");
                try {
                    for (var _p = __values(prod.children), _q = _p.next(); !_q.done; _q = _p.next()) {
                        var p = _q.value;
                        codeStr.push(CodeUtils.getProcedureCode(p, existingVars, addProdArr));
                    }
                }
                catch (e_5_1) { e_5 = { error: e_5_1 }; }
                finally {
                    try {
                        if (_q && !_q.done && (_e = _p.return)) _e.call(_p);
                    }
                    finally { if (e_5) throw e_5.error; }
                }
                codeStr.push("}");
                break;
            case _models_procedure__WEBPACK_IMPORTED_MODULE_0__["ProcedureTypes"].Break:
                codeStr.push("break;");
                break;
            case _models_procedure__WEBPACK_IMPORTED_MODULE_0__["ProcedureTypes"].Continue:
                codeStr.push("continue;");
                break;
            case _models_procedure__WEBPACK_IMPORTED_MODULE_0__["ProcedureTypes"].Function:
                var argValues = args.slice(1).map(function (arg) {
                    // if __params__ is present in the value of the argument, throw unexpected identifier
                    if (arg.name == _modules__WEBPACK_IMPORTED_MODULE_4__["_parameterTypes"].input) {
                        console.log(arg.value, arg.default);
                        var val = arg.value || arg.default;
                        return val;
                    }
                    ;
                    if (arg.value && arg.value.indexOf('__params__') != -1)
                        throw new Error("Unexpected Identifier");
                    if (arg.name == _modules__WEBPACK_IMPORTED_MODULE_4__["_parameterTypes"].constList)
                        return "__params__.constants";
                    if (arg.name == _modules__WEBPACK_IMPORTED_MODULE_4__["_parameterTypes"].model)
                        return "__params__.model";
                    if (arg.value && arg.value.substring(0, 1) == '@') {
                        if (prod.meta.module.toUpperCase() == 'QUERY' && prod.meta.name.toUpperCase() == 'SET' && arg.name.toUpperCase() == 'STATEMENT')
                            return '"' + arg.value.replace(/"/g, "'") + '"';
                        return '__modules__.Query.get( __params__.model,"' + arg.value.replace(/"/g, "'") + '" )';
                    }
                    //else if (arg.name.indexOf('__') != -1) return '"'+args[args.indexOf(arg)+1].value+'"';
                    return arg.value;
                }).join(',');
                var fnCall = "__modules__." + prod.meta.module + "." + prod.meta.name + "( " + argValues + " )";
                if (prod.meta.module.toUpperCase() == 'OUTPUT') {
                    codeStr.push("return " + fnCall + ";");
                }
                else if (args[0].name == '__none__') {
                    codeStr.push(fnCall + ";");
                }
                else {
                    codeStr.push("" + prefix + args[0].value + " = " + fnCall + ";");
                    if (prefix === 'let ') {
                        existingVars.push(args[0].value);
                    }
                }
                break;
            case _models_procedure__WEBPACK_IMPORTED_MODULE_0__["ProcedureTypes"].Imported:
                //('args: ',args)
                var argsVals = args.slice(1).map(function (arg) { return arg.value; }).join(',');
                var fn = prod.meta.name + "( " + argsVals + " )";
                codeStr.push("" + prefix + args[0].value + " = " + fn + ";");
                if (prefix === 'let ') {
                    existingVars.push(args[0].value);
                }
                break;
        }
        if (prod.print) {
            codeStr.push("console.log('" + prod.args[0].value + ":'," + prod.args[0].value + ")");
        }
        return codeStr.join('\n');
    };
    CodeUtils.loadFile = function (f) {
        var stream = rxjs__WEBPACK_IMPORTED_MODULE_1__["Observable"].create(function (observer) {
            var request = new XMLHttpRequest();
            request.open('GET', f.download_url);
            request.onload = function () {
                if (request.status === 200) {
                    var f_1 = circular_json__WEBPACK_IMPORTED_MODULE_2__["parse"](request.responseText);
                    observer.next(f_1);
                    observer.complete();
                }
                else {
                    observer.error('error happened');
                }
            };
            request.onerror = function () {
                observer.error('error happened');
            };
            request.send();
        });
        stream.subscribe(function (loadeddata) {
            return loadeddata;
        });
    };
    CodeUtils.mergeInputs = function (models) {
        var e_6, _a;
        var result = new gs_json__WEBPACK_IMPORTED_MODULE_3__["Model"]();
        try {
            for (var models_1 = __values(models), models_1_1 = models_1.next(); !models_1_1.done; models_1_1 = models_1.next()) {
                var model = models_1_1.value;
                if (!model || model.constructor != _modules__WEBPACK_IMPORTED_MODULE_4__["gsConstructor"])
                    continue;
                result.merge(model);
            }
        }
        catch (e_6_1) { e_6 = { error: e_6_1 }; }
        finally {
            try {
                if (models_1_1 && !models_1_1.done && (_a = models_1.return)) _a.call(models_1);
            }
            finally { if (e_6) throw e_6.error; }
        }
        return result;
    };
    CodeUtils.getInputValue = function (inp, node) {
        return __awaiter(this, void 0, void 0, function () {
            var input;
            return __generator(this, function (_a) {
                if (node.type == 'start' || inp.edges.length == 0) {
                    input = new gs_json__WEBPACK_IMPORTED_MODULE_3__["Model"]();
                }
                else {
                    input = CodeUtils.mergeInputs(inp.edges.map(function (edge) { return edge.source.value; }));
                    /*
                    if (input.constructor === gsConstructor) {
                        input = `new __MODULES__.gs.Model(${input.toJSON()})`
                    } else {
                        // do nothing
                    }
                    */
                }
                return [2 /*return*/, input];
            });
        });
    };
    CodeUtils.getNodeCode = function (node, addProdArr) {
        if (addProdArr === void 0) { addProdArr = false; }
        return __awaiter(this, void 0, void 0, function () {
            var e_7, _a, codeStr, varsDefined, input, _b, _c, prod;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        node.hasError = false;
                        codeStr = [];
                        varsDefined = [];
                        if (!addProdArr) return [3 /*break*/, 2];
                        return [4 /*yield*/, CodeUtils.getInputValue(node.input, node)];
                    case 1:
                        input = _d.sent();
                        node.input.value = input;
                        _d.label = 2;
                    case 2:
                        if (node.type == 'start') {
                            codeStr.push('__params__.constants = {};\n');
                        }
                        try {
                            // procedure
                            for (_b = __values(node.procedure), _c = _b.next(); !_c.done; _c = _b.next()) {
                                prod = _c.value;
                                codeStr.push(CodeUtils.getProcedureCode(prod, varsDefined, addProdArr));
                            }
                        }
                        catch (e_7_1) { e_7 = { error: e_7_1 }; }
                        finally {
                            try {
                                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                            }
                            finally { if (e_7) throw e_7.error; }
                        }
                        ;
                        if (node.type == 'end' && node.procedure.length > 0) {
                            return [2 /*return*/, "{\n" + codeStr.join('\n') + "\n}"];
                        }
                        return [2 /*return*/, "{\n" + codeStr.join('\n') + "\nreturn __params__.model;\n}"];
                }
            });
        });
    };
    CodeUtils.getFunctionString = function (func) {
        return __awaiter(this, void 0, void 0, function () {
            var e_8, _a, fullCode, fnCode, _b, _c, node, code, e_8_1;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        fullCode = '';
                        fnCode = "function " + func.name + "(" + func.args.map(function (arg) { return arg.name; }).join(',') + "){\nvar merged;\nlet __params__={\"currentProcedure\": [''],\"model\":{}};\n";
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, 6, 7, 8]);
                        _b = __values(func.module.nodes), _c = _b.next();
                        _d.label = 2;
                    case 2:
                        if (!!_c.done) return [3 /*break*/, 5];
                        node = _c.value;
                        return [4 /*yield*/, CodeUtils.getNodeCode(node, false)];
                    case 3:
                        code = _d.sent();
                        fullCode += "function " + node.id + "(__params__, " + func.args.map(function (arg) { return arg.name; }).join(',') + ")" + code + "\n\n";
                        if (node.type === 'start') {
                            //fnCode += `let result_${node.id} = ${node.id}(__params__);\n`
                            fnCode += "let result_" + node.id + " = __params__.model;\n";
                        }
                        else if (node.input.edges.length == 1) {
                            fnCode += "__params__.model = JSON.parse(JSON.stringify(result_" + node.input.edges[0].source.parentNode.id + "));\n";
                            fnCode += "let result_" + node.id + " = " + node.id + "(__params__, " + func.args.map(function (arg) { return arg.name; }).join(',') + ");\n";
                        }
                        else {
                            fnCode += "merged = mergeInputs([" + node.input.edges.map(function (edge) { return 'result_' + edge.source.parentNode.id; }).join(',') + "]);\n";
                            fnCode += "__params__.model = merged;\n";
                            fnCode += "let result_" + node.id + " = " + node.id + "(__params__, " + func.args.map(function (arg) { return arg.name; }).join(',') + ");\n";
                        }
                        /*
                        } else if (node.input.edges.length == 1) {
                            fnCode += `let result_${node.id} = ${node.id}(result_${node.input.edges[0].source.parentNode.id});\n`
                        } else {
                            fnCode += `merged = mergeResults([${node.input.edges.map((edge)=>'result_'+edge.source.parentNode.id).join(',')}]);\n`;
                            fnCode += `let result_${node.id} = ${node.id}(merged);\n`
            
            
                        */
                        if (node.type === 'end') {
                            fnCode += "return result_" + node.id + ";\n";
                        }
                        _d.label = 4;
                    case 4:
                        _c = _b.next();
                        return [3 /*break*/, 2];
                    case 5: return [3 /*break*/, 8];
                    case 6:
                        e_8_1 = _d.sent();
                        e_8 = { error: e_8_1 };
                        return [3 /*break*/, 8];
                    case 7:
                        try {
                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                        }
                        finally { if (e_8) throw e_8.error; }
                        return [7 /*endfinally*/];
                    case 8:
                        fnCode += '}\n\n';
                        fullCode += fnCode;
                        //console.log(fullCode)
                        return [2 /*return*/, fullCode];
                }
            });
        });
    };
    return CodeUtils;
}());



/***/ }),

/***/ "./src/app/shared/models/code/execute.utils.ts":
/*!*****************************************************!*\
  !*** ./src/app/shared/models/code/execute.utils.ts ***!
  \*****************************************************/
/*! exports provided: ExecuteUtils */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ExecuteUtils", function() { return ExecuteUtils; });
var ExecuteUtils = /** @class */ (function () {
    function ExecuteUtils() {
    }
    return ExecuteUtils;
}());



/***/ }),

/***/ "./src/app/shared/models/code/index.ts":
/*!*********************************************!*\
  !*** ./src/app/shared/models/code/index.ts ***!
  \*********************************************/
/*! exports provided: CodeUtils, ExecuteUtils */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _code_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./code.utils */ "./src/app/shared/models/code/code.utils.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CodeUtils", function() { return _code_utils__WEBPACK_IMPORTED_MODULE_0__["CodeUtils"]; });

/* harmony import */ var _execute_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./execute.utils */ "./src/app/shared/models/code/execute.utils.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ExecuteUtils", function() { return _execute_utils__WEBPACK_IMPORTED_MODULE_1__["ExecuteUtils"]; });





/***/ }),

/***/ "./src/app/shared/models/flowchart/flowchart.utils.ts":
/*!************************************************************!*\
  !*** ./src/app/shared/models/flowchart/flowchart.utils.ts ***!
  \************************************************************/
/*! exports provided: FlowchartUtils */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FlowchartUtils", function() { return FlowchartUtils; });
/* harmony import */ var _models_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @models/node */ "./src/app/shared/models/node/index.ts");
var __values = (undefined && undefined.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};

var FlowchartUtils = /** @class */ (function () {
    function FlowchartUtils() {
    }
    FlowchartUtils.newflowchart = function () {
        var flw = {
            name: "new_flowchart",
            description: '',
            language: "js",
            meta: {
                selected_nodes: [0]
            },
            nodes: [_models_node__WEBPACK_IMPORTED_MODULE_0__["NodeUtils"].getStartNode(), _models_node__WEBPACK_IMPORTED_MODULE_0__["NodeUtils"].getEndNode()],
            edges: [],
            functions: [],
            ordered: false
        };
        return flw;
    };
    FlowchartUtils.checkNode = function (nodeOrder, node, enabled) {
        var e_1, _a, e_2, _b;
        if (node.hasExecuted) {
            return;
        }
        else if (node.type === 'start') {
            nodeOrder.push(node);
        }
        else {
            try {
                for (var _c = __values(node.input.edges), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var edge = _d.value;
                    if (!edge.source.parentNode.hasExecuted) {
                        return;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
            nodeOrder.push(node);
        }
        node.hasExecuted = true;
        node.enabled = enabled;
        try {
            for (var _e = __values(node.output.edges), _f = _e.next(); !_f.done; _f = _e.next()) {
                var edge = _f.value;
                FlowchartUtils.checkNode(nodeOrder, edge.target.parentNode, enabled);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
            }
            finally { if (e_2) throw e_2.error; }
        }
    };
    FlowchartUtils.orderNodes = function (flw) {
        var e_3, _a, e_4, _b;
        var startNode = undefined;
        try {
            for (var _c = __values(flw.nodes), _d = _c.next(); !_d.done; _d = _c.next()) {
                var node = _d.value;
                if (node.type === 'start') {
                    startNode = node;
                }
                node.hasExecuted = false;
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_3) throw e_3.error; }
        }
        var nodeOrder = [];
        FlowchartUtils.checkNode(nodeOrder, startNode, true);
        if (nodeOrder.length < flw.nodes.length) {
            try {
                for (var _e = __values(flw.nodes), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var node = _f.value;
                    if (node.type != 'start' && node.input.edges.length == 0) {
                        FlowchartUtils.checkNode(nodeOrder, node, false);
                    }
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                }
                finally { if (e_4) throw e_4.error; }
            }
        }
        flw.nodes = nodeOrder;
        flw.ordered = true;
    };
    return FlowchartUtils;
}());



/***/ }),

/***/ "./src/app/shared/models/flowchart/index.ts":
/*!**************************************************!*\
  !*** ./src/app/shared/models/flowchart/index.ts ***!
  \**************************************************/
/*! exports provided: FlowchartUtils */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _flowchart_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./flowchart.utils */ "./src/app/shared/models/flowchart/flowchart.utils.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FlowchartUtils", function() { return _flowchart_utils__WEBPACK_IMPORTED_MODULE_0__["FlowchartUtils"]; });




/***/ }),

/***/ "./src/app/shared/models/node/index.ts":
/*!*********************************************!*\
  !*** ./src/app/shared/models/node/index.ts ***!
  \*********************************************/
/*! exports provided: NodeUtils */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node.utils */ "./src/app/shared/models/node/node.utils.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "NodeUtils", function() { return _node_utils__WEBPACK_IMPORTED_MODULE_0__["NodeUtils"]; });




/***/ }),

/***/ "./src/app/shared/models/node/node.utils.ts":
/*!**************************************************!*\
  !*** ./src/app/shared/models/node/node.utils.ts ***!
  \**************************************************/
/*! exports provided: NodeUtils */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NodeUtils", function() { return NodeUtils; });
/* harmony import */ var _models_procedure__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @models/procedure */ "./src/app/shared/models/procedure/index.ts");
/* harmony import */ var _models_port__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @models/port */ "./src/app/shared/models/port/index.ts");
/* harmony import */ var circular_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! circular-json */ "./node_modules/circular-json/build/circular-json.node.js");
/* harmony import */ var circular_json__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(circular_json__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @utils */ "./src/app/shared/utils/index.ts");
var __values = (undefined && undefined.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (undefined && undefined.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};




var NodeUtils = /** @class */ (function () {
    function NodeUtils() {
    }
    NodeUtils.getNewNode = function () {
        var node = {
            name: "Node",
            id: _utils__WEBPACK_IMPORTED_MODULE_3__["IdGenerator"].getNodeID(),
            position: { x: 0, y: 0 },
            enabled: true,
            type: '',
            procedure: [],
            state: {
                procedure: [],
                input_port: undefined,
                output_port: undefined
            },
            input: _models_port__WEBPACK_IMPORTED_MODULE_1__["PortUtils"].getNewInput(),
            output: _models_port__WEBPACK_IMPORTED_MODULE_1__["PortUtils"].getNewOutput()
        };
        node.input.parentNode = node;
        node.output.parentNode = node;
        return node;
    };
    ;
    NodeUtils.getStartNode = function () {
        var node = NodeUtils.getNewNode();
        node.name = 'Start';
        node.type = 'start';
        node.position = { x: 400, y: 0 };
        return node;
    };
    ;
    NodeUtils.getEndNode = function () {
        var node = NodeUtils.getNewNode();
        node.name = 'End';
        node.type = 'end';
        node.position = { x: 400, y: 400 };
        return node;
    };
    ;
    NodeUtils.deselect_procedure = function (node) {
        var e_1, _a;
        try {
            for (var _b = __values(node.state.procedure), _c = _b.next(); !_c.done; _c = _b.next()) {
                var prod = _c.value;
                prod.selected = false;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        node.state.procedure = [];
    };
    NodeUtils.rearrangeSelected = function (prodList, tempList, prods) {
        var e_2, _a;
        try {
            for (var prods_1 = __values(prods), prods_1_1 = prods_1.next(); !prods_1_1.done; prods_1_1 = prods_1.next()) {
                var pr = prods_1_1.value;
                if (!pr.selected) {
                    if (pr.children)
                        NodeUtils.rearrangeSelected(prodList, tempList, pr.children);
                    continue;
                }
                ;
                var i = 0;
                while (i < tempList.length) {
                    if (tempList[i] === pr) {
                        prodList.push(pr);
                        tempList.splice(i, 1);
                        break;
                    }
                    i += 1;
                }
                if (pr.children)
                    NodeUtils.rearrangeSelected(prodList, tempList, pr.children);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (prods_1_1 && !prods_1_1.done && (_a = prods_1.return)) _a.call(prods_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
    };
    NodeUtils.select_procedure = function (node, procedure, ctrl) {
        var e_3, _a;
        if (!procedure) {
            return;
        }
        if (ctrl) {
            var selIndex = 0;
            var selected = false;
            while (selIndex < node.state.procedure.length) {
                if (node.state.procedure[selIndex] === procedure) {
                    selected = true;
                    node.state.procedure.splice(selIndex, 1);
                    procedure.selected = false;
                    break;
                }
                selIndex += 1;
            }
            if (!selected) {
                procedure.selected = true;
                node.state.procedure.push(procedure);
                var tempArray = node.state.procedure.splice(0, node.state.procedure.length);
                NodeUtils.rearrangeSelected(node.state.procedure, tempArray, node.procedure);
                console.log(node.state.procedure);
            }
        }
        else {
            var sel = procedure.selected;
            try {
                for (var _b = __values(node.state.procedure), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var prod = _c.value;
                    prod.selected = false;
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_3) throw e_3.error; }
            }
            if (sel && node.state.procedure.length === 1 && node.state.procedure[0] === procedure) {
                node.state.procedure = [];
            }
            else {
                node.state.procedure = [procedure];
                procedure.selected = true;
            }
        }
    };
    NodeUtils.insert_procedure = function (node, prod) {
        if (node.state.procedure[0]) {
            if (node.state.procedure[0].children) {
                node.state.procedure[0].children.push(prod);
                prod.parent = node.state.procedure[0];
            }
            else {
                if (node.state.procedure[0].parent) {
                    prod.parent = node.state.procedure[0].parent;
                    var list = prod.parent.children;
                }
                else {
                    var list = node.procedure;
                }
                for (var index in list) {
                    if (list[index].selected) {
                        list.splice(parseInt(index) + 1, 0, prod);
                        break;
                    }
                }
            }
        }
        else {
            node.procedure.push(prod);
        }
    };
    NodeUtils.add_procedure = function (node, type, data) {
        var prod = {};
        prod.type = type;
        NodeUtils.insert_procedure(node, prod);
        // add ID to the procedure
        prod.ID = _utils__WEBPACK_IMPORTED_MODULE_3__["IdGenerator"].getProdID();
        prod.enabled = true;
        prod.print = false;
        // select the procedure
        NodeUtils.select_procedure(node, prod, false);
        switch (prod.type) {
            case _models_procedure__WEBPACK_IMPORTED_MODULE_0__["ProcedureTypes"].Variable:
                prod.argCount = 2;
                prod.args = [{ name: 'var_name', value: undefined, default: undefined }, { name: 'value', value: undefined, default: undefined }];
                break;
            case _models_procedure__WEBPACK_IMPORTED_MODULE_0__["ProcedureTypes"].Foreach:
                prod.argCount = 2;
                prod.args = [{ name: 'i', value: undefined, default: undefined }, { name: 'arr', value: undefined, default: [] }];
                prod.children = [];
                break;
            case _models_procedure__WEBPACK_IMPORTED_MODULE_0__["ProcedureTypes"].While:
                prod.argCount = 1;
                prod.args = [{ name: 'condition', value: undefined, default: undefined }];
                prod.children = [];
                break;
            case _models_procedure__WEBPACK_IMPORTED_MODULE_0__["ProcedureTypes"].If:
            case _models_procedure__WEBPACK_IMPORTED_MODULE_0__["ProcedureTypes"].Elseif:
                prod.argCount = 1;
                prod.args = [{ name: 'condition', value: undefined, default: undefined }];
                prod.children = [];
                break;
            case _models_procedure__WEBPACK_IMPORTED_MODULE_0__["ProcedureTypes"].Else:
                prod.argCount = 0;
                prod.args = [];
                prod.children = [];
                break;
            case _models_procedure__WEBPACK_IMPORTED_MODULE_0__["ProcedureTypes"].Break:
            case _models_procedure__WEBPACK_IMPORTED_MODULE_0__["ProcedureTypes"].Continue:
                prod.argCount = 0;
                prod.args = [];
                break;
            case _models_procedure__WEBPACK_IMPORTED_MODULE_0__["ProcedureTypes"].Function:
                if (!data)
                    throw Error('No function data');
                prod.meta = { module: data.module, name: data.name, inputMode: _models_port__WEBPACK_IMPORTED_MODULE_1__["InputType"].SimpleInput };
                prod.argCount = data.argCount + 1;
                var returnArg = { name: 'var_name', value: undefined, default: undefined };
                if (!data.hasReturn) {
                    returnArg = { name: '__none__', value: undefined, default: undefined };
                }
                // --UNSTABLE--
                // changing the value of the last argument of all functions in input node to be undefined
                if (node.type == 'start') {
                    data.args[data.argCount - 1].value = undefined;
                }
                prod.args = __spread([returnArg], data.args);
                break;
            case _models_procedure__WEBPACK_IMPORTED_MODULE_0__["ProcedureTypes"].Imported:
                prod.meta = { module: data.module, name: data.name, inputMode: _models_port__WEBPACK_IMPORTED_MODULE_1__["InputType"].SimpleInput };
                prod.argCount = data.argCount + 1;
                prod.args = __spread([{ name: 'var_name', value: undefined, default: undefined }], data.args);
                break;
        }
    };
    NodeUtils.updateNode = function (newNode, newPos) {
        newNode.id = _utils__WEBPACK_IMPORTED_MODULE_3__["IdGenerator"].getNodeID();
        newNode.input = _models_port__WEBPACK_IMPORTED_MODULE_1__["PortUtils"].getNewInput();
        newNode.output = _models_port__WEBPACK_IMPORTED_MODULE_1__["PortUtils"].getNewOutput();
        newNode.input.parentNode = newNode;
        newNode.output.parentNode = newNode;
        newNode.position.x = newPos.x;
        newNode.position.y = newPos.y;
        return newNode;
    };
    NodeUtils.updateID = function (prod) {
        if (prod.hasOwnProperty('children')) {
            prod.children.map(function (child) {
                NodeUtils.updateID(child);
            });
        }
        prod.ID = _utils__WEBPACK_IMPORTED_MODULE_3__["IdGenerator"].getProdID();
        return prod;
    };
    NodeUtils.paste_procedure = function (node, prod) {
        var newProd = NodeUtils.updateID(circular_json__WEBPACK_IMPORTED_MODULE_2__["parse"](circular_json__WEBPACK_IMPORTED_MODULE_2__["stringify"](prod)));
        newProd.parent = undefined;
        NodeUtils.insert_procedure(node, newProd);
        NodeUtils.select_procedure(node, newProd, false);
    };
    return NodeUtils;
}());



/***/ }),

/***/ "./src/app/shared/models/port/index.ts":
/*!*********************************************!*\
  !*** ./src/app/shared/models/port/index.ts ***!
  \*********************************************/
/*! exports provided: PortUtils, PortType, InputType, OutputType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ "./src/app/shared/models/port/types.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PortType", function() { return _types__WEBPACK_IMPORTED_MODULE_0__["PortType"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "InputType", function() { return _types__WEBPACK_IMPORTED_MODULE_0__["InputType"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "OutputType", function() { return _types__WEBPACK_IMPORTED_MODULE_0__["OutputType"]; });

/* harmony import */ var _port_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./port.utils */ "./src/app/shared/models/port/port.utils.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PortUtils", function() { return _port_utils__WEBPACK_IMPORTED_MODULE_1__["PortUtils"]; });





/***/ }),

/***/ "./src/app/shared/models/port/port.utils.ts":
/*!**************************************************!*\
  !*** ./src/app/shared/models/port/port.utils.ts ***!
  \**************************************************/
/*! exports provided: PortUtils */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PortUtils", function() { return PortUtils; });
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ "./src/app/shared/models/port/types.ts");
/* harmony import */ var _shared_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @shared/utils */ "./src/app/shared/utils/index.ts");


var PortUtils = /** @class */ (function () {
    function PortUtils() {
    }
    PortUtils.getNewInput = function () {
        var inp = {
            id: _shared_utils__WEBPACK_IMPORTED_MODULE_1__["IdGenerator"].getId(),
            name: 'input',
            type: _types__WEBPACK_IMPORTED_MODULE_0__["PortType"].Input,
            value: undefined,
            default: undefined,
            edges: [],
            meta: {
                mode: _types__WEBPACK_IMPORTED_MODULE_0__["InputType"].SimpleInput,
                opts: {}
            }
        };
        return inp;
    };
    ;
    PortUtils.getNewOutput = function () {
        var oup = {
            id: _shared_utils__WEBPACK_IMPORTED_MODULE_1__["IdGenerator"].getId(),
            name: 'output',
            type: _types__WEBPACK_IMPORTED_MODULE_0__["PortType"].Output,
            edges: [],
            meta: {
                mode: _types__WEBPACK_IMPORTED_MODULE_0__["OutputType"].Text,
            }
        };
        return oup;
    };
    ;
    return PortUtils;
}());



/***/ }),

/***/ "./src/app/shared/models/port/types.ts":
/*!*********************************************!*\
  !*** ./src/app/shared/models/port/types.ts ***!
  \*********************************************/
/*! exports provided: PortType, InputType, OutputType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PortType", function() { return PortType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InputType", function() { return InputType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OutputType", function() { return OutputType; });
var PortType;
(function (PortType) {
    PortType[PortType["Input"] = 0] = "Input";
    PortType[PortType["Output"] = 1] = "Output";
})(PortType || (PortType = {}));
var InputType;
(function (InputType) {
    InputType[InputType["SimpleInput"] = 0] = "SimpleInput";
    InputType[InputType["Slider"] = 1] = "Slider";
    InputType[InputType["Checkbox"] = 2] = "Checkbox";
    InputType[InputType["URL"] = 3] = "URL";
    InputType[InputType["File"] = 4] = "File";
})(InputType || (InputType = {}));
var OutputType;
(function (OutputType) {
    OutputType[OutputType["Text"] = 0] = "Text";
    OutputType[OutputType["Code"] = 1] = "Code";
})(OutputType || (OutputType = {}));


/***/ }),

/***/ "./src/app/shared/models/procedure/index.ts":
/*!**************************************************!*\
  !*** ./src/app/shared/models/procedure/index.ts ***!
  \**************************************************/
/*! exports provided: ProcedureTypes */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ "./src/app/shared/models/procedure/types.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ProcedureTypes", function() { return _types__WEBPACK_IMPORTED_MODULE_0__["ProcedureTypes"]; });




/***/ }),

/***/ "./src/app/shared/models/procedure/types.ts":
/*!**************************************************!*\
  !*** ./src/app/shared/models/procedure/types.ts ***!
  \**************************************************/
/*! exports provided: ProcedureTypes */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ProcedureTypes", function() { return ProcedureTypes; });
var ProcedureTypes;
(function (ProcedureTypes) {
    ProcedureTypes[ProcedureTypes["Variable"] = 0] = "Variable";
    ProcedureTypes[ProcedureTypes["If"] = 1] = "If";
    ProcedureTypes[ProcedureTypes["Elseif"] = 2] = "Elseif";
    ProcedureTypes[ProcedureTypes["Else"] = 3] = "Else";
    ProcedureTypes[ProcedureTypes["Foreach"] = 4] = "Foreach";
    ProcedureTypes[ProcedureTypes["While"] = 5] = "While";
    ProcedureTypes[ProcedureTypes["Break"] = 6] = "Break";
    ProcedureTypes[ProcedureTypes["Continue"] = 7] = "Continue";
    ProcedureTypes[ProcedureTypes["Function"] = 8] = "Function";
    ProcedureTypes[ProcedureTypes["Imported"] = 9] = "Imported";
})(ProcedureTypes || (ProcedureTypes = {}));


/***/ }),

/***/ "./src/app/shared/shared.module.ts":
/*!*****************************************!*\
  !*** ./src/app/shared/shared.module.ts ***!
  \*****************************************/
/*! exports provided: SharedModule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SharedModule", function() { return SharedModule; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm5/common.js");
/* harmony import */ var _angular_router__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/router */ "./node_modules/@angular/router/fesm5/router.js");
/* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/forms */ "./node_modules/@angular/forms/fesm5/forms.js");
/* harmony import */ var _angular_material__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/material */ "./node_modules/@angular/material/esm5/material.es5.js");
/* harmony import */ var _app_ngFlowchart_svg__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../app/ngFlowchart-svg */ "./src/app/ngFlowchart-svg/index.ts");
/* harmony import */ var angular_split__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! angular-split */ "./node_modules/angular-split/fesm5/angular-split.js");
/* harmony import */ var _directives_filesys__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./directives/filesys */ "./src/app/shared/directives/filesys/index.ts");
/* harmony import */ var _components_execute_execute_component__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./components/execute/execute.component */ "./src/app/shared/components/execute/execute.component.ts");
/* harmony import */ var _components_not_found_not_found_component__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./components/not-found/not-found.component */ "./src/app/shared/components/not-found/not-found.component.ts");
/* harmony import */ var _components_navigation_navigation_component__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./components/navigation/navigation.component */ "./src/app/shared/components/navigation/navigation.component.ts");
/* harmony import */ var _components_header_header_component__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./components/header/header.component */ "./src/app/shared/components/header/header.component.ts");
/* harmony import */ var _components_add_components_add_output_component__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./components/add-components/add_output.component */ "./src/app/shared/components/add-components/add_output.component.ts");
/* harmony import */ var _components_add_components_add_node_component__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./components/add-components/add_node.component */ "./src/app/shared/components/add-components/add_node.component.ts");
/* harmony import */ var _components_add_components_add_input_component__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./components/add-components/add_input.component */ "./src/app/shared/components/add-components/add_input.component.ts");
/* harmony import */ var _components_parameter_viewer_parameter_viewer_component__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./components/parameter-viewer/parameter-viewer.component */ "./src/app/shared/components/parameter-viewer/parameter-viewer.component.ts");
/* harmony import */ var _components_parameter_viewer_input_port_viewer_input_port_viewer_component__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./components/parameter-viewer/input-port-viewer/input-port-viewer.component */ "./src/app/shared/components/parameter-viewer/input-port-viewer/input-port-viewer.component.ts");
/* harmony import */ var _components_parameter_viewer_procedure_input_viewer_procedure_input_viewer_component__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./components/parameter-viewer/procedure-input-viewer/procedure-input-viewer.component */ "./src/app/shared/components/parameter-viewer/procedure-input-viewer/procedure-input-viewer.component.ts");
/* harmony import */ var _components_file__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./components/file */ "./src/app/shared/components/file/index.ts");
/* harmony import */ var _mViewer_mobius_viewer_module__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../mViewer/mobius-viewer.module */ "./src/app/mViewer/mobius-viewer.module.ts");
/* harmony import */ var _directives_textarea__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./directives/textarea */ "./src/app/shared/directives/textarea/index.ts");
/*
 *  This module is to be imported ONLY by the AppModule
 *  Contains all global services
 *
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (undefined && undefined.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};





















var SharedModule = /** @class */ (function () {
    function SharedModule(shared) {
        /*
        /// Prevents any module apart from AppModule from re-importing
        if(shared){
            throw new Error("Core Module has already been imported");
        }
        */
    }
    SharedModule = __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"])({
            providers: [],
            declarations: [
                _directives_filesys__WEBPACK_IMPORTED_MODULE_7__["MbFileReaderDirective"],
                _directives_textarea__WEBPACK_IMPORTED_MODULE_20__["autogrowDirective"],
                _components_execute_execute_component__WEBPACK_IMPORTED_MODULE_8__["ExecuteComponent"],
                _components_not_found_not_found_component__WEBPACK_IMPORTED_MODULE_9__["PageNotFoundComponent"],
                _components_navigation_navigation_component__WEBPACK_IMPORTED_MODULE_10__["NavigationComponent"],
                _components_header_header_component__WEBPACK_IMPORTED_MODULE_11__["HeaderComponent"],
                _components_add_components_add_node_component__WEBPACK_IMPORTED_MODULE_13__["AddNodeComponent"], _components_add_components_add_input_component__WEBPACK_IMPORTED_MODULE_14__["AddInputComponent"], _components_add_components_add_output_component__WEBPACK_IMPORTED_MODULE_12__["AddOutputComponent"],
                _components_parameter_viewer_parameter_viewer_component__WEBPACK_IMPORTED_MODULE_15__["ParameterViewerComponent"], _components_parameter_viewer_input_port_viewer_input_port_viewer_component__WEBPACK_IMPORTED_MODULE_16__["InputPortViewerComponent"], _components_parameter_viewer_procedure_input_viewer_procedure_input_viewer_component__WEBPACK_IMPORTED_MODULE_17__["procedureInputViewerComponent"],
                _components_file__WEBPACK_IMPORTED_MODULE_18__["NewFileComponent"], _components_file__WEBPACK_IMPORTED_MODULE_18__["SaveFileComponent"], _components_file__WEBPACK_IMPORTED_MODULE_18__["LoadFileComponent"]
            ],
            imports: [
                _angular_common__WEBPACK_IMPORTED_MODULE_1__["CommonModule"],
                _angular_router__WEBPACK_IMPORTED_MODULE_2__["RouterModule"],
                _angular_material__WEBPACK_IMPORTED_MODULE_4__["MatSliderModule"], _angular_material__WEBPACK_IMPORTED_MODULE_4__["MatCheckboxModule"],
                _app_ngFlowchart_svg__WEBPACK_IMPORTED_MODULE_5__["SVGFlowchartModule"],
                _mViewer_mobius_viewer_module__WEBPACK_IMPORTED_MODULE_19__["MobiusViewerModule"],
                angular_split__WEBPACK_IMPORTED_MODULE_6__["AngularSplitModule"],
                _angular_forms__WEBPACK_IMPORTED_MODULE_3__["FormsModule"],
                _angular_material__WEBPACK_IMPORTED_MODULE_4__["MatIconModule"],
            ],
            entryComponents: [],
            exports: [
                _angular_forms__WEBPACK_IMPORTED_MODULE_3__["FormsModule"],
                _app_ngFlowchart_svg__WEBPACK_IMPORTED_MODULE_5__["SVGFlowchartModule"],
                _mViewer_mobius_viewer_module__WEBPACK_IMPORTED_MODULE_19__["MobiusViewerModule"],
                angular_split__WEBPACK_IMPORTED_MODULE_6__["AngularSplitModule"],
                _directives_filesys__WEBPACK_IMPORTED_MODULE_7__["MbFileReaderDirective"],
                _directives_textarea__WEBPACK_IMPORTED_MODULE_20__["autogrowDirective"],
                _components_execute_execute_component__WEBPACK_IMPORTED_MODULE_8__["ExecuteComponent"],
                _components_not_found_not_found_component__WEBPACK_IMPORTED_MODULE_9__["PageNotFoundComponent"],
                _components_navigation_navigation_component__WEBPACK_IMPORTED_MODULE_10__["NavigationComponent"],
                _components_header_header_component__WEBPACK_IMPORTED_MODULE_11__["HeaderComponent"],
                _components_add_components_add_node_component__WEBPACK_IMPORTED_MODULE_13__["AddNodeComponent"],
                _components_add_components_add_input_component__WEBPACK_IMPORTED_MODULE_14__["AddInputComponent"],
                _components_add_components_add_output_component__WEBPACK_IMPORTED_MODULE_12__["AddOutputComponent"],
                _components_parameter_viewer_parameter_viewer_component__WEBPACK_IMPORTED_MODULE_15__["ParameterViewerComponent"],
                _components_file__WEBPACK_IMPORTED_MODULE_18__["NewFileComponent"], _components_file__WEBPACK_IMPORTED_MODULE_18__["SaveFileComponent"], _components_file__WEBPACK_IMPORTED_MODULE_18__["LoadFileComponent"]
            ]
        }),
        __param(0, Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Optional"])()), __param(0, Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["SkipSelf"])()),
        __metadata("design:paramtypes", [SharedModule])
    ], SharedModule);
    return SharedModule;
}());



/***/ }),

/***/ "./src/app/shared/utils/GUID.ts":
/*!**************************************!*\
  !*** ./src/app/shared/utils/GUID.ts ***!
  \**************************************/
/*! exports provided: IdGenerator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IdGenerator", function() { return IdGenerator; });
var IdGenerator = /** @class */ (function () {
    function IdGenerator() {
    }
    IdGenerator.s4 = function () {
        return Math.floor((1 + Math.random()) * 0x10000)
            .toString(16)
            .substring(1);
    };
    IdGenerator.getId = function () {
        return this.s4() + this.s4() + '-' + this.s4() + '-' + this.s4() + '-' +
            this.s4() + '-' + this.s4() + this.s4() + this.s4();
    };
    IdGenerator.getNodeID = function () {
        return 'node_' + Math.random().toString(36).substr(2, 16);
    };
    IdGenerator.getProdID = function () {
        return 'prod-' + Math.random().toString(36).substr(2, 16);
    };
    return IdGenerator;
}());



/***/ }),

/***/ "./src/app/shared/utils/index.ts":
/*!***************************************!*\
  !*** ./src/app/shared/utils/index.ts ***!
  \***************************************/
/*! exports provided: IdGenerator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _GUID__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GUID */ "./src/app/shared/utils/GUID.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "IdGenerator", function() { return _GUID__WEBPACK_IMPORTED_MODULE_0__["IdGenerator"]; });




/***/ }),

/***/ "./src/app/views/index.ts":
/*!********************************!*\
  !*** ./src/app/views/index.ts ***!
  \********************************/
/*! exports provided: ViewPublishModule, ViewPublishComponent, ViewEditorModule, ViewEditorComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _view_publish_view_publish_module__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./view-publish/view-publish.module */ "./src/app/views/view-publish/view-publish.module.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ViewPublishModule", function() { return _view_publish_view_publish_module__WEBPACK_IMPORTED_MODULE_0__["ViewPublishModule"]; });

/* harmony import */ var _view_publish_view_publish_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./view-publish/view-publish.component */ "./src/app/views/view-publish/view-publish.component.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ViewPublishComponent", function() { return _view_publish_view_publish_component__WEBPACK_IMPORTED_MODULE_1__["ViewPublishComponent"]; });

/* harmony import */ var _view_editor_view_editor_module__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./view-editor/view-editor.module */ "./src/app/views/view-editor/view-editor.module.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ViewEditorModule", function() { return _view_editor_view_editor_module__WEBPACK_IMPORTED_MODULE_2__["ViewEditorModule"]; });

/* harmony import */ var _view_editor_view_editor_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./view-editor/view-editor.component */ "./src/app/views/view-editor/view-editor.component.ts");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ViewEditorComponent", function() { return _view_editor_view_editor_component__WEBPACK_IMPORTED_MODULE_3__["ViewEditorComponent"]; });

//export * from './view-about/view-about.module';
//export * from './view-gallery/view-gallery.module';






/***/ }),

/***/ "./src/app/views/view-editor/parameter-editor/parameter-editor.component.html":
/*!************************************************************************************!*\
  !*** ./src/app/views/view-editor/parameter-editor/parameter-editor.component.html ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<div class='flowchart-info'>\r\n\t<input [(ngModel)]='flowchart.name' size={{flowchart.name?.length||1}}>\r\n\t<textarea autogrow [(ngModel)]='flowchart.description' placeholder=\"flowchart description\"></textarea>\r\n</div>\r\n<hr>\r\n<div class='container--input'>\r\n\t<procedure-input-editor *ngFor=\"let prod of node.procedure\" [prod]=\"prod\" ></procedure-input-editor>\r\n</div>\r\n\t\r\n<!--\r\n<section *ngIf=\"node.type != 'end'\">\r\n\t<panel-header [node]='node' [title]=\"'inputs'\"></panel-header>\r\n\t<div class='container--input'>\r\n\t\t<input-port-editor [port]=\"node?.input\" ></input-port-editor>\r\n\t</div>\r\n</section>\r\n<section *ngIf=\"node.type != 'start'\">\r\n\t<panel-header [node]='node' [title]=\"'output'\"></panel-header>\r\n\t<div class='container--output'>\r\n\t\t<output-port-editor [port]=\"node?.output\" ></output-port-editor>\r\n\t</div>\r\n</section>\r\n-->\r\n"

/***/ }),

/***/ "./src/app/views/view-editor/parameter-editor/parameter-editor.component.scss":
/*!************************************************************************************!*\
  !*** ./src/app/views/view-editor/parameter-editor/parameter-editor.component.scss ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "div[class^=\"container--\"] {\n  display: flex;\n  flex-direction: column;\n  padding-left: 10px;\n  margin: 0px 0px; }\n\n.flowchart-info {\n  display: -ms-grid;\n  display: grid;\n  padding-left: 10px;\n  margin: 5px 0px;\n  width: 100%; }\n\ninput {\n  color: #505050;\n  background-color: #fafafa;\n  border: none;\n  width: -webkit-fit-content;\n  width: -moz-fit-content;\n  width: fit-content;\n  border-left: 1px solid gainsboro;\n  border-bottom: 1px solid gainsboro;\n  padding: 5px;\n  margin-left: 3px;\n  font-weight: 600;\n  font-style: italic;\n  min-width: 40px;\n  max-width: 300px;\n  font-size: 12px;\n  vertical-align: bottom; }\n\ninput.disabled-input {\n    border-bottom: none; }\n\ntextarea {\n  color: #505050;\n  background-color: #fafafa;\n  border: none;\n  border-left: 1px solid gainsboro;\n  border-bottom: 1px solid gainsboro;\n  padding-left: 5px;\n  font-family: sans-serif;\n  font-size: 12px;\n  margin: 10px 0px 5px 3px;\n  height: 18px;\n  width: 90%;\n  resize: none; }\n\nhr {\n  width: inherit;\n  border-top: 2px solid gainsboro; }\n"

/***/ }),

/***/ "./src/app/views/view-editor/parameter-editor/parameter-editor.component.ts":
/*!**********************************************************************************!*\
  !*** ./src/app/views/view-editor/parameter-editor/parameter-editor.component.ts ***!
  \**********************************************************************************/
/*! exports provided: ParameterEditorComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParameterEditorComponent", function() { return ParameterEditorComponent; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

var ParameterEditorComponent = /** @class */ (function () {
    function ParameterEditorComponent() {
    }
    __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(),
        __metadata("design:type", Object)
    ], ParameterEditorComponent.prototype, "node", void 0);
    __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(),
        __metadata("design:type", Object)
    ], ParameterEditorComponent.prototype, "flowchart", void 0);
    ParameterEditorComponent = __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"])({
            selector: 'parameter-editor',
            template: __webpack_require__(/*! ./parameter-editor.component.html */ "./src/app/views/view-editor/parameter-editor/parameter-editor.component.html"),
            styles: [__webpack_require__(/*! ./parameter-editor.component.scss */ "./src/app/views/view-editor/parameter-editor/parameter-editor.component.scss")]
        })
    ], ParameterEditorComponent);
    return ParameterEditorComponent;
}());



/***/ }),

/***/ "./src/app/views/view-editor/parameter-editor/procedure-input-editor/procedure-input-editor.component.html":
/*!*****************************************************************************************************************!*\
  !*** ./src/app/views/view-editor/parameter-editor/procedure-input-editor/procedure-input-editor.component.html ***!
  \*****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<div class='container container--parameter'>\r\n    <input [class.disabled-input]='true' value='{{prod.args[prod.argCount-2].value||\"Undefined\"}}:' size='15' disabled>\r\n\r\n    <select name={{prod.ID}}_type [(ngModel)]=\"prod.meta.inputMode\" tabindex=\"-1\">\r\n        <option \r\n            *ngFor=\"let ptype of PortTypesArr\" \r\n            [value]=\"PortTypes[ptype]\" \r\n            [selected]=\"prod.meta.inputMode == ptype\">{{ptype}}</option>\r\n    </select>\r\n    <ng-container [ngSwitch]=\"prod.meta.inputMode\" >\r\n        <input *ngSwitchCase=\"PortTypes.SimpleInput\" [(ngModel)]='prod.args[prod.argCount-1].default' placeholder='Default Value' size={{prod.args[prod.argCount-1].default.length||13}}>\r\n\r\n        <div class='div--slider' *ngSwitchCase=\"PortTypes.Slider\">\r\n            <input [(ngModel)]='prod.args[prod.argCount-1].min' placeholder='Min' size={{prod.args[prod.argCount-1].min?.length||1}}>\r\n            <input [(ngModel)]='prod.args[prod.argCount-1].max' placeholder='Max' size={{prod.args[prod.argCount-1].max?.length||1}}>\r\n            <mat-slider\r\n                [(ngModel)]='prod.args[prod.argCount-1].default'\r\n                thumbLabel\r\n                tickInterval=\"auto\"\r\n                min={{prod.args[prod.argCount-1].min||0}}\r\n                max={{prod.args[prod.argCount-1].max||100}}></mat-slider>\r\n            <input [class.disabled-input]='true' [(ngModel)]='prod.args[prod.argCount-1].default' size={{prod.args[prod.argCount-1].default?.length||1}} disabled>\r\n\r\n        </div>\r\n        <input *ngSwitchCase=\"PortTypes.Checkbox\" [(ngModel)]='prod.args[prod.argCount-1].default' name='prod.args[prod.argCount-1].default' type=\"checkbox\">\r\n        <input *ngSwitchCase=\"PortTypes.URL\" [(ngModel)]='prod.args[prod.argCount-1].default' name='prod.args[prod.argCount-1].default' placeholder='Default URL'>\r\n        <input *ngSwitchCase=\"PortTypes.File\" (change)=\"onFileChange($event)\" type=\"file\">\r\n    </ng-container>\r\n\r\n    \r\n    <!--\r\n    <div class='parameter__name' [ngSwitch]=\"prod.meta.mode\">\r\n        <input *ngSwitchCase=\"PortTypes.SimpleInput\" [(ngModel)]='prod.args[prod.argCount-1].default' name='prod.args[prod.argCount-1].default' placeholder='Default Value'>\r\n        <div *ngSwitchCase=\"PortTypes.Slider\">\r\n            <input [(ngModel)]='prod.args[prod.argCount-1].default' value='prod.args[prod.argCount-1].default' disabled>\r\n            <input [(ngModel)]='prod.args[prod.argCount-1].default' name='prod.args[prod.argCount-1].default' type=\"range\" >\r\n        </div>\r\n        <input *ngSwitchCase=\"PortTypes.Checkbox\" [(ngModel)]='prod.args[prod.argCount-1].default' name='prod.args[prod.argCount-1].default' type=\"checkbox\">\r\n        <input *ngSwitchCase=\"PortTypes.URL\" [(ngModel)]='prod.args[prod.argCount-1].default' name='prod.args[prod.argCount-1].default' placeholder='Default URL'>\r\n        <input *ngSwitchCase=\"PortTypes.File\" (change)=\"onFileChange($event)\" type=\"file\">\r\n    </div>\r\n\r\n    <select name={{prod.name}}_type *ngIf=\"prod.parentNode.type=='start'\"  [(ngModel)]=\"prod.meta.mode\">\r\n        <option \r\n            *ngFor=\"let ptype of PortTypesArr\" \r\n            [value]=\"PortTypes[ptype]\" \r\n            [selected]=\"prod.meta.mode == ptype\">{{ptype}}</option>\r\n    </select>\r\n    -->\r\n\r\n</div>\r\n\r\n"

/***/ }),

/***/ "./src/app/views/view-editor/parameter-editor/procedure-input-editor/procedure-input-editor.component.scss":
/*!*****************************************************************************************************************!*\
  !*** ./src/app/views/view-editor/parameter-editor/procedure-input-editor/procedure-input-editor.component.scss ***!
  \*****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ".container {\n  margin: 5px 0px; }\n\n.container--parameter {\n  display: inline-block;\n  flex-direction: row;\n  flex-wrap: wrap;\n  color: #505050;\n  vertical-align: bottom;\n  padding-bottom: 5px;\n  border-bottom: 1px solid gainsboro;\n  border-left: 1px solid gainsboro;\n  width: 100%; }\n\nselect {\n  color: #505050;\n  background-color: #fafafa;\n  border: 1px solid #505050; }\n\ninput {\n  color: #505050;\n  background-color: #fafafa;\n  border: none;\n  border-bottom: 1px solid #505050;\n  margin-left: 5px;\n  vertical-align: bottom; }\n\ninput.disabled-input {\n    border-bottom: none; }\n\n.slider-val {\n  color: #505050;\n  resize: horizontal;\n  size: 2;\n  min-width: 1px;\n  max-width: 300px;\n  width: 20px; }\n\n.container--input {\n  display: inline-flex;\n  flex-direction: row; }\n\n.div--slider {\n  display: inline-flex;\n  flex-direction: row; }\n\n.parameter__name {\n  width: 100px;\n  height: auto;\n  word-wrap: break-word; }\n\nmat-slider {\n  width: 300px; }\n"

/***/ }),

/***/ "./src/app/views/view-editor/parameter-editor/procedure-input-editor/procedure-input-editor.component.ts":
/*!***************************************************************************************************************!*\
  !*** ./src/app/views/view-editor/parameter-editor/procedure-input-editor/procedure-input-editor.component.ts ***!
  \***************************************************************************************************************/
/*! exports provided: procedureInputEditorComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "procedureInputEditorComponent", function() { return procedureInputEditorComponent; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var _models_port__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @models/port */ "./src/app/shared/models/port/index.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


var keys = Object.keys(_models_port__WEBPACK_IMPORTED_MODULE_1__["InputType"]);
var procedureInputEditorComponent = /** @class */ (function () {
    function procedureInputEditorComponent() {
        this.delete = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.PortTypes = _models_port__WEBPACK_IMPORTED_MODULE_1__["InputType"];
        this.PortTypesArr = keys.slice(keys.length / 2);
    }
    procedureInputEditorComponent.prototype.editOptions = function () { };
    procedureInputEditorComponent.prototype.onFileChange = function (event) {
        this.prod.args[this.prod.args.length - 1] = event.target.files[0];
    };
    __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(),
        __metadata("design:type", Object)
    ], procedureInputEditorComponent.prototype, "prod", void 0);
    __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"])(),
        __metadata("design:type", Object)
    ], procedureInputEditorComponent.prototype, "delete", void 0);
    procedureInputEditorComponent = __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"])({
            selector: 'procedure-input-editor',
            template: __webpack_require__(/*! ./procedure-input-editor.component.html */ "./src/app/views/view-editor/parameter-editor/procedure-input-editor/procedure-input-editor.component.html"),
            styles: [__webpack_require__(/*! ./procedure-input-editor.component.scss */ "./src/app/views/view-editor/parameter-editor/procedure-input-editor/procedure-input-editor.component.scss")]
        }),
        __metadata("design:paramtypes", [])
    ], procedureInputEditorComponent);
    return procedureInputEditorComponent;
}());



/***/ }),

/***/ "./src/app/views/view-editor/procedure-item/procedure-item.component.html":
/*!********************************************************************************!*\
  !*** ./src/app/views/view-editor/procedure-item/procedure-item.component.html ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<div class='container--line' \r\n    [class.selected]=\"data.selected\"\r\n    [class.error]=\"data.hasError\"\r\n    [class.disabled]=\"!data.enabled\"\r\n    [ngSwitch]=\"data.type\"\r\n    (click)='emitSelect($event, data)'>\r\n    <div class='container--item' >\r\n        <!-- Variable Assignment Template -->\r\n        <div class='line--item' *ngSwitchCase=\"ProcedureTypes.Variable\">\r\n            <input class='input--var'\r\n                [ngModel]='data.args[0].value'\r\n                (ngModelChange)='data.args[0].value=varMod($event)'\r\n                name='data.args[0].name'\r\n                placeholder={{data.args[0].name}}>  \r\n            = \r\n            <input class='input--arg'\r\n                [(ngModel)]='data.args[1].value'\r\n                name='data.args[1].name'\r\n                placeholder={{data.args[1].name}}\r\n                size=\"1\"\r\n                size={{data.args[1].value?.length||data.args[1].name.length}}>  \r\n            </div>\r\n\r\n        <!-- IF Template -->\r\n        <div class='line--item hasChildren' *ngSwitchCase=\"ProcedureTypes.If\">\r\n            <div class='function-text'>\r\n                If\r\n            </div>\r\n            ( <input class='input--arg'\r\n                    (cut)='stopProp($event)' (paste)='stopProp($event)'\r\n                    [(ngModel)]='data.args[0].value'\r\n                    name='data.args[0].name'\r\n                    placeholder={{data.args[0].name}}\r\n                    size={{data.args[0].value?.length||data.args[0].name.length}}>  \r\n                    )\r\n\r\n        </div>\r\n\r\n        <!-- ELSEIF Template -->\r\n        <div class='line--item hasChildren' *ngSwitchCase=\"ProcedureTypes.Elseif\">\r\n            <div class='function-text'>\r\n                Else if\r\n            </div>\r\n            \r\n        \r\n        ( <input class='input--arg'\r\n                (cut)='stopProp($event)' (paste)='stopProp($event)' \r\n                [(ngModel)]='data.args[0].value'\r\n                name='data.args[0].name'\r\n                placeholder={{data.args[0].name}}\r\n                size={{data.args[0].value?.length||data.args[0].name.length}}>  \r\n                )\r\n        </div>\r\n\r\n        <!-- ELSE Template -->\r\n        <div class='line--item hasChildren' *ngSwitchCase=\"ProcedureTypes.Else\">\r\n            <div class='function-text'>\r\n                Else\r\n            </div>\r\n        </div>\r\n\r\n        <!-- BREAK Template -->\r\n        <div class='line--item' *ngSwitchCase=\"ProcedureTypes.Break\">\r\n            <div class='function-text'>\r\n                Break\r\n            </div>\r\n        </div>\r\n\r\n        <!-- CONTINUE Template -->\r\n        <div class='line--item' *ngSwitchCase=\"ProcedureTypes.Continue\">\r\n            <div class='function-text'>\r\n                Continue\r\n            </div>\r\n        </div>\r\n\r\n\r\n    <!-- FOREACH Template -->\r\n        <div class='line--item hasChildren' *ngSwitchCase=\"ProcedureTypes.Foreach\">\r\n                <div class='function-text'>\r\n                    For\r\n                </div>\r\n                <input class='input--arg'\r\n                    (cut)='stopProp($event)' (paste)='stopProp($event)'\r\n                    [(ngModel)]='data.args[0].value'\r\n                    name='data.args[0].name'\r\n                    placeholder={{data.args[0].name}}\r\n                    size={{data.args[0].value?.length||data.args[0].name.length}}>  \r\n                <div class='function-text'>\r\n                    in\r\n                </div>\r\n                <input class='input--arg'\r\n                    (cut)='stopProp($event)' (paste)='stopProp($event)'\r\n                    [(ngModel)]='data.args[1].value'\r\n                    name='data.args[1].name'\r\n                    placeholder={{data.args[1].name}}\r\n                    size={{data.args[1].value?.length||data.args[1].name.length}}>  \r\n                    \r\n        </div>\r\n\r\n        <!-- WHILE Template -->\r\n        <div class='line--item hasChildren' *ngSwitchCase=\"ProcedureTypes.While\">\r\n            <div class='function-text'>\r\n                While\r\n            </div>\r\n            <input class='input--arg' \r\n                    (cut)='stopProp($event)' (paste)='stopProp($event)'\r\n                    [(ngModel)]='data.args[0].value'\r\n                    name='data.args[0].name'\r\n                    placeholder={{data.args[0].name}}\r\n                    size={{data.args[0].value?.length||data.args[0].name.length}}>  \r\n\r\n        </div>\r\n        \r\n        <!-- Function Template -->\r\n        <div class='line--item' *ngSwitchCase=\"ProcedureTypes.Function\">\r\n            <ng-container *ngIf=\"data.meta.module.toUpperCase() !='OUTPUT' && data.args[0].name !=='__none__'\">\r\n                <input class='input--var'\r\n                [ngModel]='data.args[0].value'\r\n                (ngModelChange)='data.args[0].value=varMod($event)'\r\n                (cut)='stopProp($event)' \r\n                (paste)='stopProp($event)'\r\n                placeholder={{data.args[0].name}}>  \r\n                = \r\n\r\n            </ng-container>\r\n            <div class='function-text'>{{data.meta.module}}.{{data.meta.name}} </div>\r\n\r\n            <ng-container *ngFor='let p of data.args.slice(1);let i=index'>\r\n                <!--\r\n                <input *ngIf=\"p.name.toUpperCase() !== '__MODEL__'; else text_template\" \r\n                \r\n                (cut)='stopProp($event)' \r\n                (paste)='stopProp($event)' \r\n                [(ngModel)]='p.value' \r\n                placeholder={{p.name}}>    \r\n                \r\n                <ng-template #text_template>\r\n                    model,\r\n                </ng-template>\r\n                -->\r\n\r\n                <input *ngIf=\"p.name.indexOf('__') == -1\" \r\n                        class='input--arg' \r\n                        (cut)='stopProp($event)' \r\n                        (paste)='stopProp($event)' \r\n                        [(ngModel)]='p.value' \r\n                        placeholder={{p.name}}\r\n                        size={{p.value?.length||p.name.length}}>    \r\n                \r\n                <!--\r\n\r\n                <ng-template #model_template>\r\n                    <ng-container *ngIf=\"p.name == model; else params_template\">\r\n                        model,\r\n                    </ng-container>\r\n                </ng-template>\r\n                <ng-template #params_template>\r\n                    <ng-container *ngIf=\"p.name == constList;\">\r\n                        const_list,\r\n                    </ng-container>\r\n                </ng-template>\r\n                -->\r\n\r\n            </ng-container>\r\n\r\n        </div>\r\n\r\n        <!-- Imported Function Template -->\r\n        <div class='line--item' *ngSwitchCase=\"ProcedureTypes.Imported\">\r\n            <input class='input--var'\r\n                    [ngModel]='data.args[0].value'\r\n                    (ngModelChange)='data.args[0].value=varMod($event)'\r\n                    (cut)='stopProp($event)' (paste)='stopProp($event)'\r\n                    placeholder={{data.args[0].name}}>  \r\n            = \r\n            <div class='function-text'>{{data.meta.name}} </div> \r\n            \r\n            <ng-container *ngFor='let p of data.args.slice(1);let i=index'>\r\n                <input class='input--arg' \r\n                        (cut)='stopProp($event)' (paste)='stopProp($event)' \r\n                        [(ngModel)]='p.value' \r\n                        placeholder={{p.name}}\r\n                        size={{p.value?.length||p.name.length}}>    \r\n            </ng-container>\r\n            \r\n\r\n        </div>\r\n\r\n\r\n        <!-- delete button-->\r\n        <button class='btn' mat-icon-button title=\"Delete Procedure\" (click)=\"emitDelete()\" tabindex=\"-1\">\r\n            <mat-icon class='icon'>delete_outline</mat-icon>\r\n        </button>\r\n        <!-- Disable button-->\r\n        <button class='btn' mat-icon-button title=\"Disable Procedure\" [class.highlighted]='!data.enabled' (click)='markDisabled()' tabindex=\"-1\">\r\n            <mat-icon class='icon'>tv_off</mat-icon>\r\n        </button>\r\n        <!-- Print button-->\r\n        <button *ngIf='canBePrinted()' class='btn' mat-icon-button title=\"Print Result In Console\" [class.highlighted]='data.print' (click)='markPrint()' tabindex=\"-1\">\r\n            <mat-icon class='icon'>print</mat-icon>\r\n        </button>\r\n        <!-- help button-->\r\n        <button class='btn' mat-icon-button title=\"Help\" tabindex=\"-1\">\r\n            <mat-icon class='icon'>help</mat-icon>\r\n        </button>\r\n    </div>\r\n    <!-- list of child procedures (if the procedure has children) -->\r\n    <div *ngIf=\"data?.children\" class='container--nested'>\r\n        <procedure-item \r\n            *ngFor=\"let line of data?.children; let idx=index\" \r\n            [data]=\"line\"\r\n            (select)='selectChild($event, line)'\r\n            (delete)='deleteChild(idx)'></procedure-item>\r\n    </div>\r\n\r\n\r\n</div>\r\n\r\n"

/***/ }),

/***/ "./src/app/views/view-editor/procedure-item/procedure-item.component.scss":
/*!********************************************************************************!*\
  !*** ./src/app/views/view-editor/procedure-item/procedure-item.component.scss ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ".container--nested {\n  padding-left: 0px; }\n\n.container--line {\n  margin: 8px 0px 8px 10px;\n  padding: 2px 0px 2px 2px;\n  border-bottom: 1px solid gainsboro;\n  border-left: 1px solid gainsboro;\n  color: #505050;\n  min-height: 22px;\n  opacity: 1; }\n\n.container--line.disabled {\n    opacity: 0.5; }\n\n.container--line.selected {\n    border: 1px solid #000096;\n    background-color: gainsboro; }\n\n.container--line.error {\n    border: 1px solid red; }\n\n.container--item {\n  margin: none;\n  padding: none;\n  border: none; }\n\n.btn {\n  height: 24px;\n  width: 24px;\n  float: right;\n  background-color: transparent;\n  border: none;\n  display: none;\n  color: #777; }\n\n.btn.highlighted {\n    background-color: #ff9696; }\n\n.container--item:hover .btn {\n  display: block; }\n\n.icon {\n  vertical-align: top;\n  font-size: 20px; }\n\n.line--item {\n  display: inline-block;\n  color: #505050; }\n\n/*\r\n.hasChildren::before{\r\n    content: '\\25B6';\r\n    position: absolute;\r\n    left: 3px;\r\n    font-size: 8px;\r\n}\r\n*/\n\n.input--var {\n  width: 70px;\n  background-color: #fafafa;\n  border: none;\n  border-bottom: 1px solid #505050;\n  margin-right: 5px; }\n\n.input--arg {\n  resize: horizontal;\n  min-width: 1px;\n  max-width: 300px;\n  width: auto;\n  background-color: #fafafa;\n  border: none;\n  border-bottom: 1px solid #505050;\n  margin-left: 5px; }\n\ninput:focus {\n  border: 1px solid #000096; }\n\n.function-text {\n  display: inline-block;\n  white-space: normal;\n  font-style: italic;\n  color: #be8c1e;\n  font-weight: 600; }\n"

/***/ }),

/***/ "./src/app/views/view-editor/procedure-item/procedure-item.component.ts":
/*!******************************************************************************!*\
  !*** ./src/app/views/view-editor/procedure-item/procedure-item.component.ts ***!
  \******************************************************************************/
/*! exports provided: ProcedureItemComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ProcedureItemComponent", function() { return ProcedureItemComponent; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var _models_procedure__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @models/procedure */ "./src/app/shared/models/procedure/index.ts");
/* harmony import */ var _shared_decorators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @shared/decorators */ "./src/app/shared/decorators/index.ts");
/* harmony import */ var _modules__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @modules */ "./src/app/core/modules/index.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




var ProcedureItemComponent = /** @class */ (function () {
    function ProcedureItemComponent() {
        this.delete = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.select = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.copied = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.pasteOn = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.model = _modules__WEBPACK_IMPORTED_MODULE_3__["_parameterTypes"].model;
        this.constList = _modules__WEBPACK_IMPORTED_MODULE_3__["_parameterTypes"].constList;
        this.ProcedureTypes = _models_procedure__WEBPACK_IMPORTED_MODULE_1__["ProcedureTypes"];
    }
    // delete this procedure
    ProcedureItemComponent.prototype.emitDelete = function () {
        this.delete.emit();
    };
    // select this procedure
    ProcedureItemComponent.prototype.emitSelect = function (event, procedure) {
        event.stopPropagation();
        this.select.emit({ "ctrl": event.ctrlKey, "prod": procedure });
    };
    // delete child procedure (after receiving emitDelete from child procedure)
    ProcedureItemComponent.prototype.deleteChild = function (index) {
        this.data.children.splice(index, 1);
    };
    // select child procedure (after receiving emitSelect from child procedure)
    ProcedureItemComponent.prototype.selectChild = function (event, procedure) {
        this.select.emit(event);
    };
    ProcedureItemComponent.prototype.markPrint = function () {
        this.data.print = !this.data.print;
    };
    ProcedureItemComponent.prototype.markDisabled = function () {
        this.data.enabled = !this.data.enabled;
    };
    ProcedureItemComponent.prototype.canBePrinted = function () {
        return (this.data.argCount > 0 && this.data.args[0].name == 'var_name');
    };
    // stopPropagation to prevent cut/paste with input box focused
    ProcedureItemComponent.prototype.stopProp = function (event) {
        event.stopPropagation();
    };
    // modify input: replace space " " with underscore "_"
    ProcedureItemComponent.prototype.varMod = function (event) {
        if (!event)
            return event;
        var str = event.trim();
        str = str.replace(/ /g, "_");
        return str;
    };
    __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(),
        __metadata("design:type", Object)
    ], ProcedureItemComponent.prototype, "data", void 0);
    __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"])(),
        __metadata("design:type", Object)
    ], ProcedureItemComponent.prototype, "delete", void 0);
    __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"])(),
        __metadata("design:type", Object)
    ], ProcedureItemComponent.prototype, "select", void 0);
    __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"])(),
        __metadata("design:type", Object)
    ], ProcedureItemComponent.prototype, "copied", void 0);
    __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"])(),
        __metadata("design:type", Object)
    ], ProcedureItemComponent.prototype, "pasteOn", void 0);
    ProcedureItemComponent = __decorate([
        _shared_decorators__WEBPACK_IMPORTED_MODULE_2__["ProcedureTypesAware"],
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"])({
            selector: 'procedure-item',
            template: __webpack_require__(/*! ./procedure-item.component.html */ "./src/app/views/view-editor/procedure-item/procedure-item.component.html"),
            styles: [__webpack_require__(/*! ./procedure-item.component.scss */ "./src/app/views/view-editor/procedure-item/procedure-item.component.scss")]
        })
    ], ProcedureItemComponent);
    return ProcedureItemComponent;
}());



/***/ }),

/***/ "./src/app/views/view-editor/toolset/toolset.component.html":
/*!******************************************************************!*\
  !*** ./src/app/views/view-editor/toolset/toolset.component.html ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<ng-container *ngIf=\"nodeType == ''\">\r\n    <!-- basic functions: variable, if, else, else if, for, while, continue, break -->\r\n    <ul class='toolset__basic'>\r\n        <ng-container *ngFor=\"let type of ProcedureTypesArr\">\r\n            <li *ngIf='type.toUpperCase() !== \"FUNCTION\" && type.toUpperCase() !== \"IMPORTED\"'\r\n                (click)='add(ProcedureTypes[type])'> \r\n                {{type}}\r\n            </li>\r\n        </ng-container>\r\n    </ul>\r\n    \r\n    <!--\r\n    <div class='toolset__functions'>\r\n        <section *ngFor='let mod of Modules' >\r\n            <div *ngIf='mod.module.toUpperCase() != \"INPUT\" && mod.module.toUpperCase() != \"OUTPUT\"'>\r\n                <h3>{{ mod.module }}</h3>\r\n                <ul class='toolset__functions--subset'>\r\n                    <li *ngFor='let fn of mod.functions' (click)='add_function(fn)'> {{fn.name}} </li>\r\n                </ul>\r\n            </div>\r\n        </section>\r\n    </div>\r\n    <div class='toolset__functions'>\r\n        <section>\r\n            <h3>Imported</h3>\r\n            <ul class='toolset__functions--subset'>\r\n                <li *ngFor='let fn of functions' (click)='add_imported_function(fn)'> {{fn.name}} \r\n                    <button class='remove-btn' (click)='delete_imported_function(fn)'>\r\n                        <mat-icon class='remove-icon'>close</mat-icon>\r\n                    </button>\r\n                </li>\r\n            </ul>\r\n        </section>\r\n        <br>\r\n        <input type=\"file\" id=\"selectedFile\" (change)=\"import_function($event)\" style=\"display: none;\" />\r\n        <button class='add-btn' onclick=\"document.getElementById('selectedFile').click();\">\r\n            <mat-icon class='add-icon'>open_in_browser</mat-icon>\r\n        </button>\r\n    </div>\r\n    -->\r\n\r\n    <!-- functions from core.modules -->\r\n    <ng-container *ngFor='let mod of Modules' >\r\n\r\n        <button id='{{mod.module}}' class=\"accordion\" \r\n        *ngIf='mod.module.toUpperCase() != \"INPUT\" && mod.module.toUpperCase() != \"OUTPUT\"'\r\n        (click)='toggleAccordion(mod.module)' >{{ mod.module }}</button>\r\n        <div class=\"panel\">\r\n            <ul class='toolset__functions--subset'>\r\n                <li *ngFor='let fn of mod.functions' (click)='add_function(fn)'> {{fn.name}} </li>\r\n            </ul>\r\n        </div>\r\n    </ng-container>\r\n\r\n    <!-- imported functions -->\r\n    <ng-container>\r\n        <button id='imported' class=\"accordion\" \r\n        (click)='toggleAccordion(\"imported\")' >Imported</button>\r\n        <div class=\"panel\">\r\n            <ul class='toolset__functions--subset'>\r\n                <li *ngFor='let fn of functions' (click)='add_imported_function(fn)'> {{fn.name}} \r\n                    <button class='remove-btn' (click)='delete_imported_function(fn)'>\r\n                        <mat-icon class='remove-icon'>close</mat-icon>\r\n                    </button>\r\n                </li>\r\n            </ul>\r\n            <br>\r\n            <input type=\"file\" id=\"selectedFile\" (change)=\"import_function($event)\" style=\"display: none;\" />\r\n            <button class='add-btn' onclick=\"document.getElementById('selectedFile').click();\" title=\"Import Function from File\">\r\n                <mat-icon class='add-icon'>open_in_browser</mat-icon>\r\n            </button>\r\n        </div>\r\n    </ng-container>\r\n</ng-container>\r\n\r\n<!-- functions for input nodes -->\r\n<div id='toolset_inp' class = 'toolset' *ngIf=\"nodeType == 'start'\">\r\n    \r\n    <div class='toolset__functions'>\r\n        <section *ngFor='let mod of Modules' >\r\n            <div *ngIf='mod.module.toUpperCase() == \"INPUT\"'>\r\n                <!-- <h3>{{ mod.module }}</h3> -->\r\n                <ul class='toolset__functions--subset'>\r\n                    <li *ngFor='let fn of mod.functions' (click)='add_function(fn)'> {{fn.name}} </li>\r\n                </ul>\r\n            </div>\r\n        </section>\r\n    </div>\r\n</div>\r\n\r\n<!-- functions for output nodes -->\r\n<div id='toolset_inp' class = 'toolset' *ngIf=\"nodeType == 'end'\">\r\n    <div class='toolset__functions' *ngIf=\"hasProd===false\">\r\n        <section *ngFor='let mod of Modules' >\r\n            <div *ngIf='mod.module.toUpperCase() == \"OUTPUT\"'>\r\n                <!-- <h3>{{ mod.module }}</h3> -->\r\n                <ul class='toolset__functions--subset'>\r\n                    <li *ngFor='let fn of mod.functions' (click)='add_function(fn)'> {{fn.name}} </li>\r\n                </ul>\r\n            </div>\r\n        </section>\r\n    </div>\r\n</div>\r\n"

/***/ }),

/***/ "./src/app/views/view-editor/toolset/toolset.component.scss":
/*!******************************************************************!*\
  !*** ./src/app/views/view-editor/toolset/toolset.component.scss ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ":host {\n  width: 100%;\n  background-color: #efefef; }\n\nul {\n  list-style-type: none;\n  margin: 0px;\n  padding: 0px;\n  padding-left: 15px; }\n\nul li {\n    -webkit-user-select: none;\n       -moz-user-select: none;\n        -ms-user-select: none;\n            user-select: none;\n    margin: 0px;\n    padding: 0px;\n    color: #505050;\n    font-size: 12px;\n    line-height: 18px; }\n\n.remove-btn {\n  background-color: transparent;\n  border: none;\n  height: 13px;\n  float: right; }\n\n.remove-btn .remove-icon {\n    font-size: 11px;\n    height: 11px;\n    color: #505050; }\n\n.add-btn {\n  background-color: transparent;\n  border: none;\n  float: left;\n  padding: 6px;\n  transition: 0.4s; }\n\n.add-btn :hover {\n    background-color: gainsboro; }\n\n.add-btn .add-icon {\n    float: left;\n    color: #505050; }\n\n.accordion {\n  background-color: gainsboro;\n  color: #505050;\n  cursor: pointer;\n  width: 100%;\n  padding: 8px 8px 8px 8px;\n  border: none;\n  display: block;\n  text-align: left;\n  outline: none;\n  font-size: 12px;\n  transition: 0.4s;\n  font-weight: 550; }\n\n.active, .accordion:hover {\n  background-color: #ccc; }\n\n.panel {\n  width: inherit;\n  padding: 0px 10px 0px 0px;\n  display: none;\n  background-color: #efefef;\n  overflow: hidden; }\n"

/***/ }),

/***/ "./src/app/views/view-editor/toolset/toolset.component.ts":
/*!****************************************************************!*\
  !*** ./src/app/views/view-editor/toolset/toolset.component.ts ***!
  \****************************************************************/
/*! exports provided: ToolsetComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ToolsetComponent", function() { return ToolsetComponent; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var _models_procedure__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @models/procedure */ "./src/app/shared/models/procedure/index.ts");
/* harmony import */ var circular_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! circular-json */ "./node_modules/circular-json/build/circular-json.node.js");
/* harmony import */ var circular_json__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(circular_json__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _modules__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @modules */ "./src/app/core/modules/index.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (undefined && undefined.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};




var keys = Object.keys(_models_procedure__WEBPACK_IMPORTED_MODULE_1__["ProcedureTypes"]);
var ToolsetComponent = /** @class */ (function () {
    function ToolsetComponent() {
        this.select = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.delete = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.imported = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.Modules = ToolsetComponent_1.ModuleAware();
        this.ProcedureTypes = _models_procedure__WEBPACK_IMPORTED_MODULE_1__["ProcedureTypes"];
        this.ProcedureTypesArr = keys.slice(keys.length / 2);
    }
    ToolsetComponent_1 = ToolsetComponent;
    // add selected basic function as a new procedure
    ToolsetComponent.prototype.add = function (type) {
        this.select.emit({ type: type, data: undefined });
    };
    // add selected function from core.modules as a new procedure
    ToolsetComponent.prototype.add_function = function (fnData) {
        // create a fresh copy of the params to avoid linked objects
        // todo: figure out
        fnData.args = fnData.args.map(function (arg) {
            return { name: arg.name, value: arg.value, default: arg.default };
        });
        this.select.emit({ type: _models_procedure__WEBPACK_IMPORTED_MODULE_1__["ProcedureTypes"].Function, data: fnData });
    };
    // add selected imported function as a new procedure
    ToolsetComponent.prototype.add_imported_function = function (fnData) {
        fnData.args = fnData.args.map(function (arg) {
            return { name: arg.name, value: arg.value };
        });
        this.select.emit({ type: _models_procedure__WEBPACK_IMPORTED_MODULE_1__["ProcedureTypes"].Imported, data: fnData });
    };
    // delete imported function
    ToolsetComponent.prototype.delete_imported_function = function (fnData) {
        this.delete.emit(fnData);
    };
    // import a flowchart as function
    ToolsetComponent.prototype.import_function = function (event) {
        return __awaiter(this, void 0, void 0, function () {
            var p, fnc;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        p = new Promise(function (resolve) {
                            var reader = new FileReader();
                            reader.onload = function () {
                                var e_1, _a;
                                // parse the flowchart
                                var fl = circular_json__WEBPACK_IMPORTED_MODULE_2__["parse"](reader.result.toString()).flowchart;
                                // create function
                                var funcs = [];
                                var func = {
                                    module: {
                                        name: fl.name,
                                        nodes: fl.nodes,
                                        edges: fl.edges
                                    },
                                    name: event.target.files[0].name.split('.')[0],
                                };
                                // go through the nodes
                                func.argCount = fl.nodes[0].procedure.length;
                                func.args = fl.nodes[0].procedure.map(function (prod) {
                                    return {
                                        name: prod.args[prod.argCount - 2].value.substring(1, prod.args[prod.argCount - 2].value.length - 1),
                                        default: prod.args[prod.argCount - 1].default,
                                        value: undefined,
                                        min: undefined,
                                        max: undefined
                                    };
                                });
                                if (!func.argCount) {
                                    resolve('error');
                                }
                                // add func and all the imported functions of the imported flowchart to funcs
                                funcs.push(func);
                                try {
                                    for (var _b = __values(fl.functions), _c = _b.next(); !_c.done; _c = _b.next()) {
                                        var i = _c.value;
                                        funcs.push(i);
                                    }
                                }
                                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                                finally {
                                    try {
                                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                                    }
                                    finally { if (e_1) throw e_1.error; }
                                }
                                resolve(funcs);
                            };
                            reader.onerror = function () {
                                resolve('error');
                            };
                            reader.readAsText(event.target.files[0]);
                        });
                        return [4 /*yield*/, p];
                    case 1:
                        fnc = _a.sent();
                        document.getElementById('selectedFile').value = "";
                        if (fnc === 'error') {
                            console.warn('Error reading file');
                            return [2 /*return*/];
                        }
                        this.imported.emit(fnc);
                        return [2 /*return*/];
                }
            });
        });
    };
    ToolsetComponent.prototype.toggleAccordion = function (id) {
        var acc = document.getElementById(id);
        //var acc = document.getElementsByClassName("accordion");
        acc.classList.toggle("active");
        var panel = acc.nextElementSibling;
        console.log(panel);
        if (panel.style.display === "block") {
            panel.style.display = "none";
        }
        else {
            panel.style.display = "block";
        }
    };
    // todo: bug fix for defaults
    ToolsetComponent.extract_params = function (func) {
        var fnStr = func.toString().replace(/((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg, '');
        var result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).split(","); //.match( /([^\s,]+)/g);
        if (result === null || result[0] == "") {
            result = [];
        }
        var final_result = result.map(function (r) {
            r = r.trim();
            var r_value = r.split("=");
            if (r_value.length == 1) {
                return { name: r_value[0].trim(), value: undefined, default: 0 };
            }
            else {
                return { name: r_value[0].trim(), value: undefined, default: 0 };
            }
        });
        var hasReturn = true;
        if (fnStr.indexOf("return") === -1 || fnStr.indexOf("return;") !== -1) {
            hasReturn = false;
        }
        return [final_result, hasReturn];
    };
    ToolsetComponent.ModuleAware = function () {
        var e_2, _a;
        var module_list = [];
        for (var m_name in _modules__WEBPACK_IMPORTED_MODULE_3__) {
            if (m_name[0] == '_')
                continue;
            var modObj = {};
            modObj.module = m_name;
            modObj.functions = [];
            try {
                for (var _b = __values(Object.keys(_modules__WEBPACK_IMPORTED_MODULE_3__[m_name])), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var fn_name = _c.value;
                    var func = _modules__WEBPACK_IMPORTED_MODULE_3__[m_name][fn_name];
                    var fnObj = {};
                    fnObj.module = m_name;
                    fnObj.name = fn_name;
                    fnObj.argCount = func.length;
                    var args = ToolsetComponent_1.extract_params(func);
                    fnObj.args = args[0];
                    fnObj.hasReturn = args[1];
                    modObj.functions.push(fnObj);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
            }
            module_list.push(modObj);
        }
        return module_list;
    };
    var ToolsetComponent_1;
    __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"])(),
        __metadata("design:type", Object)
    ], ToolsetComponent.prototype, "select", void 0);
    __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"])(),
        __metadata("design:type", Object)
    ], ToolsetComponent.prototype, "delete", void 0);
    __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"])(),
        __metadata("design:type", Object)
    ], ToolsetComponent.prototype, "imported", void 0);
    __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(),
        __metadata("design:type", Array)
    ], ToolsetComponent.prototype, "functions", void 0);
    __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(),
        __metadata("design:type", String)
    ], ToolsetComponent.prototype, "nodeType", void 0);
    __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(),
        __metadata("design:type", Boolean)
    ], ToolsetComponent.prototype, "hasProd", void 0);
    ToolsetComponent = ToolsetComponent_1 = __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"])({
            selector: 'toolset',
            template: __webpack_require__(/*! ./toolset.component.html */ "./src/app/views/view-editor/toolset/toolset.component.html"),
            styles: [__webpack_require__(/*! ./toolset.component.scss */ "./src/app/views/view-editor/toolset/toolset.component.scss")]
        }),
        __metadata("design:paramtypes", [])
    ], ToolsetComponent);
    return ToolsetComponent;
}());



/***/ }),

/***/ "./src/app/views/view-editor/view-editor.component.html":
/*!**************************************************************!*\
  !*** ./src/app/views/view-editor/view-editor.component.html ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<h2>{{node?.name}}</h2>\r\n\r\n<div class='container--editor' (mouseenter)='activateCopyPaste()'  (mouseleave)='deactivateCopyPaste()'\r\n(copy)='copyProd()' (cut)='cutProd($event)' (paste)='pasteProd($event)'>\r\n\r\n\t<div class='container__content'>\r\n\t\t<!-- toolset on the left side -->\r\n\t\t<div class=\"container--toolset\">\r\n\t\t\t<toolset [functions]='flowchart.functions' \r\n\t\t\t[nodeType]='node.type' \r\n\t\t\t[hasProd]='node.procedure.length>0' \r\n\t\t\t(delete)='deleteFunction($event)' \r\n\t\t\t(select)='add($event)' \r\n\t\t\t(imported)='importFunction($event)'></toolset>\r\n\t\t</div>\r\n\r\n\t\t<!-- procedure editor on the right side -->\r\n\t\t<div id='procedure' class=\"container--procedure\">\r\n\t\t\t<!-- parameter-editor only for start node -->\r\n\t\t\t<parameter-editor *ngIf=\"node.type == 'start'\" [flowchart]='flowchart' [node]='node'></parameter-editor>\r\n\r\n\t\t\t<!-- list of procedure items for all nodes -->\r\n\t\t\t<procedure-item \r\n\t\t\t*ngFor=\"let line of node?.procedure; let idx=index\" \r\n\t\t\t[data]=\"line\"\r\n\t\t\t(select)=\"selectProcedure($event,line)\"\r\n\t\t\t(delete)=\"deleteChild(idx)\"></procedure-item>\r\n\t\t\t<br>\r\n\t\t\t<br>\r\n\t\t</div>\r\n\t</div>\r\n\r\n</div>\r\n"

/***/ }),

/***/ "./src/app/views/view-editor/view-editor.component.scss":
/*!**************************************************************!*\
  !*** ./src/app/views/view-editor/view-editor.component.scss ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ".container--editor {\n  display: block;\n  height: 95%;\n  width: 100%; }\n\n.container__heading {\n  display: block;\n  text-align: center;\n  width: 98%; }\n\nh2 {\n  color: #505050;\n  text-align: left;\n  width: 100%;\n  font-size: 12px;\n  line-height: 14px;\n  font-weight: 600;\n  padding-left: 15px; }\n\nhr {\n  border-top: 2px solid #efefef; }\n\n.container__content {\n  display: inline-flex;\n  width: 100%;\n  min-height: 95%;\n  overflow: inherit; }\n\n.container--toolset {\n  display: inline-flex;\n  width: 20%; }\n\n.container--procedure {\n  display: block;\n  width: 76%;\n  bottom: 10px;\n  background-color: #fafafa;\n  padding: none; }\n\nhr {\n  border-top: 2px solid #efefef;\n  width: 100%; }\n\n/*\r\n$header-height: 45px;\r\n\r\n.container{\r\n    position: relative;\r\n    overflow: auto;\r\n    margin: 10px 10px;\r\n\r\n    display: flex;\r\n    flex-direction: column;\r\n    justify-content: space-around;\r\n        \r\n    h1, h2, h3, h4, h5, h6, p{\r\n        margin: 0px;\r\n        padding: 0px;\r\n    }\r\n\r\n    .container__header{\r\n        flex: 0 1 auto;\r\n        min-height: $header-height;\r\n\r\n        display: flex;\r\n        flex-direction: row;\r\n        justify-content: space-between;\r\n\r\n        padding: 0px 0px 0px 15px;\r\n\r\n        background-color: #3F4651;\r\n        color: #E7BF00;\r\n        \r\n        line-height: $header-height;\r\n        text-transform: uppercase;\r\n    \r\n        font-size: 18px;\r\n        font-weight: 600;\r\n        text-align: center;\r\n    }\r\n\r\n    .container__content{\r\n        flex-grow: 1;\r\n        height: 0px;\r\n        border: 2px solid #3F4651;\r\n        overflow: auto;\r\n\r\n        split{\r\n            height: 100%;\r\n        }\r\n    }\r\n\r\n    .container__footer{\r\n        text-align: center;\r\n        font-size: 12px;\r\n        line-height: 18px;\r\n\r\n        background-color: #3F4651;\r\n        color: #E7BF00;\r\n    }\r\n}\r\n\r\n\r\n.content__panel{\r\n    height: 100%; \r\n    overflow: auto;\r\n\r\n    //padding: 10px 15px;\r\n}\r\n*/\n"

/***/ }),

/***/ "./src/app/views/view-editor/view-editor.component.ts":
/*!************************************************************!*\
  !*** ./src/app/views/view-editor/view-editor.component.ts ***!
  \************************************************************/
/*! exports provided: ViewEditorComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ViewEditorComponent", function() { return ViewEditorComponent; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var _models_node__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @models/node */ "./src/app/shared/models/node/index.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __values = (undefined && undefined.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};


var ViewEditorComponent = /** @class */ (function () {
    function ViewEditorComponent() {
        this.imported = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.delete_Function = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.copyCheck = false;
    }
    // add a procedure
    ViewEditorComponent.prototype.add = function (data) {
        _models_node__WEBPACK_IMPORTED_MODULE_1__["NodeUtils"].add_procedure(this.node, data.type, data.data);
    };
    // delete a procedure
    ViewEditorComponent.prototype.deleteChild = function (index) {
        this.node.procedure.splice(index, 1);
        _models_node__WEBPACK_IMPORTED_MODULE_1__["NodeUtils"].deselect_procedure(this.node);
    };
    // select a procedure
    ViewEditorComponent.prototype.selectProcedure = function (event, line) {
        _models_node__WEBPACK_IMPORTED_MODULE_1__["NodeUtils"].select_procedure(this.node, event.prod, event.ctrl || false);
    };
    // copy selected procedures
    ViewEditorComponent.prototype.copyProd = function () {
        if (!this.copyCheck)
            return;
        console.log('copying', this.node.state.procedure);
        this.copiedProd = this.node.state.procedure;
    };
    // cut selected procedures
    ViewEditorComponent.prototype.cutProd = function (event) {
        var e_1, _a;
        if (!this.copyCheck || document.activeElement.nodeName == "INPUT")
            return;
        console.log('cutting', this.node.state.procedure);
        this.copiedProd = this.node.state.procedure;
        var parentArray;
        try {
            for (var _b = __values(this.copiedProd), _c = _b.next(); !_c.done; _c = _b.next()) {
                var prod = _c.value;
                if (prod.parent) {
                    parentArray = prod.parent.children;
                }
                else
                    parentArray = this.node.procedure;
                for (var i = 0; i < parentArray.length; i++) {
                    if (parentArray[i] === prod) {
                        parentArray.splice(i, 1);
                        break;
                    }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        _models_node__WEBPACK_IMPORTED_MODULE_1__["NodeUtils"].deselect_procedure(this.node);
    };
    // paste copied procedures
    ViewEditorComponent.prototype.pasteProd = function (event) {
        if (this.copyCheck && document.activeElement.nodeName.toUpperCase() != "INPUT") {
            var pastingPlace = this.node.state.procedure[0];
            if (pastingPlace === undefined) {
                for (var i = 0; i < this.copiedProd.length; i++) {
                    console.log('pasting', this.copiedProd[i].ID);
                    _models_node__WEBPACK_IMPORTED_MODULE_1__["NodeUtils"].paste_procedure(this.node, this.copiedProd[i]);
                    this.node.state.procedure[0].selected = false;
                    this.node.state.procedure = [];
                }
            }
            else if (pastingPlace.children) {
                for (var i = 0; i < this.copiedProd.length; i++) {
                    console.log('pasting', this.copiedProd[i].ID);
                    _models_node__WEBPACK_IMPORTED_MODULE_1__["NodeUtils"].paste_procedure(this.node, this.copiedProd[i]);
                    this.node.state.procedure[0].selected = false;
                    pastingPlace.selected = true;
                    this.node.state.procedure = [pastingPlace];
                }
            }
            else {
                for (var i = this.copiedProd.length - 1; i >= 0; i--) {
                    console.log('pasting', this.copiedProd[i].ID);
                    _models_node__WEBPACK_IMPORTED_MODULE_1__["NodeUtils"].paste_procedure(this.node, this.copiedProd[i]);
                    this.node.state.procedure[0].selected = false;
                    pastingPlace.selected = true;
                    this.node.state.procedure = [pastingPlace];
                }
            }
            //this.copiedProd = undefined;
        }
    };
    // activate copying/cutting/pasting when the mouse hovers over the procedure list
    ViewEditorComponent.prototype.activateCopyPaste = function () {
        this.copyCheck = true;
    };
    // deactivate copying/cutting/pasting when the mouse exit the procedure list
    ViewEditorComponent.prototype.deactivateCopyPaste = function () {
        this.copyCheck = false;
    };
    // import a flowchart as function
    ViewEditorComponent.prototype.importFunction = function (event) {
        var e_2, _a;
        try {
            for (var event_1 = __values(event), event_1_1 = event_1.next(); !event_1_1.done; event_1_1 = event_1.next()) {
                var func = event_1_1.value;
                this.flowchart.functions.push(func);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (event_1_1 && !event_1_1.done && (_a = event_1.return)) _a.call(event_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
    };
    // delete an imported function
    ViewEditorComponent.prototype.deleteFunction = function (event) {
        for (var i = 0; i < this.flowchart.functions.length; i++) {
            if (this.flowchart.functions[i] == event) {
                this.flowchart.functions.splice(i, 1);
                break;
            }
        }
    };
    __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(),
        __metadata("design:type", Object)
    ], ViewEditorComponent.prototype, "flowchart", void 0);
    __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(),
        __metadata("design:type", Object)
    ], ViewEditorComponent.prototype, "node", void 0);
    __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"])(),
        __metadata("design:type", Object)
    ], ViewEditorComponent.prototype, "imported", void 0);
    __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"])(),
        __metadata("design:type", Object)
    ], ViewEditorComponent.prototype, "delete_Function", void 0);
    ViewEditorComponent = __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"])({
            selector: 'view-editor',
            template: __webpack_require__(/*! ./view-editor.component.html */ "./src/app/views/view-editor/view-editor.component.html"),
            styles: [__webpack_require__(/*! ./view-editor.component.scss */ "./src/app/views/view-editor/view-editor.component.scss")]
        }),
        __metadata("design:paramtypes", [])
    ], ViewEditorComponent);
    return ViewEditorComponent;
}());



/***/ }),

/***/ "./src/app/views/view-editor/view-editor.module.ts":
/*!*********************************************************!*\
  !*** ./src/app/views/view-editor/view-editor.module.ts ***!
  \*********************************************************/
/*! exports provided: ViewEditorModule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ViewEditorModule", function() { return ViewEditorModule; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm5/common.js");
/* harmony import */ var _shared_shared_module__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @shared/shared.module */ "./src/app/shared/shared.module.ts");
/* harmony import */ var _view_editor_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./view-editor.component */ "./src/app/views/view-editor/view-editor.component.ts");
/* harmony import */ var _procedure_item_procedure_item_component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./procedure-item/procedure-item.component */ "./src/app/views/view-editor/procedure-item/procedure-item.component.ts");
/* harmony import */ var _toolset_toolset_component__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./toolset/toolset.component */ "./src/app/views/view-editor/toolset/toolset.component.ts");
/* harmony import */ var _parameter_editor_parameter_editor_component__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./parameter-editor/parameter-editor.component */ "./src/app/views/view-editor/parameter-editor/parameter-editor.component.ts");
/* harmony import */ var _parameter_editor_procedure_input_editor_procedure_input_editor_component__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./parameter-editor/procedure-input-editor/procedure-input-editor.component */ "./src/app/views/view-editor/parameter-editor/procedure-input-editor/procedure-input-editor.component.ts");
/* harmony import */ var _angular_material__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @angular/material */ "./node_modules/@angular/material/esm5/material.es5.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};









var ViewEditorModule = /** @class */ (function () {
    function ViewEditorModule() {
    }
    ViewEditorModule = __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"])({
            declarations: [
                _view_editor_component__WEBPACK_IMPORTED_MODULE_3__["ViewEditorComponent"],
                _procedure_item_procedure_item_component__WEBPACK_IMPORTED_MODULE_4__["ProcedureItemComponent"],
                _toolset_toolset_component__WEBPACK_IMPORTED_MODULE_5__["ToolsetComponent"],
                _parameter_editor_parameter_editor_component__WEBPACK_IMPORTED_MODULE_6__["ParameterEditorComponent"],
                _parameter_editor_procedure_input_editor_procedure_input_editor_component__WEBPACK_IMPORTED_MODULE_7__["procedureInputEditorComponent"],
            ],
            entryComponents: [],
            imports: [
                _angular_common__WEBPACK_IMPORTED_MODULE_1__["CommonModule"],
                _shared_shared_module__WEBPACK_IMPORTED_MODULE_2__["SharedModule"],
                _angular_material__WEBPACK_IMPORTED_MODULE_8__["MatSliderModule"],
                _angular_material__WEBPACK_IMPORTED_MODULE_8__["MatIconModule"],
                _angular_material__WEBPACK_IMPORTED_MODULE_8__["MatExpansionModule"],
                _angular_material__WEBPACK_IMPORTED_MODULE_8__["MatButtonModule"],
                _angular_material__WEBPACK_IMPORTED_MODULE_8__["MatSelectModule"],
            ],
            exports: [
                _view_editor_component__WEBPACK_IMPORTED_MODULE_3__["ViewEditorComponent"],
            ],
            providers: []
        }),
        __metadata("design:paramtypes", [])
    ], ViewEditorModule);
    return ViewEditorModule;
}());



/***/ }),

/***/ "./src/app/views/view-publish/view-publish.component.html":
/*!****************************************************************!*\
  !*** ./src/app/views/view-publish/view-publish.component.html ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "<parameter-viewer [flowchart]='flowchart' [startNode]='flowchart.nodes[0]' [endNode]='getEndNode()'></parameter-viewer>\r\n\r\n<!--\r\n<div class='container'>\r\n\t<div class='container__content'>\r\n\t\r\n\t\t< !-- Side content__Panel: Split into three panes -- >\r\n\t\t<as-split direction=\"vertical\">\r\n\r\n\t\t\t<as-split-area size='20'>\r\n\t\t\t\t<div class='content__panel'>\r\n\t\t\t\t\t<parameter-viewer [node]='flowchart.nodes[0]'></parameter-viewer>\r\n\t\t\t\t</div>\r\n\t\t\t</as-split-area>\r\n\t\t\t\r\n\t\t\t< !-- \r\n\t\t\t<as-split-area size='20'>\r\n\t\t\t\t<div class='content__panel'>\r\n\t\t\t\t\t\t<flowchart [data]=\"flowchart\" (select)='selectNode($event)'></flowchart>\r\n\t\t\t\t</div>\r\n\t\t\t</as-split-area> \r\n\t\t\t-- >\r\n\t\t\r\n\t\t</as-split>\r\n\t\t\t\t\t\r\n\t</div>\r\n</div>\r\n-->\r\n<!--\r\n<div class='container'>\r\n\r\n\t<div class='container__header'>\r\n\t\tMobius Viewer\t\r\n\t\t<navigation></navigation>\r\n\t\t<execute [flowchart]='flowchart'></execute>\r\n\t</div>\r\n\r\n\t<div class='container__content'>\r\n\t\t<file-new *ngIf='!flowchart'></file-new>\r\n\r\n\t\t<as-split direction=\"horizontal\" *ngIf='flowchart'>\r\n\t\t\t<as-split-area size=\"60\">\r\n\r\n\t\t\t\t<div class='content__panel' *ngIf='flowchart.meta.selected_nodes[0] !== undefined'>\r\n\t\t\t\t\t<mviewer [node]='flowchart.nodes[flowchart.meta.selected_nodes[0]]'></mviewer>\r\n\t\t\t\t</div>\r\n\t\t\t</as-split-area>\r\n\t\t\t\r\n\t\t\t<as-split-area size=\"40\">\r\n\t\r\n\r\n\t\t\t\t<as-split direction=\"vertical\">\r\n\t\r\n\t\t\t\t\t\t<as-split-area size='20'>\r\n\t\t\t\t\t\t\t<div class='content__panel'>\r\n\t\t\t\t\t\t\t\t<parameter-viewer [node]='flowchart.nodes[0]'></parameter-viewer>\r\n\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t</as-split-area>\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t\t</as-split>\r\n\t\t\t\t\t\r\n\t\t\t</as-split-area>\r\n\t\t</as-split>\r\n\t</div>\r\n\r\n\t<div class='container__footer'>\r\n\t\tCopyright © 2018 Design Automation Lab, NUS. All Rights Reserved.\r\n\t</div>\r\n\t\r\n\t\r\n</div>\r\n-->"

/***/ }),

/***/ "./src/app/views/view-publish/view-publish.component.scss":
/*!****************************************************************!*\
  !*** ./src/app/views/view-publish/view-publish.component.scss ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ".container {\n  position: relative;\n  overflow: auto;\n  height: 100%;\n  display: flex;\n  flex-direction: column;\n  justify-content: space-around; }\n  .container h1, .container h2, .container h3, .container h4, .container h5, .container h6, .container p {\n    margin: 0px;\n    padding: 0px; }\n  .container .container__header {\n    flex: 0 1 auto;\n    min-height: 45px;\n    display: flex;\n    flex-direction: row;\n    justify-content: space-between;\n    padding: 0px 0px 0px 15px;\n    background-color: #3F4651;\n    color: #E7BF00;\n    line-height: 45px;\n    text-transform: uppercase;\n    font-size: 18px;\n    font-weight: 600;\n    text-align: center; }\n  .container .container__content {\n    flex-grow: 1;\n    height: 0px;\n    border: none;\n    overflow: auto; }\n  .container .container__content split {\n      height: 100%; }\n  .container .container__footer {\n    text-align: center;\n    font-size: 12px;\n    line-height: 18px;\n    background-color: #3F4651;\n    color: #E7BF00; }\n  .content__panel {\n  height: 100%;\n  overflow: auto;\n  padding: 10px 15px; }\n"

/***/ }),

/***/ "./src/app/views/view-publish/view-publish.component.ts":
/*!**************************************************************!*\
  !*** ./src/app/views/view-publish/view-publish.component.ts ***!
  \**************************************************************/
/*! exports provided: ViewPublishComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ViewPublishComponent", function() { return ViewPublishComponent; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __values = (undefined && undefined.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};

var ViewPublishComponent = /** @class */ (function () {
    function ViewPublishComponent() {
    }
    ViewPublishComponent.prototype.selectNode = function (node_index) {
        if (typeof (node_index) == 'number') {
            this.flowchart.meta.selected_nodes = [node_index];
        }
    };
    ViewPublishComponent.prototype.getEndNode = function () {
        var e_1, _a;
        try {
            for (var _b = __values(this.flowchart.nodes), _c = _b.next(); !_c.done; _c = _b.next()) {
                var node = _c.value;
                if (node.type == 'end')
                    return node;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"])(),
        __metadata("design:type", Object)
    ], ViewPublishComponent.prototype, "flowchart", void 0);
    ViewPublishComponent = __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["Component"])({
            selector: 'view-publish',
            template: __webpack_require__(/*! ./view-publish.component.html */ "./src/app/views/view-publish/view-publish.component.html"),
            styles: [__webpack_require__(/*! ./view-publish.component.scss */ "./src/app/views/view-publish/view-publish.component.scss")]
        }),
        __metadata("design:paramtypes", [])
    ], ViewPublishComponent);
    return ViewPublishComponent;
}());



/***/ }),

/***/ "./src/app/views/view-publish/view-publish.module.ts":
/*!***********************************************************!*\
  !*** ./src/app/views/view-publish/view-publish.module.ts ***!
  \***********************************************************/
/*! exports provided: ViewPublishModule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ViewPublishModule", function() { return ViewPublishModule; });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/common */ "./node_modules/@angular/common/fesm5/common.js");
/* harmony import */ var _shared_shared_module__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @shared/shared.module */ "./src/app/shared/shared.module.ts");
/* harmony import */ var _view_publish_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./view-publish.component */ "./src/app/views/view-publish/view-publish.component.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




var ViewPublishModule = /** @class */ (function () {
    function ViewPublishModule() {
    }
    ViewPublishModule = __decorate([
        Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"])({
            declarations: [
                _view_publish_component__WEBPACK_IMPORTED_MODULE_3__["ViewPublishComponent"]
            ],
            exports: [
                _view_publish_component__WEBPACK_IMPORTED_MODULE_3__["ViewPublishComponent"]
            ],
            imports: [
                _angular_common__WEBPACK_IMPORTED_MODULE_1__["CommonModule"],
                _shared_shared_module__WEBPACK_IMPORTED_MODULE_2__["SharedModule"],
            ],
            entryComponents: [],
            providers: []
        }),
        __metadata("design:paramtypes", [])
    ], ViewPublishModule);
    return ViewPublishModule;
}());



/***/ }),

/***/ "./src/environments/environment.ts":
/*!*****************************************!*\
  !*** ./src/environments/environment.ts ***!
  \*****************************************/
/*! exports provided: environment */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "environment", function() { return environment; });
// The file contents for the current environment will overwrite these during build.
// The build system defaults to the dev environment which uses `environment.ts`, but if you do
// `ng build --env=prod` then `environment.prod.ts` will be used instead.
// The list of which env maps to which file can be found in `.angular-cli.json`.
var environment = {
    production: false
};


/***/ }),

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "./node_modules/@angular/core/fesm5/core.js");
/* harmony import */ var _angular_platform_browser_dynamic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/platform-browser-dynamic */ "./node_modules/@angular/platform-browser-dynamic/fesm5/platform-browser-dynamic.js");
/* harmony import */ var _app_appmodule_app_module__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./app/appmodule/app.module */ "./src/app/appmodule/app.module.ts");
/* harmony import */ var _environments_environment__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./environments/environment */ "./src/environments/environment.ts");




if (_environments_environment__WEBPACK_IMPORTED_MODULE_3__["environment"].production) {
    Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__["enableProdMode"])();
}
window['CESIUM_BASE_URL'] = 'assets/cesium';
Object(_angular_platform_browser_dynamic__WEBPACK_IMPORTED_MODULE_1__["platformBrowserDynamic"])().bootstrapModule(_app_appmodule_app_module__WEBPACK_IMPORTED_MODULE_2__["AppModule"])
    .catch(function (err) { return console.log(err); });


/***/ }),

/***/ 0:
/*!***************************!*\
  !*** multi ./src/main.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! C:\Users\akibdpt\Documents\Angular\mobius-parametric-modeller\src\main.ts */"./src/main.ts");


/***/ })

},[[0,"runtime","vendor"]]]);
//# sourceMappingURL=main.js.map